<!DOCTYPE html>
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>14&nbsp;Exercises</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><link rel="stylesheet" type="text/css" href="extra.css" title="default"/><link rel="stylesheet" type="text/css" href="faq.css" title="default"/><link rel="stylesheet" type="text/css" href="fancyverb.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="accordion.js"></script><script type="text/javascript" src="quiz.js"></script><script type="text/javascript" src="manual-racket.js"></script></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">CMSC 330 Lecture Notes</a></td></tr></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="intro.html" class="tocviewlink" data-pltdoc="x">Introduction</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="ocaml.html" class="tocviewlink" data-pltdoc="x">Functional Programming with OCaml</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="imperative-ocaml.html" class="tocviewlink" data-pltdoc="x">Imperative Programming with OCaml</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="pbt.html" class="tocviewlink" data-pltdoc="x">Property-<wbr></wbr>Based Randomized Testing (PBT)</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="regexp.html" class="tocviewlink" data-pltdoc="x">OCaml Regular Expressions</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="Finite_Automata.html" class="tocviewlink" data-pltdoc="x">Finite Automata</a></td></tr><tr><td align="right">7&nbsp;</td><td><a href="Context_Free_Grammars.html" class="tocviewlink" data-pltdoc="x">Context Free Grammars</a></td></tr><tr><td align="right">8&nbsp;</td><td><a href="Parsing.html" class="tocviewlink" data-pltdoc="x">Parsing</a></td></tr><tr><td align="right">9&nbsp;</td><td><a href="Operational_Semantics.html" class="tocviewlink" data-pltdoc="x">Operational Semantics</a></td></tr><tr><td align="right">10&nbsp;</td><td><a href="Type_Checking.html" class="tocviewlink" data-pltdoc="x">Type Checking</a></td></tr><tr><td align="right">11&nbsp;</td><td><a href="Lambda_Calculus.html" class="tocviewlink" data-pltdoc="x">Lambda Calculus</a></td></tr><tr><td align="right">12&nbsp;</td><td><a href="Rust.html" class="tocviewlink" data-pltdoc="x">Rust</a></td></tr><tr><td align="right">13&nbsp;</td><td><a href="Software_Security.html" class="tocviewlink" data-pltdoc="x">Software Security</a></td></tr><tr><td align="right">14&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Exercises</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td>14&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Exercises</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">14.1&nbsp;</td><td><a href="#%28part._functional-ocaml%29" class="tocviewlink" data-pltdoc="x">Functional OCaml</a></td></tr><tr><td align="right">14.2&nbsp;</td><td><a href="#%28part._exercise-imperative-ocaml%29" class="tocviewlink" data-pltdoc="x">Imperative OCaml</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">14.1<span class="stt">&nbsp;</span></span><a href="#%28part._functional-ocaml%29" class="tocsubseclink" data-pltdoc="x">Functional OCaml</a></td></tr><tr><td><span class="tocsublinknumber">14.2<span class="stt">&nbsp;</span></span><a href="#%28part._exercise-imperative-ocaml%29" class="tocsubseclink" data-pltdoc="x">Imperative OCaml</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">9.0</span></div><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="Software_Security.html" title="backward to &quot;13 Software Security&quot;" data-pltdoc="x" rel="prev">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;CMSC 330 Lecture Notes&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<span class="nonavigation">next &rarr;</span></span>&nbsp;</div><section class="SsectionLevel2" id="section 14"><h2 class="heading">14<span class="stt">&nbsp;</span><a name="(part._exercises)"></a>Exercises<span class="button-group"><a href="#(part._exercises)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h2><section class="SsectionLevel3" id="section 14.1"><h3 class="heading">14.1<span class="stt">&nbsp;</span><a name="(part._functional-ocaml)"></a>Functional OCaml<span class="button-group"><a href="#(part._functional-ocaml)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h3><details class="SubFlow accordion-section"><summary><span style="font-weight: bold">Programming Language Concepts</span></summary><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>Due to OCaml&rsquo;s type constraints, you cannot make a list of functions.</p><p><label class="quiz-option"><input type="radio" name="sp25-1-3" value="true"/> True</label></p><p><label class="quiz-option"><input type="radio" name="sp25-1-3" value="false" data-correct="true"/> False</label></p></blockquote></summary><p>Answer: False. You can make a list of functions in OCaml as long as they all have the same type. For example, <span class="stt">[(fun x -&gt; x + 1); (fun x -&gt; x * 2)]</span> is a valid <span class="stt">(int -&gt; int) list</span>.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>The <span class="stt">=</span> operator in OCaml performs structural (deep) comparison.</p><p><label class="quiz-option"><input type="radio" name="sp16-m1-1" value="1" data-correct="true"/> True</label></p><p><label class="quiz-option"><input type="radio" name="sp16-m1-1" value="2"/> False</label></p></blockquote></summary><p>Answer: True. OCaml&rsquo;s = operator performs deep structural equality, recursively comparing the contents of data structures. Physical equality (==) checks reference identity.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>Given <div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> comb x lst = (x + <span class="dv">5</span>)::lst</span></code></pre></div>
</div>
does OCaml use type inference to recognize that <span class="stt">x</span> must be an <span class="stt">int</span>?</p><p><label class="quiz-option"><input type="radio" name="sp16-m1-2" value="1" data-correct="true"/> True</label></p><p><label class="quiz-option"><input type="radio" name="sp16-m1-2" value="2"/> False</label></p></blockquote></summary><p>Answer: True. The expression x + 5 uses integer addition (+), so OCaml infers x must be of type int without any explicit annotation.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>Given <div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> comb x lst = (x + <span class="dv">5</span>)::lst</span></code></pre></div>
</div> is the expression <span class="stt">comb 2 [8.0;9.0]</span> valid? (Does OCaml perform implicit type conversion?)</p><p><label class="quiz-option"><input type="radio" name="sp16-m1-3" value="1"/> True</label></p><p><label class="quiz-option"><input type="radio" name="sp16-m1-3" value="2" data-correct="true"/> False</label></p></blockquote></summary><p>Answer: False. OCaml does not perform implicit type conversion. Since x + 5 constrains x to int, comb 2 expects an int list. Passing a float list [8.0;9.0] is a type error.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p><span class="stt">fold_left</span>&rsquo;s accumulator can be a list.</p><p><label class="quiz-option"><input type="radio" name="sp25-1-4" value="true" data-correct="true"/> True</label></p><p><label class="quiz-option"><input type="radio" name="sp25-1-4" value="false"/> False</label></p></blockquote></summary><p>Answer: True. The accumulator can be any type, including a list. For example, <span class="stt">fold_left (fun acc x -&gt; x :: acc) [] [1;2;3]</span> uses a list as the accumulator.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p><span class="stt">fold_left</span>&rsquo;s accumulator can be a tuple.</p><p><label class="quiz-option"><input type="radio" name="sp25-1-5" value="true" data-correct="true"/> True</label></p><p><label class="quiz-option"><input type="radio" name="sp25-1-5" value="false"/> False</label></p></blockquote></summary><p>Answer: True. The accumulator can be any type, including a tuple. For example, <span class="stt">fold_left (fun (s, c) x -&gt; (s + x, c + 1)) (0, 0) [1;2;3]</span> uses a tuple to track both sum and count.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>OCaml uses type inference to determine the type of variables.</p><p><label class="quiz-option"><input type="radio" name="sp24-1-1" value="true" data-correct="true"/> True</label></p><p><label class="quiz-option"><input type="radio" name="sp24-1-1" value="false"/> False</label></p></blockquote></summary><p>Answer: True. OCaml has a powerful type inference system that automatically determines the types of expressions without requiring explicit type annotations.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>Functional Programming aims to decrease the amount of side effects.</p><p><label class="quiz-option"><input type="radio" name="sp24-1-3" value="true" data-correct="true"/> True</label></p><p><label class="quiz-option"><input type="radio" name="sp24-1-3" value="false"/> False</label></p></blockquote></summary><p>Answer: True. A core goal of functional programming is to minimize side effects by using pure functions and immutable data.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>Functions are expressions in OCaml.</p><p><label class="quiz-option"><input type="radio" name="sp24-1-4" value="true" data-correct="true"/> True</label></p><p><label class="quiz-option"><input type="radio" name="sp24-1-4" value="false"/> False</label></p></blockquote></summary><p>Answer: True. In OCaml, functions are first-class values and therefore expressions. You can pass them as arguments, return them from other functions, and bind them to variables.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>In OCaml, all values are expressions but not all expressions are values.</p><p><label class="quiz-option"><input type="radio" name="f24-1-1" value="true" data-correct="true"/> True</label></p><p><label class="quiz-option"><input type="radio" name="f24-1-1" value="false"/> False</label></p></blockquote></summary><p>Answer: True. Everything is an expression, but <span class="stt">2 + 3</span> is an expression that is not a value &#8212;<wbr></wbr> it must be evaluated to produce the value <span class="stt">5</span>.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p><span class="stt">map (fun x -&gt; x + 1) a</span> will modify the list <span class="stt">a</span> in-place.</p><p><label class="quiz-option"><input type="radio" name="f24-1-2" value="true"/> True</label></p><p><label class="quiz-option"><input type="radio" name="f24-1-2" value="false" data-correct="true"/> False</label></p></blockquote></summary><p>Answer: False. <span class="stt">map</span> doesn&rsquo;t modify anything in place because lists are immutable in OCaml. It returns a new list.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>Having mutable variables can make it hard to reason about how a program runs.</p><p><label class="quiz-option"><input type="radio" name="f24-1-3" value="true" data-correct="true"/> True</label></p><p><label class="quiz-option"><input type="radio" name="f24-1-3" value="false"/> False</label></p></blockquote></summary><p>Answer: True. Side effects occur when we have mutability, which can make it difficult to reason about program behavior.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>A function with type <span class="stt">int -&gt; float -&gt; bool</span> returns 2 things: a float and a bool.</p><p><label class="quiz-option"><input type="radio" name="f24-1-4" value="true"/> True</label></p><p><label class="quiz-option"><input type="radio" name="f24-1-4" value="false" data-correct="true"/> False</label></p></blockquote></summary><p>Answer: False. Functions return only 1 thing. This function takes an <span class="stt">int</span> and a <span class="stt">float</span> and returns a <span class="stt">bool</span>.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>A function with type <span class="stt">int -&gt; bool -&gt; float</span> could be interpreted as returning a <span class="stt">bool -&gt; float</span> function.</p><p><label class="quiz-option"><input type="radio" name="f24-1-5" value="true" data-correct="true"/> True</label></p><p><label class="quiz-option"><input type="radio" name="f24-1-5" value="false"/> False</label></p></blockquote></summary><p>Answer: True. Currying allows for this interpretation. <span class="stt">int -&gt; bool -&gt; float</span> is equivalent to <span class="stt">int -&gt; (bool -&gt; float)</span>.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p><span class="stt">let f x = x + 3</span> is an example of a higher order function.</p><p><label class="quiz-option"><input type="radio" name="f24-1-6" value="true"/> True</label></p><p><label class="quiz-option"><input type="radio" name="f24-1-6" value="false" data-correct="true"/> False</label></p></blockquote></summary><p>Answer: False. This function has type <span class="stt">int -&gt; int</span>. It neither takes a function as an argument nor returns a function, so it is not a higher order function.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p><span class="stt">let f x = x 3</span> is an example of a higher order function.</p><p><label class="quiz-option"><input type="radio" name="f24-1-7" value="true" data-correct="true"/> True</label></p><p><label class="quiz-option"><input type="radio" name="f24-1-7" value="false"/> False</label></p></blockquote></summary><p>Answer: True. Because we use <span class="stt">x</span> as a function name (applying it to <span class="stt">3</span>), OCaml infers this has type <span class="stt">(int -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a) -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a</span>. It takes a function as an argument, making it higher order.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>An OCaml function can return different types depending on how it&rsquo;s called.</p><p><label class="quiz-option"><input type="radio" name="f24-1-8" value="true"/> True</label></p><p><label class="quiz-option"><input type="radio" name="f24-1-8" value="false" data-correct="true"/> False</label></p></blockquote></summary><p>Answer: False. A function can only return 1 type (or 1 polymorphic type). The return type is fixed at definition time.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p><span class="stt">let x = 3 in let x = 4 in x</span> is an example of variable shadowing.</p><p><label class="quiz-option"><input type="radio" name="f24-1-9" value="true" data-correct="true"/> True</label></p><p><label class="quiz-option"><input type="radio" name="f24-1-9" value="false"/> False</label></p></blockquote></summary><p>Answer: True. This returns 4. The second <span class="stt">let x = 4</span> shadows the first <span class="stt">let x = 3</span>. Variables are immutable, so shadowing creates a new binding rather than mutating.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p><span class="stt">let x = 3 in let y = 4 in y + x</span> is an example of variable shadowing.</p><p><label class="quiz-option"><input type="radio" name="f24-1-10" value="true"/> True</label></p><p><label class="quiz-option"><input type="radio" name="f24-1-10" value="false" data-correct="true"/> False</label></p></blockquote></summary><p>Answer: False. There are no two variables with the same name, so no shadowing occurs.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p><span class="stt">List.length x = (List.length (List.map f x))</span> for all valid <span class="stt">f</span> and <span class="stt">x</span> (i.e., assume <span class="stt">List.map f x</span> compiles).</p><p><label class="quiz-option"><input type="radio" name="q1-1" value="true" data-correct="true"/> True</label></p><p><label class="quiz-option"><input type="radio" name="q1-1" value="false"/> False</label></p></blockquote></summary><p>Answer: True. <span class="stt">List.map f x</span> always produces a list of the same length as <span class="stt">x</span>, regardless of what <span class="stt">f</span> does to each element.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>If <span class="stt">fold_left f a l</span> compiles and results in value <span class="stt">v</span>, then <span class="stt">fold_right (fun x a -&gt; f a x) l a</span> should also result in <span class="stt">v</span>.</p><p><label class="quiz-option"><input type="radio" name="q1-2" value="true"/> True</label></p><p><label class="quiz-option"><input type="radio" name="q1-2" value="false" data-correct="true"/> False</label></p></blockquote></summary><p>Answer: False. <span class="stt">fold_left</span> and <span class="stt">fold_right</span> process the list in different orders. They only produce the same result when the function <span class="stt">f</span> is associative and commutative (e.g., addition). For non-commutative operations like subtraction or string concatenation, the results differ.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>In OCaml the entire function body is a single expression.</p><p><label class="quiz-option"><input type="radio" name="q1-3" value="true" data-correct="true"/> True</label></p><p><label class="quiz-option"><input type="radio" name="q1-3" value="false"/> False</label></p></blockquote></summary><p>Answer: True. In OCaml, a function body is always a single expression. There are no statements &#8212;<wbr></wbr> everything is an expression that evaluates to a value.</p></details><details class="SubFlow"><summary>OCaml lists are immutable. List 2 benefits of immutability in functional programming.</summary><p>Some benefits of immutability:</p><ul><li><p><span style="font-weight: bold">No aliasing bugs</span>: Since data cannot be modified, sharing references is always safe. You never have to worry about one part of your code unexpectedly changing data used elsewhere.</p></li><li><p><span style="font-weight: bold">Thread safety</span>: Immutable data can be freely shared between threads without locks or synchronization, since no thread can modify the data.</p></li><li><p><span style="font-weight: bold">Easier reasoning</span>: Code is easier to understand and debug because values don&rsquo;t change over time. You can always rely on a value being what it was when it was created.</p></li></ul></details></details><details class="SubFlow accordion-section"><summary><span style="font-weight: bold">Multiple Choice: Typing and Evaluating</span></summary><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of <span class="stt">foo</span> and what does <span class="stt">foo [] [1;2;3]</span> evaluate to?</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> foo x y = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> x,y <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    x::xs,y::ys -&gt; y :: xs </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    | _ -&gt; [] ;; </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> foo [] [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>] ;;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> foo : &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> = []</span></code></pre></div>
</div></p></blockquote></blockquote><p><label class="quiz-option"><input type="radio" name="sp25-2a" value="1" data-correct="true"/> 'a list -&gt; 'a list -&gt; 'a list, evaluates to []</label></p><p><label class="quiz-option"><input type="radio" name="sp25-2a" value="2"/> 'a list -&gt; 'a list -&gt; 'a list, evaluates to [1]</label></p><p><label class="quiz-option"><input type="radio" name="sp25-2a" value="3"/> int list -&gt; int list -&gt; int list, evaluates to []</label></p><p><label class="quiz-option"><input type="radio" name="sp25-2a" value="4"/> TYPE ERROR</label></p></blockquote></summary><p>Answer: Type is <span class="stt"></span><span class="stt">&rsquo;</span><span class="stt">a list -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a list -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a list</span>. The function pattern-matches on a tuple of two lists. When both are non-empty, it returns <span class="stt">y :: xs</span>. Since <span class="stt">x = []</span> matches the wildcard case, the result is <span class="stt">[]</span>.</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>   <span class="kw">let</span> foo x y = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> x,y <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    x::xs,y::ys -&gt; y :: xs </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    | _ -&gt; [] ;; </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> foo [] [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>] ;;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> foo : &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> = []</span></code></pre></div>
</div></p></blockquote></blockquote></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of <span class="stt">foo</span> and what does <span class="stt">foo [3;6;9]</span> evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> foo lst = <span class="kw">let</span> total, _ =</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  fold_left</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">fun</span> (tot, idx) ele -&gt;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    (tot + ele * idx, idx + <span class="dv">1</span>))</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  (<span class="dv">0</span>, <span class="dv">0</span>)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  lst <span class="kw">in</span> total;;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>foo [<span class="dv">3</span>;<span class="dv">6</span>;<span class="dv">9</span>] ;;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="sp25-2b" value="1" data-correct="true"/> int list -&gt; int, evaluates to 24</label></p><p><label class="quiz-option"><input type="radio" name="sp25-2b" value="2"/> int list -&gt; int, evaluates to 18</label></p><p><label class="quiz-option"><input type="radio" name="sp25-2b" value="3"/> int list -&gt; int * int, evaluates to (24, 3)</label></p><p><label class="quiz-option"><input type="radio" name="sp25-2b" value="4"/> TYPE ERROR</label></p></blockquote></summary><p>Answer: Type is <span class="stt">int list -&gt; int</span>. The fold computes a weighted sum using the index: <span class="stt">3*0 + 6*1 + 9*2 = 0 + 6 + 18 = 24</span>. The accumulator is a tuple <span class="stt">(total, index)</span>, but <span class="stt">let total, _ = ...</span> destructures it to return only <span class="stt">total</span>.</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>   <span class="kw">let</span> foo lst = <span class="kw">let</span> total, _ = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>      <span class="dt">List</span>.fold_left </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>     (<span class="kw">fun</span> (tot, idx) ele -&gt; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>      (tot + ele * idx, idx + <span class="dv">1</span>)) </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">0</span>, <span class="dv">0</span>) </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    lst <span class="kw">in</span> total;; </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a> foo [<span class="dv">3</span>;<span class="dv">6</span>;<span class="dv">9</span>] ;;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> foo : <span class="dt">int</span> <span class="dt">list</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">24</span></span></code></pre></div>
</div></p></blockquote></blockquote></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of <span class="stt">foo</span> and what does <span class="stt">foo [] [1;2;3]</span> evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> foo x y =</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> x,y <span class="kw">with</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  x::xs,y::ys -&gt; y :: xs</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  | _ -&gt; (<span class="dv">0</span>,<span class="dv">0</span>) ;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>foo [] [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>] ;;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="sp25-2c" value="1" data-correct="true"/> TYPE ERROR</label></p><p><label class="quiz-option"><input type="radio" name="sp25-2c" value="2"/> 'a list -&gt; 'a list -&gt; 'a list, evaluates to []</label></p><p><label class="quiz-option"><input type="radio" name="sp25-2c" value="3"/> int list -&gt; int list -&gt; int * int, evaluates to (0,0)</label></p><p><label class="quiz-option"><input type="radio" name="sp25-2c" value="4"/> int list -&gt; int list -&gt; int list, evaluates to (0,0)</label></p></blockquote></summary><p>Answer: TYPE ERROR. The first branch returns <span class="stt">y :: xs</span> (a list), but the second branch returns <span class="stt">(0,0)</span> (a tuple). These types are incompatible, so the match expression cannot be typed.</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> foo x y = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> x,y <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    x::xs,y::ys -&gt; y :: xs </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    | _ -&gt; (<span class="dv">0</span>,<span class="dv">0</span>) ;; </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> foo [] [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>] ;;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>Line <span class="dv">4</span>, characters <span class="dv">11-16</span>:</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="dv">4</span> |     | _ -&gt; (<span class="dv">0</span>,<span class="dv">0</span>) ;; </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>               ^^^^^</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>Error: This expression has <span class="kw">type</span> &#39;a * &#39;b</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>       but an expression was expected <span class="kw">of</span> <span class="kw">type</span> &#39;c <span class="dt">list</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>Line <span class="dv">1</span>, characters <span class="dv">1-4</span>:</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> |  foo [] [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>] ;;</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>     ^^^</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>Error: Unbound value foo</span></code></pre></div>
</div></p></blockquote></blockquote></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of <span class="stt">foo</span> and what does <span class="stt">foo [7;4;23]</span> evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> foo lst = <span class="kw">let</span> total, _ =</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  fold_left</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">fun</span> (tot, idx) ele -&gt;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    (tot*ele*idx, idx + <span class="dv">1</span>))</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  (<span class="dv">0</span>, <span class="dv">0</span>)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  lst <span class="kw">in</span> total;;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>foo [<span class="dv">7</span>;<span class="dv">4</span>;<span class="dv">23</span>] ;;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="sp25-2d" value="1" data-correct="true"/> int list -&gt; int, evaluates to 0</label></p><p><label class="quiz-option"><input type="radio" name="sp25-2d" value="2"/> int list -&gt; int, evaluates to 644</label></p><p><label class="quiz-option"><input type="radio" name="sp25-2d" value="3"/> int list -&gt; int, evaluates to 28</label></p><p><label class="quiz-option"><input type="radio" name="sp25-2d" value="4"/> TYPE ERROR</label></p></blockquote></summary><p>Answer: Type is <span class="stt">int list -&gt; int</span>, evaluates to <span class="stt">0</span>. The initial accumulator is <span class="stt">(0, 0)</span>. Since <span class="stt">tot</span> starts at 0 and gets multiplied (<span class="stt">tot*ele*idx</span>), the result stays 0 throughout: <span class="stt">0*7*0 = 0</span>, <span class="stt">0*4*1 = 0</span>, <span class="stt">0*23*2 = 0</span>.</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>   <span class="kw">let</span> foo lst = <span class="kw">let</span> total, _ = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">List</span>.fold_left </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">fun</span> (tot, idx) ele -&gt; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>      (tot*ele*idx, idx + <span class="dv">1</span>)) </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">0</span>, <span class="dv">0</span>) </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    lst <span class="kw">in</span> total;; </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a> foo [<span class="dv">7</span>;<span class="dv">4</span>;<span class="dv">23</span>] ;;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> foo : <span class="dt">int</span> <span class="dt">list</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">0</span></span></code></pre></div>
</div></p></blockquote></blockquote></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of <span class="stt">foo</span> and what does <span class="stt">foo [] [1;2;3]</span> evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> foo x y = <span class="kw">match</span> x,y <span class="kw">with</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  x::xs,y::ys -&gt; y :: xs</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  | _ -&gt; [<span class="dv">9</span>] ;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>foo [] [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>] ;;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="sp25-2e" value="1" data-correct="true"/> int list -&gt; int list -&gt; int list, evaluates to [9]</label></p><p><label class="quiz-option"><input type="radio" name="sp25-2e" value="2"/> 'a list -&gt; 'a list -&gt; 'a list, evaluates to [9]</label></p><p><label class="quiz-option"><input type="radio" name="sp25-2e" value="3"/> int list -&gt; int list -&gt; int list, evaluates to []</label></p><p><label class="quiz-option"><input type="radio" name="sp25-2e" value="4"/> TYPE ERROR</label></p></blockquote></summary><p>Answer: Type is <span class="stt">int list -&gt; int list -&gt; int list</span>. The wildcard branch returns <span class="stt">[9]</span>, which constrains the type to <span class="stt">int list</span> (not polymorphic <span class="stt"></span><span class="stt">&rsquo;</span><span class="stt">a list</span>). Since <span class="stt">x = []</span> matches the wildcard, the result is <span class="stt">[9]</span>.</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>   <span class="kw">let</span> foo x y = <span class="kw">match</span> x,y <span class="kw">with</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    x::xs,y::ys -&gt; y :: xs </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    | _ -&gt; [<span class="dv">9</span>] ;; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> foo [] [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>] ;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> foo : <span class="dt">int</span> <span class="dt">list</span> -&gt; <span class="dt">int</span> <span class="dt">list</span> -&gt; <span class="dt">int</span> <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">9</span>]</span></code></pre></div>
</div></p></blockquote></blockquote></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of <span class="stt">foo</span> and what does <span class="stt">foo [2;4;8]</span> evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> foo lst = <span class="kw">let</span> total, _ =</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  fold_left</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">fun</span> (tot, idx) ele -&gt;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    (tot + ele * idx, idx + <span class="dv">1</span>))</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  (<span class="dv">0</span>, <span class="dv">0</span>)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  lst <span class="kw">in</span> total;;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>foo [<span class="dv">2</span>;<span class="dv">4</span>;<span class="dv">8</span>] ;;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="sp25-2f" value="1" data-correct="true"/> int list -&gt; int, evaluates to 20</label></p><p><label class="quiz-option"><input type="radio" name="sp25-2f" value="2"/> int list -&gt; int, evaluates to 14</label></p><p><label class="quiz-option"><input type="radio" name="sp25-2f" value="3"/> int list -&gt; int, evaluates to 24</label></p><p><label class="quiz-option"><input type="radio" name="sp25-2f" value="4"/> TYPE ERROR</label></p></blockquote></summary><p>Answer: Type is <span class="stt">int list -&gt; int</span>, evaluates to <span class="stt">20</span>. The fold computes a weighted sum: <span class="stt">2*0 + 4*1 + 8*2 = 0 + 4 + 16 = 20</span>.</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>   <span class="kw">let</span> foo lst = <span class="kw">let</span> total, _ = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">List</span>.fold_left </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">fun</span> (tot, idx) ele -&gt; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>      (tot + ele * idx, idx + <span class="dv">1</span>)) </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">0</span>, <span class="dv">0</span>) </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    lst <span class="kw">in</span> total;; </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a> foo [<span class="dv">2</span>;<span class="dv">4</span>;<span class="dv">8</span>] ;;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> foo : <span class="dt">int</span> <span class="dt">list</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">20</span></span></code></pre></div>
</div></p></blockquote></blockquote></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of <span class="stt">foo</span> and what does <span class="stt">foo (1,3) [1;2;3]</span> evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> foo x y = <span class="kw">match</span> x,y <span class="kw">with</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  x::xs,y::ys -&gt; y :: xs</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  | _ -&gt; [] ;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>foo (<span class="dv">1</span>,<span class="dv">3</span>) [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>] ;;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="sp25-2g" value="1" data-correct="true"/> 'a list -&gt; 'a list -&gt; 'a list, evaluates to Error</label></p><p><label class="quiz-option"><input type="radio" name="sp25-2g" value="2"/> 'a list -&gt; 'a list -&gt; 'a list, evaluates to []</label></p><p><label class="quiz-option"><input type="radio" name="sp25-2g" value="3"/> TYPE ERROR</label></p><p><label class="quiz-option"><input type="radio" name="sp25-2g" value="4"/> 'a list -&gt; 'a list -&gt; 'a list, evaluates to [1]</label></p></blockquote></summary><p>Answer: Type is <span class="stt"></span><span class="stt">&rsquo;</span><span class="stt">a list -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a list -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a list</span>, but the call causes a runtime error. <span class="stt">foo</span> expects two lists, but <span class="stt">(1,3)</span> is a tuple, not a list. The function itself type-checks fine, but the call <span class="stt">foo (1,3) [1;2;3]</span> is a type mismatch at the call site, causing an error.</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>   <span class="kw">let</span> foo x y = <span class="kw">match</span> x,y <span class="kw">with</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    x::xs,y::ys -&gt; y :: xs </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    | _ -&gt; [] ;; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> foo (<span class="dv">1</span>,<span class="dv">3</span>) [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>] ;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> foo : &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>Line <span class="dv">1</span>, characters <span class="dv">5-10</span>:</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> |  foo (<span class="dv">1</span>,<span class="dv">3</span>) [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>] ;;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>         ^^^^^</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>Error: This expression has <span class="kw">type</span> &#39;a * &#39;b</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>       but an expression was expected <span class="kw">of</span> <span class="kw">type</span> &#39;c <span class="dt">list</span></span></code></pre></div>
</div></p></blockquote></blockquote></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of <span class="stt">foo</span> and what does <span class="stt">foo [1;3;5]</span> evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> foo lst = <span class="kw">let</span> total, _ =</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  fold_left</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">fun</span> (tot, idx) ele -&gt;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    (tot * ele * idx, idx + <span class="dv">1</span>))</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  (<span class="dv">1</span>, <span class="dv">0</span>)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  lst <span class="kw">in</span> total;;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>foo [<span class="dv">1</span>;<span class="dv">3</span>;<span class="dv">5</span>] ;;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="sp25-2h" value="1" data-correct="true"/> int list -&gt; int, evaluates to 0</label></p><p><label class="quiz-option"><input type="radio" name="sp25-2h" value="2"/> int list -&gt; int, evaluates to 15</label></p><p><label class="quiz-option"><input type="radio" name="sp25-2h" value="3"/> int list -&gt; int, evaluates to 30</label></p><p><label class="quiz-option"><input type="radio" name="sp25-2h" value="4"/> TYPE ERROR</label></p></blockquote></summary><p>Answer: Type is <span class="stt">int list -&gt; int</span>, evaluates to <span class="stt">0</span>. Even though <span class="stt">tot</span> starts at 1, the first iteration multiplies by <span class="stt">idx = 0</span>: <span class="stt">1*1*0 = 0</span>. After that, <span class="stt">tot</span> remains 0: <span class="stt">0*3*1 = 0</span>, <span class="stt">0*5*2 = 0</span>.</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>   <span class="kw">let</span> foo lst = <span class="kw">let</span> total, _ = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">List</span>.fold_left </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">fun</span> (tot, idx) ele -&gt; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>      (tot * ele * idx, idx + <span class="dv">1</span>)) </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">1</span>, <span class="dv">0</span>) </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    lst <span class="kw">in</span> total;; </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a> foo [<span class="dv">1</span>;<span class="dv">3</span>;<span class="dv">5</span>] ;;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> foo : <span class="dt">int</span> <span class="dt">list</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">0</span></span></code></pre></div>
</div></p></blockquote></blockquote></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of <span class="stt">f</span> and what does <span class="stt">f [4] [[6]]</span> evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f x y = <span class="kw">match</span> x <span class="kw">with</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  [] -&gt; y</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  |x::xs -&gt; [x]::[] ;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>f [<span class="dv">4</span>] [[<span class="dv">6</span>]] ;;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="sp24-2a" value="1" data-correct="true"/> 'a list -&gt; 'a list list -&gt; 'a list list, evaluates to [[4]]</label></p><p><label class="quiz-option"><input type="radio" name="sp24-2a" value="2"/> int list -&gt; int list list -&gt; int list list, evaluates to [[4]]</label></p><p><label class="quiz-option"><input type="radio" name="sp24-2a" value="3"/> 'a list -&gt; 'a list list -&gt; 'a list list, evaluates to [[6]]</label></p><p><label class="quiz-option"><input type="radio" name="sp24-2a" value="4"/> TYPE ERROR</label></p></blockquote></summary><p>Answer: Type is <span class="stt"></span><span class="stt">&rsquo;</span><span class="stt">a list -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a list list -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a list list</span>. The empty case returns <span class="stt">y</span> (a list list), and the non-empty case returns <span class="stt">[x]::[]</span>, which is also a list list. No operations constrain the type, so it&rsquo;s polymorphic. Since <span class="stt">x = [4]</span> is non-empty, <span class="stt">x = 4</span> and we return <span class="stt">[[4]]</span>.</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>   <span class="kw">let</span> f x y = <span class="kw">match</span> x <span class="kw">with</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    [] -&gt; y </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    |x::xs -&gt; [x]::[] ;; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> f [<span class="dv">4</span>] [[<span class="dv">6</span>]] ;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> f : &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> <span class="dt">list</span> = [[<span class="dv">4</span>]]</span></code></pre></div>
</div></p></blockquote></blockquote></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of <span class="stt">f</span> and what does <span class="stt">f 2.0 false</span> evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f a b =</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> b &gt; a <span class="kw">then</span> b</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">else</span> a &lt; <span class="kw">true</span> ;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>f <span class="fl">2.0</span> <span class="kw">false</span>;;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="sp24-2b" value="1" data-correct="true"/> bool -&gt; bool -&gt; bool, evaluates to Error</label></p><p><label class="quiz-option"><input type="radio" name="sp24-2b" value="2"/> float -&gt; bool -&gt; bool, evaluates to false</label></p><p><label class="quiz-option"><input type="radio" name="sp24-2b" value="3"/> bool -&gt; bool -&gt; bool, evaluates to true</label></p><p><label class="quiz-option"><input type="radio" name="sp24-2b" value="4"/> TYPE ERROR</label></p></blockquote></summary><p>Answer: Type is <span class="stt">bool -&gt; bool -&gt; bool</span>. The <span class="stt">then</span> branch returns <span class="stt">b</span> and the <span class="stt">else</span> branch returns <span class="stt">a &lt; true</span>. Since <span class="stt">a &lt; true</span> compares <span class="stt">a</span> with a <span class="stt">bool</span>, <span class="stt">a : bool</span>. Since <span class="stt">b &gt; a</span> compares <span class="stt">b</span> with <span class="stt">a</span>, <span class="stt">b : bool</span>. The call passes <span class="stt">2.0</span> (a <span class="stt">float</span>) for <span class="stt">a</span>, which doesn&rsquo;t match &#8212;<wbr></wbr> Error.</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f a b = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> b &gt; a <span class="kw">then</span> b </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> a &lt; <span class="kw">true</span> ;; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> f <span class="fl">2.0</span> <span class="kw">false</span>;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> f : <span class="dt">bool</span> -&gt; <span class="dt">bool</span> -&gt; <span class="dt">bool</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>Line <span class="dv">1</span>, characters <span class="dv">3-6</span>:</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> |  f <span class="fl">2.0</span> <span class="kw">false</span>;;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>       ^^^</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>Error: The constant <span class="fl">2.0</span> has <span class="kw">type</span> <span class="dt">float</span> but an expression was expected <span class="kw">of</span> <span class="kw">type</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>         <span class="dt">bool</span></span></code></pre></div>
</div></p></blockquote></blockquote></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of <span class="stt">f</span> and what does <span class="stt">f [4]</span> evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f x = <span class="kw">match</span> x <span class="kw">with</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  [] -&gt; [[<span class="dv">3</span>]]</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  |x::xs -&gt; [x]::[] ;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>f [<span class="dv">4</span>];;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="sp24-2d" value="1" data-correct="true"/> int list -&gt; int list list, evaluates to [[4]]</label></p><p><label class="quiz-option"><input type="radio" name="sp24-2d" value="2"/> 'a list -&gt; 'a list list, evaluates to [[4]]</label></p><p><label class="quiz-option"><input type="radio" name="sp24-2d" value="3"/> int list -&gt; int list list, evaluates to [[3]]</label></p><p><label class="quiz-option"><input type="radio" name="sp24-2d" value="4"/> TYPE ERROR</label></p></blockquote></summary><p>Answer: Type is <span class="stt">int list -&gt; int list list</span>. The <span class="stt">[[3]]</span> in the empty case constrains the type to <span class="stt">int</span>. Since <span class="stt">x = [4]</span> is non-empty, <span class="stt">x = 4</span> and we return <span class="stt">[[4]]</span>.</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>   <span class="kw">let</span> f x = <span class="kw">match</span> x <span class="kw">with</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    [] -&gt; [[<span class="dv">3</span>]] </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    |x::xs -&gt; [x]::[] ;; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> f [<span class="dv">4</span>];;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> f : <span class="dt">int</span> <span class="dt">list</span> -&gt; <span class="dt">int</span> <span class="dt">list</span> <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> <span class="dt">list</span> = [[<span class="dv">4</span>]]</span></code></pre></div>
</div></p></blockquote></blockquote></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of <span class="stt">f</span> and what does <span class="stt">f true false (fun x y -&gt; x &gt; y)</span> evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f a b c =</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> b &gt; a <span class="kw">then</span> c</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">else</span> a &lt; <span class="kw">true</span> ;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>f <span class="kw">true</span> <span class="kw">false</span> (<span class="kw">fun</span> x y -&gt; x &gt; y);;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="sp24-2e" value="1" data-correct="true"/> bool -&gt; bool -&gt; bool -&gt; bool, evaluates to Error</label></p><p><label class="quiz-option"><input type="radio" name="sp24-2e" value="2"/> bool -&gt; bool -&gt; bool -&gt; bool, evaluates to true</label></p><p><label class="quiz-option"><input type="radio" name="sp24-2e" value="3"/> 'a -&gt; 'a -&gt; bool -&gt; bool, evaluates to false</label></p><p><label class="quiz-option"><input type="radio" name="sp24-2e" value="4"/> TYPE ERROR</label></p></blockquote></summary><p>Answer: Type is <span class="stt">bool -&gt; bool -&gt; bool -&gt; bool</span>. <span class="stt">a &lt; true</span> forces <span class="stt">a : bool</span>, <span class="stt">b &gt; a</span> forces <span class="stt">b : bool</span>, and <span class="stt">c</span> must match the return type <span class="stt">bool</span>. The call passes a function <span class="stt">fun x y -&gt; x &gt; y</span> for <span class="stt">c</span>, but <span class="stt">c : bool</span>, so this is a type error at the call site &#8212;<wbr></wbr> Error.</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>   <span class="kw">let</span> f a b c = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> b &gt; a <span class="kw">then</span> c </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> a &lt; <span class="kw">true</span> ;; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> f <span class="kw">true</span> <span class="kw">false</span> (<span class="kw">fun</span> x y -&gt; x &gt; y);;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> f : <span class="dt">bool</span> -&gt; <span class="dt">bool</span> -&gt; <span class="dt">bool</span> -&gt; <span class="dt">bool</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>Line <span class="dv">1</span>, characters <span class="dv">14-32</span>:</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> |  f <span class="kw">true</span> <span class="kw">false</span> (<span class="kw">fun</span> x y -&gt; x &gt; y);;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>                  ^^^^^^^^^^^^^^^^^^</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>Error: This expression should <span class="dt">not</span> be a <span class="kw">function</span>, the expected <span class="kw">type</span> is <span class="dt">bool</span></span></code></pre></div>
</div></p></blockquote></blockquote></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of <span class="stt">f</span> and what does <span class="stt">f [4] [[6]]</span> evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f x y = <span class="kw">match</span> x <span class="kw">with</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  [] -&gt; y</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  |_::xs -&gt; [<span class="dv">2</span>]::[]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  |<span class="dv">4</span>::xs -&gt; [<span class="dv">4</span>]::[];;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>f [<span class="dv">4</span>] [[<span class="dv">6</span>]] ;;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="sp24-2f" value="1" data-correct="true"/> int list -&gt; int list list -&gt; int list list, evaluates to [[2]]</label></p><p><label class="quiz-option"><input type="radio" name="sp24-2f" value="2"/> int list -&gt; int list list -&gt; int list list, evaluates to [[4]]</label></p><p><label class="quiz-option"><input type="radio" name="sp24-2f" value="3"/> 'a list -&gt; 'a list list -&gt; 'a list list, evaluates to [[2]]</label></p><p><label class="quiz-option"><input type="radio" name="sp24-2f" value="4"/> TYPE ERROR</label></p></blockquote></summary><p>Answer: Type is <span class="stt">int list -&gt; int list list -&gt; int list list</span>. The <span class="stt">[2]</span> and <span class="stt">[4]</span> constrain the type to <span class="stt">int</span>. Since <span class="stt">x = [4]</span> is non-empty, it matches the <span class="stt">_::xs</span> pattern first (patterns are tried in order), returning <span class="stt">[[2]]</span>.</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>   <span class="kw">let</span> f x y = <span class="kw">match</span> x <span class="kw">with</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    [] -&gt; y </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    |_::xs -&gt; [<span class="dv">2</span>]::[] </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    |<span class="dv">4</span>::xs -&gt; [<span class="dv">4</span>]::[];; </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> f [<span class="dv">4</span>] [[<span class="dv">6</span>]] ;;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>Line <span class="dv">4</span>, characters <span class="dv">5-10</span>:</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="dv">4</span> |     |<span class="dv">4</span>::xs -&gt; [<span class="dv">4</span>]::[];; </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>         ^^^^^</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>Warning <span class="dv">11</span> [redundant-case]: this <span class="kw">match</span> case is unused.</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> f : <span class="dt">int</span> <span class="dt">list</span> -&gt; <span class="dt">int</span> <span class="dt">list</span> <span class="dt">list</span> -&gt; <span class="dt">int</span> <span class="dt">list</span> <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> <span class="dt">list</span> = [[<span class="dv">2</span>]]</span></code></pre></div>
</div></p></blockquote></blockquote></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of <span class="stt">f</span> and what does <span class="stt">f true 1.3</span> evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f a b =</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> b &gt; a <span class="kw">then</span> (<span class="fl">1.3</span> &lt; <span class="fl">4.6</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">else</span> a &lt; <span class="kw">true</span> ;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>f <span class="kw">true</span> <span class="fl">1.3</span>;;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="sp24-2g" value="1" data-correct="true"/> bool -&gt; bool -&gt; bool, evaluates to Error</label></p><p><label class="quiz-option"><input type="radio" name="sp24-2g" value="2"/> bool -&gt; bool -&gt; bool, evaluates to true</label></p><p><label class="quiz-option"><input type="radio" name="sp24-2g" value="3"/> bool -&gt; float -&gt; bool, evaluates to true</label></p><p><label class="quiz-option"><input type="radio" name="sp24-2g" value="4"/> TYPE ERROR</label></p></blockquote></summary><p>Answer: Type is <span class="stt">bool -&gt; bool -&gt; bool</span>. <span class="stt">a &lt; true</span> forces <span class="stt">a : bool</span>. <span class="stt">b &gt; a</span> forces <span class="stt">b : bool</span>. The <span class="stt">then</span> branch <span class="stt">1.3 &lt; 4.6</span> is a <span class="stt">bool</span> expression that evaluates at function call time. The call passes <span class="stt">1.3</span> (a <span class="stt">float</span>) for <span class="stt">b</span>, which doesn&rsquo;t match &#8212;<wbr></wbr> Error.</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>   <span class="kw">let</span> f a b = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> b &gt; a <span class="kw">then</span> (<span class="fl">1.3</span> &lt; <span class="fl">4.6</span>) </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> a &lt; <span class="kw">true</span> ;; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> f <span class="kw">true</span> <span class="fl">1.3</span>;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> f : <span class="dt">bool</span> -&gt; <span class="dt">bool</span> -&gt; <span class="dt">bool</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>Line <span class="dv">1</span>, characters <span class="dv">8-11</span>:</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> |  f <span class="kw">true</span> <span class="fl">1.3</span>;;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>            ^^^</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>Error: The constant <span class="fl">1.3</span> has <span class="kw">type</span> <span class="dt">float</span> but an expression was expected <span class="kw">of</span> <span class="kw">type</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>         <span class="dt">bool</span></span></code></pre></div>
</div></p></blockquote></blockquote></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of <span class="stt">f</span> and what does <span class="stt">f [(1,2);(3,4)] [[(6,7)]]</span> evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f x y = <span class="kw">match</span> x <span class="kw">with</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  [] -&gt; y</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  |x::xs -&gt; [x]::[] ;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>f [(<span class="dv">1</span>,<span class="dv">2</span>);(<span class="dv">3</span>,<span class="dv">4</span>)] [[(<span class="dv">6</span>,<span class="dv">7</span>)]] ;;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="sp24-2h" value="1" data-correct="true"/> 'a list -&gt; 'a list list -&gt; 'a list list, evaluates to [[(1,2)]]</label></p><p><label class="quiz-option"><input type="radio" name="sp24-2h" value="2"/> (int * int) list -&gt; (int * int) list list -&gt; (int * int) list list, evaluates to [[(1,2)]]</label></p><p><label class="quiz-option"><input type="radio" name="sp24-2h" value="3"/> 'a list -&gt; 'a list list -&gt; 'a list list, evaluates to [[(6,7)]]</label></p><p><label class="quiz-option"><input type="radio" name="sp24-2h" value="4"/> TYPE ERROR</label></p></blockquote></summary><p>Answer: Type is <span class="stt"></span><span class="stt">&rsquo;</span><span class="stt">a list -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a list list -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a list list</span>. Same function as (a) &#8212;<wbr></wbr> no operations constrain the type. Since <span class="stt">x</span> is non-empty, <span class="stt">x = (1,2)</span> and we return <span class="stt">[[(1,2)]]</span>.</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>   <span class="kw">let</span> f x y = <span class="kw">match</span> x <span class="kw">with</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    [] -&gt; y </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    |x::xs -&gt; [x]::[] ;; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> f [(<span class="dv">1</span>,<span class="dv">2</span>);(<span class="dv">3</span>,<span class="dv">4</span>)] [[(<span class="dv">6</span>,<span class="dv">7</span>)]] ;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> f : &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>- : (<span class="dt">int</span> * <span class="dt">int</span>) <span class="dt">list</span> <span class="dt">list</span> = [[(<span class="dv">1</span>, <span class="dv">2</span>)]]</span></code></pre></div>
</div></p></blockquote></blockquote></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of <span class="stt">f</span> and what does <span class="stt">f (fun x -&gt; x &lt; 1) false</span> evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f a b =</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> b &gt; a <span class="kw">then</span> (<span class="st">&quot;hello&quot;</span> &lt; <span class="st">&quot;bye&quot;</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">else</span> a &lt; <span class="kw">true</span> ;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>f (<span class="kw">fun</span> x -&gt; x &lt; <span class="dv">1</span>) <span class="kw">false</span>;;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="sp24-2i" value="1" data-correct="true"/> bool -&gt; bool -&gt; bool, evaluates to Error</label></p><p><label class="quiz-option"><input type="radio" name="sp24-2i" value="2"/> bool -&gt; bool -&gt; bool, evaluates to true</label></p><p><label class="quiz-option"><input type="radio" name="sp24-2i" value="3"/> (int -&gt; bool) -&gt; bool -&gt; bool, evaluates to false</label></p><p><label class="quiz-option"><input type="radio" name="sp24-2i" value="4"/> TYPE ERROR</label></p></blockquote></summary><p>Answer: Type is <span class="stt">bool -&gt; bool -&gt; bool</span>. <span class="stt">a &lt; true</span> forces <span class="stt">a : bool</span>, <span class="stt">b &gt; a</span> forces <span class="stt">b : bool</span>. The <span class="stt">then</span> branch <span class="stt">"hello" &lt; "bye"</span> is a <span class="stt">bool</span> expression. The call passes a function <span class="stt">fun x -&gt; x &lt; 1</span> for <span class="stt">a</span>, which doesn&rsquo;t match <span class="stt">bool</span> &#8212;<wbr></wbr> Error.</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>   <span class="kw">let</span> f a b = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> b &gt; a <span class="kw">then</span> (<span class="st">&quot;hello&quot;</span> &lt; <span class="st">&quot;bye&quot;</span>) </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> a &lt; <span class="kw">true</span> ;; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> f (<span class="kw">fun</span> x -&gt; x &lt; <span class="dv">1</span>) <span class="kw">false</span>;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> f : <span class="dt">bool</span> -&gt; <span class="dt">bool</span> -&gt; <span class="dt">bool</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>Line <span class="dv">1</span>, characters <span class="dv">3-19</span>:</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> |  f (<span class="kw">fun</span> x -&gt; x &lt; <span class="dv">1</span>) <span class="kw">false</span>;;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>       ^^^^^^^^^^^^^^^^</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>Error: This expression should <span class="dt">not</span> be a <span class="kw">function</span>, the expected <span class="kw">type</span> is <span class="dt">bool</span></span></code></pre></div>
</div></p></blockquote></blockquote></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of <span class="stt">f</span> and what does <span class="stt">f [] [1;2;3]</span> evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f x y = <span class="kw">match</span> x <span class="kw">with</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  [] -&gt; []</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  |x::xs -&gt; y :: xs ;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>f [] [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>] ;;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="f24-2a" value="1" data-correct="true"/> 'a list -&gt; 'a -&gt; 'a list, evaluates to []</label></p><p><label class="quiz-option"><input type="radio" name="f24-2a" value="2"/> 'a list -&gt; 'a list -&gt; 'a list, evaluates to []</label></p><p><label class="quiz-option"><input type="radio" name="f24-2a" value="3"/> 'a list -&gt; 'a -&gt; 'a list, evaluates to [1;2;3]</label></p><p><label class="quiz-option"><input type="radio" name="f24-2a" value="4"/> TYPE ERROR</label></p></blockquote></summary><p>Answer: Type is <span class="stt"></span><span class="stt">&rsquo;</span><span class="stt">a list -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a list</span>. <span class="stt">x</span> is matched as a list and <span class="stt">y</span> is consed onto <span class="stt">xs</span>, so <span class="stt">y</span> is an element (not a list). No operations force a specific type, so it&rsquo;s polymorphic. Since <span class="stt">x = []</span>, the first branch matches and returns <span class="stt">[]</span>.</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>   <span class="kw">let</span> f x y = <span class="kw">match</span> x <span class="kw">with</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    [] -&gt; [] </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    |x::xs -&gt; y :: xs ;; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> f [] [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>] ;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> f : &#39;a <span class="dt">list</span> -&gt; &#39;a -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> <span class="dt">list</span> = []</span></code></pre></div>
</div></p></blockquote></blockquote></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of <span class="stt">f</span> and what does <span class="stt">f [] [1;2;3]</span> evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f x y = <span class="kw">match</span> x <span class="kw">with</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  [] -&gt; [<span class="dv">1</span>]</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  |x::xs -&gt; y :: xs ;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>f [] [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>] ;;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="f24-2b" value="1" data-correct="true"/> int list -&gt; int -&gt; int list, evaluates to Error</label></p><p><label class="quiz-option"><input type="radio" name="f24-2b" value="2"/> int list -&gt; int -&gt; int list, evaluates to [1]</label></p><p><label class="quiz-option"><input type="radio" name="f24-2b" value="3"/> 'a list -&gt; 'a -&gt; 'a list, evaluates to [1]</label></p><p><label class="quiz-option"><input type="radio" name="f24-2b" value="4"/> TYPE ERROR</label></p></blockquote></summary><p>Answer: Type is <span class="stt">int list -&gt; int -&gt; int list</span>. The <span class="stt">[1]</span> in the first branch constrains the type to <span class="stt">int list</span>. The call <span class="stt">f [] [1;2;3]</span> passes a list <span class="stt">[1;2;3]</span> as <span class="stt">y</span>, but <span class="stt">y</span> has type <span class="stt">int</span>, so this is a type error at the call site &#8212;<wbr></wbr> the function type-checks but the call causes an error.</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>     <span class="kw">let</span> f x y = <span class="kw">match</span> x <span class="kw">with</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    [] -&gt; [<span class="dv">1</span>] </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    |x::xs -&gt; y :: xs ;; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> f [] [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>] ;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> f : <span class="dt">int</span> <span class="dt">list</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>Line <span class="dv">1</span>, characters <span class="dv">6-13</span>:</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> |  f [] [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>] ;;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>          ^^^^^^^</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>Error: This constructor has <span class="kw">type</span> &#39;a <span class="dt">list</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>       but an expression was expected <span class="kw">of</span> <span class="kw">type</span> <span class="dt">int</span></span></code></pre></div>
</div></p></blockquote></blockquote></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of <span class="stt">f</span> and what does <span class="stt">f [1] [1;2;3]</span> evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f x y = <span class="kw">match</span> x <span class="kw">with</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  [] -&gt; [<span class="dv">14</span>]</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  |x::xs -&gt; y :: xs ;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>f [<span class="dv">1</span>] [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>] ;;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="f24-2c" value="1" data-correct="true"/> int list -&gt; int -&gt; int list, evaluates to Error</label></p><p><label class="quiz-option"><input type="radio" name="f24-2c" value="2"/> int list -&gt; int -&gt; int list, evaluates to [1;2;3]</label></p><p><label class="quiz-option"><input type="radio" name="f24-2c" value="3"/> int list -&gt; int -&gt; int list, evaluates to [14]</label></p><p><label class="quiz-option"><input type="radio" name="f24-2c" value="4"/> TYPE ERROR</label></p></blockquote></summary><p>Answer: Type is <span class="stt">int list -&gt; int -&gt; int list</span>. The <span class="stt">[14]</span> constrains types to <span class="stt">int</span>. The call passes <span class="stt">[1;2;3]</span> (a list) as <span class="stt">y</span>, but <span class="stt">y</span> should be <span class="stt">int</span>, so this is an error at the call site.</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>   <span class="kw">let</span> f x y = <span class="kw">match</span> x <span class="kw">with</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    [] -&gt; [<span class="dv">14</span>] </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    |x::xs -&gt; y :: xs ;; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> f [<span class="dv">1</span>] [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>] ;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> f : <span class="dt">int</span> <span class="dt">list</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>Line <span class="dv">1</span>, characters <span class="dv">7-14</span>:</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> |  f [<span class="dv">1</span>] [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>] ;;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>           ^^^^^^^</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>Error: This constructor has <span class="kw">type</span> &#39;a <span class="dt">list</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>       but an expression was expected <span class="kw">of</span> <span class="kw">type</span> <span class="dt">int</span></span></code></pre></div>
</div></p></blockquote></blockquote></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of <span class="stt">f</span> and what does <span class="stt">f 2.0 false</span> evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f a b =</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> b &lt;&gt; <span class="kw">false</span> <span class="kw">then</span> <span class="fl">1.0</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">else</span> a + <span class="fl">2.0</span> ;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>f <span class="fl">2.0</span> <span class="kw">false</span>;;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="f24-2e" value="1" data-correct="true"/> TYPE ERROR</label></p><p><label class="quiz-option"><input type="radio" name="f24-2e" value="2"/> float -&gt; bool -&gt; float, evaluates to 4.0</label></p><p><label class="quiz-option"><input type="radio" name="f24-2e" value="3"/> float -&gt; bool -&gt; float, evaluates to 1.0</label></p><p><label class="quiz-option"><input type="radio" name="f24-2e" value="4"/> float -&gt; bool -&gt; float, evaluates to Error</label></p></blockquote></summary><p>Answer: TYPE ERROR. The expression <span class="stt">a + 2.0</span> tries to use the integer addition operator <span class="stt">+</span> with a float. In OCaml, you must use <span class="stt">+.</span> for float addition.</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>   <span class="kw">let</span> f a b = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> b &lt;&gt; <span class="kw">false</span> <span class="kw">then</span> <span class="fl">1.0</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> a + <span class="fl">2.0</span> ;; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> f <span class="fl">2.0</span> <span class="kw">false</span>;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>Line <span class="dv">3</span>, characters <span class="dv">13-16</span>:</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="dv">3</span> |     <span class="kw">else</span> a + <span class="fl">2.0</span> ;; </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>                 ^^^</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>Error: The constant <span class="fl">2.0</span> has <span class="kw">type</span> <span class="dt">float</span> but an expression was expected <span class="kw">of</span> <span class="kw">type</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>         <span class="dt">int</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>Line <span class="dv">1</span>, characters <span class="dv">1-2</span>:</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> |  f <span class="fl">2.0</span> <span class="kw">false</span>;;</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>     ^</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>Error: Unbound value f</span></code></pre></div>
</div></p></blockquote></blockquote></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of <span class="stt">f</span> and what does <span class="stt">f 2 "true"</span> evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f a b =</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> b = <span class="st">&quot;false&quot;</span> <span class="kw">then</span> <span class="dv">1</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">else</span> a + <span class="dv">2</span> ;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>f <span class="dv">2</span> <span class="st">&quot;true&quot;</span>;;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="f24-2f" value="1" data-correct="true"/> int -&gt; string -&gt; int, evaluates to 4</label></p><p><label class="quiz-option"><input type="radio" name="f24-2f" value="2"/> int -&gt; string -&gt; int, evaluates to 1</label></p><p><label class="quiz-option"><input type="radio" name="f24-2f" value="3"/> int -&gt; bool -&gt; int, evaluates to 4</label></p><p><label class="quiz-option"><input type="radio" name="f24-2f" value="4"/> TYPE ERROR</label></p></blockquote></summary><p>Answer: Type is <span class="stt">int -&gt; string -&gt; int</span>. <span class="stt">a</span> is added to <span class="stt">2</span> so it&rsquo;s <span class="stt">int</span>, and <span class="stt">b</span> is compared to the string <span class="stt">"false"</span> so it&rsquo;s <span class="stt">string</span>. Since <span class="stt">b = "true"</span> which is not <span class="stt">"false"</span>, the else branch runs: <span class="stt">2 + 2 = 4</span>.</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>   <span class="kw">let</span> f a b = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> b = <span class="st">&quot;false&quot;</span> <span class="kw">then</span> <span class="dv">1</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> a + <span class="dv">2</span> ;; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> f <span class="dv">2</span> <span class="st">&quot;true&quot;</span>;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> f : <span class="dt">int</span> -&gt; <span class="dt">string</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">4</span></span></code></pre></div>
</div></p></blockquote></blockquote></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of <span class="stt">f</span> and what does <span class="stt">f 2.0 false</span> evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f a b =</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> b &gt; <span class="dv">5</span> <span class="kw">then</span> a</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">else</span> <span class="kw">true</span> ;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>f <span class="fl">2.0</span> <span class="kw">false</span>;;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="f24-2g" value="1" data-correct="true"/> bool -&gt; int -&gt; bool, evaluates to Error</label></p><p><label class="quiz-option"><input type="radio" name="f24-2g" value="2"/> bool -&gt; int -&gt; bool, evaluates to true</label></p><p><label class="quiz-option"><input type="radio" name="f24-2g" value="3"/> float -&gt; int -&gt; float, evaluates to true</label></p><p><label class="quiz-option"><input type="radio" name="f24-2g" value="4"/> TYPE ERROR</label></p></blockquote></summary><p>Answer: Type is <span class="stt">bool -&gt; int -&gt; bool</span>. <span class="stt">a</span> must match the type of <span class="stt">true</span>, so <span class="stt">a : bool</span>. <span class="stt">b</span> is compared to <span class="stt">5</span>, so <span class="stt">b : int</span>. The call <span class="stt">f 2.0 false</span> passes a <span class="stt">float</span> for <span class="stt">a</span> and a <span class="stt">bool</span> for <span class="stt">b</span>, both wrong types &#8212;<wbr></wbr> runtime error.</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>   <span class="kw">let</span> f a b = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> b &gt; <span class="dv">5</span> <span class="kw">then</span> a </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> <span class="kw">true</span> ;; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> f <span class="fl">2.0</span> <span class="kw">false</span>;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> f : <span class="dt">bool</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">bool</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>Line <span class="dv">1</span>, characters <span class="dv">3-6</span>:</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> |  f <span class="fl">2.0</span> <span class="kw">false</span>;;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>       ^^^</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>Error: The constant <span class="fl">2.0</span> has <span class="kw">type</span> <span class="dt">float</span> but an expression was expected <span class="kw">of</span> <span class="kw">type</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>         <span class="dt">bool</span></span></code></pre></div>
</div></p></blockquote></blockquote></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of <span class="stt">f</span> and what does <span class="stt">f 2.0 false</span> evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f a b =</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> b &gt; <span class="kw">false</span> <span class="kw">then</span> a</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">else</span> <span class="fl">2.3</span> ;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>f <span class="fl">2.0</span> <span class="kw">false</span>;;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="f24-2h" value="1" data-correct="true"/> float -&gt; bool -&gt; float, evaluates to 2.3</label></p><p><label class="quiz-option"><input type="radio" name="f24-2h" value="2"/> float -&gt; bool -&gt; float, evaluates to 2.0</label></p><p><label class="quiz-option"><input type="radio" name="f24-2h" value="3"/> 'a -&gt; bool -&gt; float, evaluates to 2.3</label></p><p><label class="quiz-option"><input type="radio" name="f24-2h" value="4"/> TYPE ERROR</label></p></blockquote></summary><p>Answer: Type is <span class="stt">float -&gt; bool -&gt; float</span>. <span class="stt">a</span> must match the type of <span class="stt">2.3</span>, so <span class="stt">a : float</span>. <span class="stt">b</span> is compared to <span class="stt">false</span>, so <span class="stt">b : bool</span>. Since <span class="stt">false &gt; false</span> is <span class="stt">false</span>, the else branch runs, returning <span class="stt">2.3</span>.</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>   <span class="kw">let</span> f a b = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> b &gt; <span class="kw">false</span> <span class="kw">then</span> a </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> <span class="fl">2.3</span> ;; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> f <span class="fl">2.0</span> <span class="kw">false</span>;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> f : <span class="dt">float</span> -&gt; <span class="dt">bool</span> -&gt; <span class="dt">float</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">float</span> = <span class="fl">2.3</span></span></code></pre></div>
</div></p></blockquote></blockquote></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of <span class="stt">f</span> and what does <span class="stt">f (fun x -&gt; x mod 2 = 1) [1;2;3]</span> evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> f g lst = <span class="kw">match</span> lst <span class="kw">with</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  [] -&gt; []</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  |x::xs -&gt; (x, g x)::(f g xs) ;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>f (<span class="kw">fun</span> x -&gt; x <span class="kw">mod</span> <span class="dv">2</span> = <span class="dv">1</span>) [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>] ;;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="f24-2i" value="1" data-correct="true"/> ('a -&gt; 'b) -&gt; 'a list -&gt; ('a * 'b) list, evaluates to [(1,true);(2,false);(3,true)]</label></p><p><label class="quiz-option"><input type="radio" name="f24-2i" value="2"/> ('a -&gt; 'b) -&gt; 'a list -&gt; ('b * 'a) list, evaluates to [(true,1);(false,2);(true,3)]</label></p><p><label class="quiz-option"><input type="radio" name="f24-2i" value="3"/> (int -&gt; bool) -&gt; int list -&gt; (int * bool) list, evaluates to [(1,true);(2,false);(3,true)]</label></p><p><label class="quiz-option"><input type="radio" name="f24-2i" value="4"/> TYPE ERROR</label></p></blockquote></summary><p>Answer: Type is <span class="stt">(</span><span class="stt">&rsquo;</span><span class="stt">a -&gt; </span><span class="stt">&rsquo;</span><span class="stt">b) -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a list -&gt; (</span><span class="stt">&rsquo;</span><span class="stt">a * </span><span class="stt">&rsquo;</span><span class="stt">b) list</span>. The function pairs each element <span class="stt">x</span> with <span class="stt">g x</span>. With <span class="stt">g = fun x -&gt; x mod 2 = 1</span>, each element is paired with whether it&rsquo;s odd.</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>   <span class="kw">let</span> <span class="kw">rec</span> f g lst = <span class="kw">match</span> lst <span class="kw">with</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    [] -&gt; [] </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    |x::xs -&gt; (x, g x)::(f g xs) ;; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> f (<span class="kw">fun</span> x -&gt; x <span class="kw">mod</span> <span class="dv">2</span> = <span class="dv">1</span>) [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>] ;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> f : (&#39;a -&gt; &#39;b) -&gt; &#39;a <span class="dt">list</span> -&gt; (&#39;a * &#39;b) <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>- : (<span class="dt">int</span> * <span class="dt">bool</span>) <span class="dt">list</span> = [(<span class="dv">1</span>, <span class="kw">true</span>); (<span class="dv">2</span>, <span class="kw">false</span>); (<span class="dv">3</span>, <span class="kw">true</span>)]</span></code></pre></div>
</div></p></blockquote></blockquote></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of <span class="stt">f</span> and what does <span class="stt">f (fun x -&gt; x mod 2 = 0) [1;2;3]</span> evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> f g lst = <span class="kw">match</span> lst <span class="kw">with</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  [] -&gt; []</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  |x::xs -&gt; (g x, x)::(f g xs) ;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>f (<span class="kw">fun</span> x -&gt; x <span class="kw">mod</span> <span class="dv">2</span> = <span class="dv">0</span>) [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>] ;;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="f24-2j" value="1" data-correct="true"/> ('a -&gt; 'b) -&gt; 'a list -&gt; ('b * 'a) list, evaluates to [(false,1);(true,2);(false,3)]</label></p><p><label class="quiz-option"><input type="radio" name="f24-2j" value="2"/> ('a -&gt; 'b) -&gt; 'a list -&gt; ('a * 'b) list, evaluates to [(1,false);(2,true);(3,false)]</label></p><p><label class="quiz-option"><input type="radio" name="f24-2j" value="3"/> (int -&gt; bool) -&gt; int list -&gt; (bool * int) list, evaluates to [(false,1);(true,2);(false,3)]</label></p><p><label class="quiz-option"><input type="radio" name="f24-2j" value="4"/> TYPE ERROR</label></p></blockquote></summary><p>Answer: Type is <span class="stt">(</span><span class="stt">&rsquo;</span><span class="stt">a -&gt; </span><span class="stt">&rsquo;</span><span class="stt">b) -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a list -&gt; (</span><span class="stt">&rsquo;</span><span class="stt">b * </span><span class="stt">&rsquo;</span><span class="stt">a) list</span>. Note the tuple order is <span class="stt">(g x, x)</span>, so <span class="stt">g</span>&rsquo;s result comes first. Each element is paired with whether it&rsquo;s even.</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>   <span class="kw">let</span> <span class="kw">rec</span> f g lst = <span class="kw">match</span> lst <span class="kw">with</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    [] -&gt; [] </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    |x::xs -&gt; (g x, x)::(f g xs) ;; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> f (<span class="kw">fun</span> x -&gt; x <span class="kw">mod</span> <span class="dv">2</span> = <span class="dv">0</span>) [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>] ;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> f : (&#39;a -&gt; &#39;b) -&gt; &#39;a <span class="dt">list</span> -&gt; (&#39;b * &#39;a) <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>- : (<span class="dt">bool</span> * <span class="dt">int</span>) <span class="dt">list</span> = [(<span class="kw">false</span>, <span class="dv">1</span>); (<span class="kw">true</span>, <span class="dv">2</span>); (<span class="kw">false</span>, <span class="dv">3</span>)]</span></code></pre></div>
</div></p></blockquote></blockquote></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of <span class="stt">f</span> and what does <span class="stt">f (fun x -&gt; x +. 2.0) [1.0;2.0;3.0]</span> evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> f g lst = <span class="kw">match</span> lst <span class="kw">with</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  [] -&gt; []</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  |x::xs -&gt; (g x, x)::(f g xs) ;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>f (<span class="kw">fun</span> x -&gt; x +. <span class="fl">2.0</span>) [<span class="fl">1.0</span>;<span class="fl">2.0</span>;<span class="fl">3.0</span>];;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="f24-2k" value="1" data-correct="true"/> ('a -&gt; 'b) -&gt; 'a list -&gt; ('b * 'a) list, evaluates to [(3.,1.);(4.,2.);(5.,3.)]</label></p><p><label class="quiz-option"><input type="radio" name="f24-2k" value="2"/> (float -&gt; float) -&gt; float list -&gt; (float * float) list, evaluates to [(3.,1.);(4.,2.);(5.,3.)]</label></p><p><label class="quiz-option"><input type="radio" name="f24-2k" value="3"/> ('a -&gt; 'b) -&gt; 'a list -&gt; ('a * 'b) list, evaluates to [(1.,3.);(2.,4.);(3.,5.)]</label></p><p><label class="quiz-option"><input type="radio" name="f24-2k" value="4"/> TYPE ERROR</label></p></blockquote></summary><p>Answer: Type is <span class="stt">(</span><span class="stt">&rsquo;</span><span class="stt">a -&gt; </span><span class="stt">&rsquo;</span><span class="stt">b) -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a list -&gt; (</span><span class="stt">&rsquo;</span><span class="stt">b * </span><span class="stt">&rsquo;</span><span class="stt">a) list</span>. The tuple order is <span class="stt">(g x, x)</span>. Each float has 2.0 added, and the result comes first in the pair.</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>   <span class="kw">let</span> <span class="kw">rec</span> f g lst = <span class="kw">match</span> lst <span class="kw">with</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    [] -&gt; [] </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    |x::xs -&gt; (g x, x)::(f g xs) ;; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> f (<span class="kw">fun</span> x -&gt; x +. <span class="fl">2.0</span>) [<span class="fl">1.0</span>;<span class="fl">2.0</span>;<span class="fl">3.0</span>];;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> f : (&#39;a -&gt; &#39;b) -&gt; &#39;a <span class="dt">list</span> -&gt; (&#39;b * &#39;a) <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>- : (<span class="dt">float</span> * <span class="dt">float</span>) <span class="dt">list</span> = [(<span class="dv">3</span>., <span class="dv">1</span>.); (<span class="dv">4</span>., <span class="dv">2</span>.); (<span class="dv">5</span>., <span class="dv">3</span>.)]</span></code></pre></div>
</div></p></blockquote></blockquote></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of <span class="stt">f</span> and what does <span class="stt">f (fun x -&gt; x *. 2.0) [1.0;2.0;3.0]</span> evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> f g lst = <span class="kw">match</span> lst <span class="kw">with</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  [] -&gt; []</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  |x::xs -&gt; (x, g x)::(f g xs) ;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>f (<span class="kw">fun</span> x -&gt; x *. <span class="fl">2.0</span>) [<span class="fl">1.0</span>;<span class="fl">2.0</span>;<span class="fl">3.0</span>];;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="f24-2l" value="1" data-correct="true"/> ('a -&gt; 'b) -&gt; 'a list -&gt; ('a * 'b) list, evaluates to [(1.,2.);(2.,4.);(3.,6.)]</label></p><p><label class="quiz-option"><input type="radio" name="f24-2l" value="2"/> ('a -&gt; 'b) -&gt; 'a list -&gt; ('b * 'a) list, evaluates to [(2.,1.);(4.,2.);(6.,3.)]</label></p><p><label class="quiz-option"><input type="radio" name="f24-2l" value="3"/> (float -&gt; float) -&gt; float list -&gt; (float * float) list, evaluates to [(1.,2.);(2.,4.);(3.,6.)]</label></p><p><label class="quiz-option"><input type="radio" name="f24-2l" value="4"/> TYPE ERROR</label></p></blockquote></summary><p>Answer: Type is <span class="stt">(</span><span class="stt">&rsquo;</span><span class="stt">a -&gt; </span><span class="stt">&rsquo;</span><span class="stt">b) -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a list -&gt; (</span><span class="stt">&rsquo;</span><span class="stt">a * </span><span class="stt">&rsquo;</span><span class="stt">b) list</span>. The tuple order is <span class="stt">(x, g x)</span>. Each float is doubled by <span class="stt">g</span>, and the original comes first in the pair.</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>   <span class="kw">let</span> <span class="kw">rec</span> f g lst = <span class="kw">match</span> lst <span class="kw">with</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    [] -&gt; [] </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    |x::xs -&gt; (x, g x)::(f g xs) ;; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> f (<span class="kw">fun</span> x -&gt; x *. <span class="fl">2.0</span>) [<span class="fl">1.0</span>;<span class="fl">2.0</span>;<span class="fl">3.0</span>];;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> f : (&#39;a -&gt; &#39;b) -&gt; &#39;a <span class="dt">list</span> -&gt; (&#39;a * &#39;b) <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>- : (<span class="dt">float</span> * <span class="dt">float</span>) <span class="dt">list</span> = [(<span class="dv">1</span>., <span class="dv">2</span>.); (<span class="dv">2</span>., <span class="dv">4</span>.); (<span class="dv">3</span>., <span class="dv">6</span>.)]</span></code></pre></div>
</div></p></blockquote></blockquote></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of <span class="stt">foo</span> and what does <span class="stt">foo [1;2;3;4;5]</span> evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> foo lst =</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> lst <span class="kw">with</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  h1::h2::t -&gt; h2 :: h1 :: foo t</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  | _ -&gt; lst;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>foo [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>;<span class="dv">4</span>;<span class="dv">5</span>];;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="q2a" value="1" data-correct="true"/> 'a list -&gt; 'a list, evaluates to [2;1;4;3;5]</label></p><p><label class="quiz-option"><input type="radio" name="q2a" value="2"/> 'a list -&gt; 'a list, evaluates to [1;2;3;4;5]</label></p><p><label class="quiz-option"><input type="radio" name="q2a" value="3"/> int list -&gt; int list, evaluates to [2;1;4;3;5]</label></p><p><label class="quiz-option"><input type="radio" name="q2a" value="4"/> TYPE ERROR</label></p></blockquote></summary><p>Answer: Type is <span class="stt"></span><span class="stt">&rsquo;</span><span class="stt">a list -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a list</span>. It swaps adjacent pairs of elements. <span class="stt">foo [1;2;3;4;5]</span> evaluates to <span class="stt">[2;1;4;3;5]</span>. The first pair <span class="stt">1,2</span> becomes <span class="stt">2,1</span>, the second pair <span class="stt">3,4</span> becomes <span class="stt">4,3</span>, and <span class="stt">5</span> is left as-is by the wildcard case.</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>   <span class="kw">let</span> <span class="kw">rec</span> foo lst = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> lst <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    h1::h2::t -&gt; h2 :: h1 :: foo t </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    | _ -&gt; lst;; </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> foo [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>;<span class="dv">4</span>;<span class="dv">5</span>];;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> foo : &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">2</span>; <span class="dv">1</span>; <span class="dv">4</span>; <span class="dv">3</span>; <span class="dv">5</span>]</span></code></pre></div>
</div></p></blockquote></blockquote></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of <span class="stt">foo</span> and what does the call evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> foo f x = f (f x);;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>foo (<span class="kw">fun</span> x -&gt; [<span class="dt">List</span>.length x]) [<span class="dv">3</span>;<span class="dv">6</span>;<span class="dv">9</span>];;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="q2b" value="1" data-correct="true"/> ('a -&gt; 'a) -&gt; 'a -&gt; 'a, evaluates to [1]</label></p><p><label class="quiz-option"><input type="radio" name="q2b" value="2"/> ('a -&gt; 'b) -&gt; 'a -&gt; 'b, evaluates to [1]</label></p><p><label class="quiz-option"><input type="radio" name="q2b" value="3"/> ('a -&gt; 'a) -&gt; 'a -&gt; 'a, evaluates to ERROR</label></p><p><label class="quiz-option"><input type="radio" name="q2b" value="4"/> TYPE ERROR</label></p></blockquote></summary><p>Answer: Type of <span class="stt">foo</span> is <span class="stt">(</span><span class="stt">&rsquo;</span><span class="stt">a -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a) -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a</span>. Since <span class="stt">f (f x)</span> requires the output type of <span class="stt">f</span> to match its input type. Here <span class="stt">f = fun x -&gt; [List.length x]</span> has type <span class="stt">int list -&gt; int list</span> (unifying <span class="stt"></span><span class="stt">&rsquo;</span><span class="stt">a = int</span>). So <span class="stt">f [3;6;9] = [3]</span>, then <span class="stt">f [3] = [1]</span>. The result is <span class="stt">[1]</span>.</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>   <span class="kw">let</span> foo f x = f (f x);; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> foo (<span class="kw">fun</span> x -&gt; [<span class="dt">List</span>.length x]) [<span class="dv">3</span>;<span class="dv">6</span>;<span class="dv">9</span>];;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> foo : (&#39;a -&gt; &#39;a) -&gt; &#39;a -&gt; &#39;a = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">1</span>]</span></code></pre></div>
</div></p></blockquote></blockquote></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of the following function?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f a b = <span class="kw">if</span> b <span class="kw">then</span> a <span class="kw">else</span> (a+<span class="dv">1</span>)</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="q1" value="1" data-correct="true"/> int -&gt; bool -&gt; int</label></p><p><label class="quiz-option"><input type="radio" name="q1" value="2"/> 'a -&gt; bool -&gt; 'a</label></p><p><label class="quiz-option"><input type="radio" name="q1" value="3"/> int -&gt; 'a -&gt; int</label></p><p><label class="quiz-option"><input type="radio" name="q1" value="4"/> Type Error</label></p></blockquote></summary><p>Answer: int -&gt; bool -&gt; int. The else branch is &lsquo;a+1&lsquo;, which implies &lsquo;a&lsquo; must be an integer. The if condition &lsquo;b&lsquo; must be a boolean. The function returns an integer.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What does the following code evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = <span class="dv">3</span> <span class="kw">in</span> <span class="kw">let</span> x = <span class="dv">4</span> <span class="kw">in</span> x * x</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="q2" value="1"/> 9</label></p><p><label class="quiz-option"><input type="radio" name="q2" value="2" data-correct="true"/> 16</label></p><p><label class="quiz-option"><input type="radio" name="q2" value="3"/> 12</label></p><p><label class="quiz-option"><input type="radio" name="q2" value="4"/> Type Error</label></p></blockquote></summary><p>Answer: 16. The &lsquo;let x = 4&lsquo; shadows the &lsquo;let x = 3&lsquo;. So &lsquo;x&lsquo; is 4, and &lsquo;x * x&lsquo; is 16.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of &lsquo;fold&lsquo;?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> fold f acc l =</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  | [] -&gt; acc</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  | h::t -&gt; fold f (f acc h) t</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="q3" value="1" data-correct="true"/> ('a -&gt; 'b -&gt; 'a) -&gt; 'a -&gt; 'b list -&gt; 'a</label></p><p><label class="quiz-option"><input type="radio" name="q3" value="2"/> ('a -&gt; 'b -&gt; 'b) -&gt; 'b -&gt; 'a list -&gt; 'b</label></p><p><label class="quiz-option"><input type="radio" name="q3" value="3"/> ('a -&gt; 'a -&gt; 'a) -&gt; 'a -&gt; 'a list -&gt; 'a</label></p><p><label class="quiz-option"><input type="radio" name="q3" value="4"/> Type Error</label></p></blockquote></summary><p>Answer: (&rsquo;a -&gt; &rsquo;b -&gt; &rsquo;a) -&gt; &rsquo;a -&gt; &rsquo;b list -&gt; &rsquo;a. This is the standard definition of &lsquo;fold_left&lsquo;. The accumulator &lsquo;acc&lsquo; has type &lsquo;&rsquo;a&lsquo;, the list elements have type &lsquo;&rsquo;b&lsquo;, and the function &lsquo;f&lsquo; takes the accumulator and a list element and returns a new accumulator.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of the following OCaml expression?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = <span class="dv">3</span>::[<span class="dv">1</span>;<span class="dv">2</span>]</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="q4" value="1"/> int</label></p><p><label class="quiz-option"><input type="radio" name="q4" value="2" data-correct="true"/> int list</label></p><p><label class="quiz-option"><input type="radio" name="q4" value="3"/> 'a list</label></p><p><label class="quiz-option"><input type="radio" name="q4" value="4"/> Type Error</label></p></blockquote></summary><p>Answer: int list. The &lsquo;::&lsquo; operator prepends an element to a list. Since &lsquo;3&lsquo; is an &lsquo;int&lsquo; and &lsquo;[1;2]&lsquo; is an &lsquo;int list&lsquo;, the result is an &lsquo;int list&lsquo;.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the value of the following OCaml expression?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = <span class="dv">1</span> <span class="kw">in</span> <span class="kw">let</span> y = <span class="dv">2</span> <span class="kw">in</span> <span class="kw">let</span> x = <span class="dv">3</span> <span class="kw">in</span> x + y</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="q5" value="1"/> 3</label></p><p><label class="quiz-option"><input type="radio" name="q5" value="2"/> 4</label></p><p><label class="quiz-option"><input type="radio" name="q5" value="3" data-correct="true"/> 5</label></p><p><label class="quiz-option"><input type="radio" name="q5" value="4"/> Type Error</label></p></blockquote></summary><p>Answer: 5. The innermost &lsquo;let x = 3&lsquo; shadows the outer &lsquo;let x = 1&lsquo;. The expression &lsquo;x + y&lsquo; therefore evaluates to &lsquo;3 + 2&lsquo;, which is 5.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the value of the following OCaml expression?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f x = x + <span class="dv">1</span> <span class="kw">in</span> <span class="kw">let</span> g = f <span class="kw">in</span> g (f <span class="dv">2</span>)</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="q6" value="1"/> 3</label></p><p><label class="quiz-option"><input type="radio" name="q6" value="2" data-correct="true"/> 4</label></p><p><label class="quiz-option"><input type="radio" name="q6" value="3"/> 5</label></p><p><label class="quiz-option"><input type="radio" name="q6" value="4"/> Type Error</label></p></blockquote></summary><p>Answer: 4. &lsquo;f 2&lsquo; evaluates to &lsquo;2 + 1 = 3&lsquo;. &lsquo;g&lsquo; is an alias for &lsquo;f&lsquo;, so &lsquo;g (f 2)&lsquo; is &lsquo;f(3)&lsquo;, which evaluates to &lsquo;3 + 1 = 4&lsquo;.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of the following OCaml expression?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f x y = <span class="kw">if</span> x <span class="kw">then</span> y <span class="kw">else</span> x</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="q7" value="1"/> bool -&gt; 'a -&gt; bool</label></p><p><label class="quiz-option"><input type="radio" name="q7" value="2" data-correct="true"/> bool -&gt; bool -&gt; bool</label></p><p><label class="quiz-option"><input type="radio" name="q7" value="3"/> 'a -&gt; 'b -&gt; 'a</label></p><p><label class="quiz-option"><input type="radio" name="q7" value="4"/> Type Error</label></p></blockquote></summary><p>Answer: bool -&gt; bool -&gt; bool. The &lsquo;if&lsquo; condition &lsquo;x&lsquo; must be a &lsquo;bool&lsquo;. Since the &lsquo;else&lsquo; branch returns &lsquo;x&lsquo;, the return type of the function must also be &lsquo;bool&lsquo;. The &lsquo;then&lsquo; branch returns &lsquo;y&lsquo;, so &lsquo;y&lsquo; must also be of type &lsquo;bool&lsquo;.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>Which of the following is equivalent to mapping a function &lsquo;f&lsquo; over a list and then summing the result, all in OCaml?</p><p><label class="quiz-option"><input type="radio" name="sp15-quiz1-1" value="1" data-correct="true"/> let g lst = List.fold_left (+) 0 (List.map f lst)</label></p><p><label class="quiz-option"><input type="radio" name="sp15-quiz1-1" value="2"/> let g lst = List.map (fun x -&gt; x + 1) (List.fold_left f 0 lst)</label></p><p><label class="quiz-option"><input type="radio" name="sp15-quiz1-1" value="3" data-correct="true"/> let g lst = List.fold_left (fun acc x -&gt; acc + f x) 0 lst</label></p><p><label class="quiz-option"><input type="radio" name="sp15-quiz1-1" value="4"/> let g lst = List.map (fun x -&gt; x + f x) lst</label></p></blockquote></summary><p>Answer: Both Option 1 and Option 3 are correct.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of the following OCaml expression?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> z lst = <span class="kw">match</span> lst <span class="kw">with</span> [] -&gt; <span class="dv">0</span> | a::b -&gt; a + z b;;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="sp15-quiz1-2" value="1" data-correct="true"/> int list -&gt; int</label></p><p><label class="quiz-option"><input type="radio" name="sp15-quiz1-2" value="2"/> 'a list -&gt; int</label></p><p><label class="quiz-option"><input type="radio" name="sp15-quiz1-2" value="3"/> int -&gt; int</label></p><p><label class="quiz-option"><input type="radio" name="sp15-quiz1-2" value="4"/> Type Error</label></p></blockquote></summary><p>Answer: &lsquo;int list -&gt; int&lsquo;.  The function takes an integer list as input, and returns the sum of the integers in the list. Thus it returns an integer.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the value of the following OCaml expression?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> a = <span class="dv">1</span> <span class="kw">in</span> <span class="kw">let</span> b = <span class="dv">2</span> <span class="kw">in</span> <span class="kw">let</span> a = a + b <span class="kw">in</span> a * b</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="sp15-quiz1-3" value="1"/> 2</label></p><p><label class="quiz-option"><input type="radio" name="sp15-quiz1-3" value="2"/> 3</label></p><p><label class="quiz-option"><input type="radio" name="sp15-quiz1-3" value="3" data-correct="true"/> 6</label></p><p><label class="quiz-option"><input type="radio" name="sp15-quiz1-3" value="4"/> Type Error</label></p></blockquote></summary><p>Answer: 6. &lsquo;a&lsquo; is first assigned &lsquo;1&lsquo;, and &lsquo;b&lsquo; is assigned &lsquo;2&lsquo;. Then, &lsquo;a&lsquo; is reassigned to the value of &lsquo;a + b&lsquo;, which is &lsquo;1 + 2 = 3&lsquo;. Finally, the expression evaluates &lsquo;a * b = 3 * 2 = 6&lsquo;.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of the following OCaml expression?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>[[<span class="fl">1.0</span>];[<span class="fl">2.0</span>;<span class="fl">3.0</span>]]</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="fa15-q2-1" value="1" data-correct="true"/> float list list</label></p><p><label class="quiz-option"><input type="radio" name="fa15-q2-1" value="2"/> float list</label></p><p><label class="quiz-option"><input type="radio" name="fa15-q2-1" value="3"/> 'a list list</label></p><p><label class="quiz-option"><input type="radio" name="fa15-q2-1" value="4"/> Type Error</label></p></blockquote></summary><p>Answer: float list list. Each inner list contains floats, making them float list. The outer list contains float lists, giving float list list.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of the following OCaml expression?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f (x::_) = x;;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="fa15-q2-2" value="1" data-correct="true"/> 'a list -&gt; 'a</label></p><p><label class="quiz-option"><input type="radio" name="fa15-q2-2" value="2"/> 'a -&gt; 'a</label></p><p><label class="quiz-option"><input type="radio" name="fa15-q2-2" value="3"/> int list -&gt; int</label></p><p><label class="quiz-option"><input type="radio" name="fa15-q2-2" value="4"/> Type Error</label></p></blockquote></summary><p>Answer: &rsquo;a list -&gt; &rsquo;a. The pattern (x::_) matches the head of any list. Since x is unconstrained, the result is polymorphic &rsquo;a list -&gt; &rsquo;a. (A warning is produced for incomplete pattern matching since [] is unhandled.)</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>The function <span class="stt">sumSmall lst x</span> recursively sums elements of <span class="stt">lst</span> strictly less than <span class="stt">x</span>. What does the following evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>sumSmall [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">1</span>;<span class="dv">4</span>;<span class="dv">2</span>;<span class="dv">3</span>] <span class="dv">3</span></span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="fa15-q2-3" value="1" data-correct="true"/> 6</label></p><p><label class="quiz-option"><input type="radio" name="fa15-q2-3" value="2"/> 3</label></p><p><label class="quiz-option"><input type="radio" name="fa15-q2-3" value="3"/> 4</label></p><p><label class="quiz-option"><input type="radio" name="fa15-q2-3" value="4"/> 10</label></p></blockquote></summary><p>Answer: 6. The elements of [1;2;1;4;2;3] strictly less than 3 are 1, 2, 1, and 2. Their sum is 1 + 2 + 1 + 2 = 6.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>Which of the following correctly implements <span class="stt">timesThree</span> using <span class="stt">map</span>, taking a float list and returning a list with each element multiplied by 3?</p><p><label class="quiz-option"><input type="radio" name="fa15-q2-4" value="1" data-correct="true"/> <div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> timesThree lst = <span class="dt">List</span>.map (<span class="kw">fun</span> x -&gt; x *. <span class="fl">3.0</span>) lst</span></code></pre></div>
</div></label></p><p><label class="quiz-option"><input type="radio" name="fa15-q2-4" value="2"/> <div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> timesThree lst = <span class="dt">List</span>.fold_left (<span class="kw">fun</span> acc x -&gt; acc *. x) <span class="fl">3.0</span> lst</span></code></pre></div>
</div></label></p><p><label class="quiz-option"><input type="radio" name="fa15-q2-4" value="3"/> <div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> timesThree lst = <span class="dt">List</span>.map (<span class="kw">fun</span> x -&gt; x +. <span class="fl">3.0</span>) lst</span></code></pre></div>
</div></label></p><p><label class="quiz-option"><input type="radio" name="fa15-q2-4" value="4"/> <div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> timesThree lst = <span class="dt">List</span>.map (<span class="kw">fun</span> x -&gt; x * <span class="dv">3</span>) lst</span></code></pre></div>
</div></label></p></blockquote></summary><p>Answer: let timesThree lst = List.map (fun x -&gt; x *. 3.0) lst. The anonymous function multiplies each float element by 3.0 using the float multiplication operator *.</p></details></details><details class="SubFlow accordion-section"><summary><span style="font-weight: bold">Expression Typing</span></summary><details class="SubFlow"><summary class="SubFlow"><blockquote class="SubFlow"><p>Write an expression that would have the type <span class="stt">int list -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a -&gt; bool</span>.</p></blockquote></summary><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> x y z -&gt; <span class="kw">match</span> x <span class="kw">with</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> |h::t -&gt; (<span class="kw">if</span> h = <span class="dv">0</span> <span class="kw">then</span> y = z <span class="kw">else</span> <span class="kw">false</span>) </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> |[] -&gt; <span class="kw">true</span>;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> -&gt; &#39;a -&gt; &#39;a -&gt; <span class="dt">bool</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="SubFlow"><p>Write an expression that would have the type <span class="stt">(int -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a) -&gt; int -&gt; int * </span><span class="stt">&rsquo;</span><span class="stt">a list</span>.</p></blockquote></summary><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> f a -&gt; (a + <span class="dv">1</span>, [f a]);;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>- : (<span class="dt">int</span> -&gt; &#39;a) -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> * &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="SubFlow"><p>Write an expression that would have the type <span class="stt">(</span><span class="stt">&rsquo;</span><span class="stt">a -&gt; </span><span class="stt">&rsquo;</span><span class="stt">b) -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a -&gt; </span><span class="stt">&rsquo;</span><span class="stt">b -&gt; bool</span>.</p></blockquote></summary><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> x y z -&gt; (x y) = z;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>- : (&#39;a -&gt; &#39;b) -&gt; &#39;a -&gt; &#39;b -&gt; <span class="dt">bool</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="SubFlow"><p>Write an expression that would have the type <span class="stt">float -&gt; float -&gt; bool -&gt; float list</span>.</p></blockquote></summary><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> x y z -&gt; <span class="kw">if</span> z <span class="kw">then</span> [x +. <span class="fl">1.0</span>] <span class="kw">else</span> [y];;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">float</span> -&gt; <span class="dt">float</span> -&gt; <span class="dt">bool</span> -&gt; <span class="dt">float</span> <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="SubFlow"><p>Write an expression that would have the type <span class="stt">(int * </span><span class="stt">&rsquo;</span><span class="stt">a) -&gt; (bool -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a) -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a</span>.</p></blockquote></summary><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> (a, b) c -&gt; <span class="kw">if</span> a + <span class="dv">1</span> = <span class="dv">2</span> <span class="kw">then</span> b <span class="kw">else</span> c <span class="kw">true</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> * &#39;a -&gt; (<span class="dt">bool</span> -&gt; &#39;a) -&gt; &#39;a = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="SubFlow"><p>Write an expression that would have the type <span class="stt">int list -&gt; int -&gt; bool list</span>.</p></blockquote></summary><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> x y -&gt; <span class="kw">match</span> x <span class="kw">with</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> |h::t -&gt; [h + <span class="dv">1</span> = y] </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> |[] -&gt; [<span class="kw">false</span>];;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">bool</span> <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="SubFlow"><p>Write an expression that would have the type <span class="stt"></span><span class="stt">&rsquo;</span><span class="stt">a -&gt; </span><span class="stt">&rsquo;</span><span class="stt">b list -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a * </span><span class="stt">&rsquo;</span><span class="stt">a</span>.</p></blockquote></summary><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> x y z -&gt; <span class="kw">if</span> y = [] &amp;&amp; x = z <span class="kw">then</span> (x, z) <span class="kw">else</span> (x, z);;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>- : &#39;a -&gt; &#39;b <span class="dt">list</span> -&gt; &#39;a -&gt; &#39;a * &#39;a = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="SubFlow"><p>Write an expression that would have the type <span class="stt"></span><span class="stt">&rsquo;</span><span class="stt">a -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a -&gt; bool list</span>.</p></blockquote></summary><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> a b -&gt; [a = b];;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>- : &#39;a -&gt; &#39;a -&gt; <span class="dt">bool</span> <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="SubFlow"><p>Write an expression that would have the type <span class="stt">(</span><span class="stt">&rsquo;</span><span class="stt">a -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a) -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a -&gt; int</span>.</p></blockquote></summary><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> f a -&gt; <span class="kw">if</span> (f a) = a <span class="kw">then</span> <span class="dv">3</span> <span class="kw">else</span> <span class="dv">5</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>- : (&#39;a -&gt; &#39;a) -&gt; &#39;a -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="SubFlow"><p>Write an expression that would have the type <span class="stt">float -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a -&gt; (</span><span class="stt">&rsquo;</span><span class="stt">a * float)</span>.</p></blockquote></summary><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> a b -&gt; (b, a +. <span class="dv">2</span>.);;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">float</span> -&gt; &#39;a -&gt; &#39;a * <span class="dt">float</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="SubFlow"><p>Write an expression that would have the type <span class="stt">string -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a -&gt; (</span><span class="stt">&rsquo;</span><span class="stt">a * float * </span><span class="stt">&rsquo;</span><span class="stt">a)</span>.</p></blockquote></summary><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> s a -&gt; (a, (<span class="dt">float_of_string</span> s), a);;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">string</span> -&gt; &#39;a -&gt; &#39;a * <span class="dt">float</span> * &#39;a = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="SubFlow"><p>Write an expression that would have the type <span class="stt">bool -&gt; int -&gt; (bool * int) list</span>.</p></blockquote></summary><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> b i -&gt; [b &gt; <span class="kw">true</span>, i + <span class="dv">3</span>];;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">bool</span> -&gt; <span class="dt">int</span> -&gt; (<span class="dt">bool</span> * <span class="dt">int</span>) <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="SubFlow"><p>Write an expression that would have the type <span class="stt">(int -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a) -&gt; </span><span class="stt">&rsquo;</span><span class="stt">b -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a</span>.</p></blockquote></summary><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> f a -&gt; f <span class="dv">3</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>- : (<span class="dt">int</span> -&gt; &#39;a) -&gt; &#39;b -&gt; &#39;a = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="SubFlow"><p>Write an expression that would have the type <span class="stt">(</span><span class="stt">&rsquo;</span><span class="stt">a -&gt; </span><span class="stt">&rsquo;</span><span class="stt">b) -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a -&gt; </span><span class="stt">&rsquo;</span><span class="stt">b</span>.</p></blockquote></summary><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> f b -&gt; f b;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>- : (&#39;a -&gt; &#39;b) -&gt; &#39;a -&gt; &#39;b = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="SubFlow"><p>Write an expression that would have the type <span class="stt">(</span><span class="stt">&rsquo;</span><span class="stt">a -&gt; </span><span class="stt">&rsquo;</span><span class="stt">b -&gt; </span><span class="stt">&rsquo;</span><span class="stt">c) -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a -&gt; </span><span class="stt">&rsquo;</span><span class="stt">b -&gt; </span><span class="stt">&rsquo;</span><span class="stt">c</span>.</p></blockquote></summary><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> f a b -&gt; f a b;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>- : (&#39;a -&gt; &#39;b -&gt; &#39;c) -&gt; &#39;a -&gt; &#39;b -&gt; &#39;c = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="SubFlow"><p>Write an OCaml expression of type <span class="stt">int list -&gt; int -&gt; int</span>, without type annotations and without non-exhaustive pattern matching.</p></blockquote></summary><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> a b -&gt; <span class="kw">let</span> _ = b :: a <span class="kw">in</span> b + <span class="dv">1</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="SubFlow"><p>Write an OCaml expression of type <span class="stt"></span><span class="stt">&rsquo;</span><span class="stt">a list -&gt; </span><span class="stt">&rsquo;</span><span class="stt">b -&gt; </span><span class="stt">&rsquo;</span><span class="stt">b list</span>, without type annotations and without non-exhaustive pattern matching.</p></blockquote></summary><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> a b -&gt; <span class="kw">if</span> a = [] <span class="kw">then</span> [b] <span class="kw">else</span> [b];;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>- : &#39;a <span class="dt">list</span> -&gt; &#39;b -&gt; &#39;b <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="SubFlow"><p><div class="SIntrapara">The following OCaml code does not compile. What is wrong, and how do you fix it?</div><div class="SIntrapara"><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f x = <span class="dv">1</span> +. x +. <span class="dv">3</span></span></code></pre></div>
</div></div></p></blockquote></summary><p>Answer: The literals <span class="stt">1</span> and <span class="stt">3</span> are integers, but <span class="stt">+.</span> is the float
addition operator and requires float operands. Change them to float literals:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f x = <span class="fl">1.0</span> +. x +. <span class="fl">3.0</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> f : <span class="dt">float</span> -&gt; <span class="dt">float</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></details><details class="SubFlow"><summary>Write an OCaml function <span class="stt">f</span> of type <span class="stt">(int list -&gt; int) -&gt; int -&gt; int</span>.</summary><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f a b = <span class="kw">let</span> x = a [<span class="dv">1</span>] <span class="kw">in</span> b + x;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> f : (<span class="dt">int</span> <span class="dt">list</span> -&gt; <span class="dt">int</span>) -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote><p><span class="stt">a</span> is a function from <span class="stt">int list</span> to <span class="stt">int</span>; calling <span class="stt">a [1]</span> gives an <span class="stt">int</span> bound to <span class="stt">x</span>. Then <span class="stt">b + x</span> produces an <span class="stt">int</span>.</p></details><details class="SubFlow"><summary>Write an OCaml function <span class="stt">f</span> of type <span class="stt"></span><span class="stt">&rsquo;</span><span class="stt">a -&gt; (</span><span class="stt">&rsquo;</span><span class="stt">a -&gt; </span><span class="stt">&rsquo;</span><span class="stt">b) -&gt; </span><span class="stt">&rsquo;</span><span class="stt">b -&gt; </span><span class="stt">&rsquo;</span><span class="stt">b list</span>.</summary><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f a b c = [(b a); c];;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> f : &#39;a -&gt; (&#39;a -&gt; &#39;b) -&gt; &#39;b -&gt; &#39;b <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote><p><span class="stt">b a</span> applies the function <span class="stt">b : </span><span class="stt">&rsquo;</span><span class="stt">a -&gt; </span><span class="stt">&rsquo;</span><span class="stt">b</span> to <span class="stt">a : </span><span class="stt">&rsquo;</span><span class="stt">a</span>, yielding a <span class="stt"></span><span class="stt">&rsquo;</span><span class="stt">b</span>. The result list <span class="stt">[(b a); c]</span> contains two <span class="stt"></span><span class="stt">&rsquo;</span><span class="stt">b</span> elements.</p></details><details class="SubFlow"><summary>Write an OCaml expression of type <span class="stt">(</span><span class="stt">&rsquo;</span><span class="stt">a -&gt; int) * (</span><span class="stt">&rsquo;</span><span class="stt">b -&gt; float)</span>.</summary><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">fun</span> x -&gt; <span class="dv">3</span>, <span class="kw">fun</span> x -&gt; <span class="dv">3</span>.);;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>- : &#39;a -&gt; <span class="dt">int</span> * (&#39;b -&gt; <span class="dt">float</span>) = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote><p>This is a tuple: the first component <span class="stt">fun x -&gt; 3</span> ignores its argument and returns the <span class="stt">int</span> <span class="stt">3</span>; the second <span class="stt">fun x -&gt; 3.</span> returns the <span class="stt">float</span> <span class="stt">3.0</span>.</p></details></details><details class="SubFlow accordion-section"><summary><span style="font-weight: bold">Coding</span></summary><details class="SubFlow"><summary class="SubFlow"><blockquote class="SubFlow"><p>Define a function <span style="font-weight: bold">fold_if</span> that behaves like <span class="stt">fold_left</span>,
but takes an additional predicate argument <span style="font-weight: bold">pred : &rsquo;acc -&gt; &rsquo;a -&gt; bool</span>.
During the fold, before applying the function to the current element,
<span style="font-weight: bold">pred</span> is checked with the current accumulator and the current element.
If <span style="font-weight: bold">pred</span> evaluates to false, the fold stops
and returns the current accumulator.</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* stop when we encounter an element &gt; 10 *)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="dt">pred</span> _acc x = x &lt;= <span class="dv">10</span> <span class="kw">in</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f acc x = acc + x <span class="kw">in</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>fold_if <span class="dt">pred</span> f <span class="dv">0</span> [<span class="dv">1</span>;<span class="dv">4</span>;<span class="dv">6</span>;<span class="dv">11</span>;<span class="dv">2</span>]</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co">(* returns 11 (1+4+6), stops at 11 *)</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co">(* stop once acc &gt;= 10 *)</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> pred_sum acc _x = acc &lt; <span class="dv">10</span> <span class="kw">in</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f acc x = acc + x <span class="kw">in</span> fold_if pred_sum f <span class="dv">0</span> [<span class="dv">3</span>;<span class="dv">4</span>;<span class="dv">5</span>;<span class="dv">1</span>]</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="co">(* returns 12 (3+4+5), stops before processing 1 *)</span></span></code></pre></div>
</div></p></blockquote></summary><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> fold_if <span class="dt">pred</span> f init lst =</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> lst <span class="kw">with</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  | [] -&gt; init</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  | x :: xs -&gt;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> <span class="dt">pred</span> init x <span class="kw">then</span> fold_if <span class="dt">pred</span> f (f init x) xs</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> init</span></code></pre></div>
</div></p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="SubFlow"><p><span class="stt">filter</span> is a common higher order function that has type <span class="stt">(</span><span class="stt">&rsquo;</span><span class="stt">a -&gt; bool) -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a list -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a list</span>. It applies
a function to every item in a list and returns a list of the items that caused the function to return true. <span style="font-weight: bold">Using only fold</span>
(left or right), write a function called <span class="stt">my_filter</span> which has the same functionality as <span class="stt">filter</span>. <span class="stt">f</span> will be the
function that returns true or false, and <span class="stt">l</span> will be the list. Note: the original order must be maintained.</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* example: my_filter (fun x -&gt; x &gt; 3) [2;4;6] = [4;6] *)</span></span></code></pre></div>
</div></p></blockquote></summary><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* Using fold_right *)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> my_filter f l =</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  fold_right (<span class="kw">fun</span> x acc -&gt; <span class="kw">if</span> f x <span class="kw">then</span> x :: acc <span class="kw">else</span> acc) l []</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co">(* Alternatively, using fold_left *)</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> my_filter f l =</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  fold_left (<span class="kw">fun</span> acc x -&gt; <span class="kw">if</span> f x <span class="kw">then</span> acc @ [x] <span class="kw">else</span> acc) [] l</span></code></pre></div>
</div></p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="SubFlow"><p>Write a function <span class="stt">last_sum</span> which takes in a <span class="stt">int list list</span> and returns the sum of the last elements in each <span class="stt">int list</span>. If a list is empty, it adds nothing to the total.</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* last_sum has type int list list -&gt; int *)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">(* Examples:</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">   last_sum [] = 0</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co">   last_sum [[1;2;3];[4;5;6];[7;8;9]] = 18  (* 3 + 6 + 9 *)</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co">   last_sum [[];[1];[2;3]] = 4               (* 0 + 1 + 3 *)</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co">*)</span></span></code></pre></div>
</div></p></blockquote></summary><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* Using map and fold_left *)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> last_sum mtx =</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> lasts = map (<span class="kw">fun</span> x -&gt; fold_left (<span class="kw">fun</span> acc el -&gt; el) <span class="dv">0</span> x) mtx <span class="kw">in</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  fold_left (+) <span class="dv">0</span> lasts</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co">(* Alternatively, using only fold_left *)</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> last_sum mtx =</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  fold_left (<span class="kw">fun</span> a x -&gt; a + (fold_left (<span class="kw">fun</span> a x -&gt; x) <span class="dv">0</span> x)) <span class="dv">0</span> mtx</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="co">(* Alternatively, with a helper function *)</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> get_last lst = <span class="kw">match</span> lst <span class="kw">with</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>  | [] -&gt; <span class="dv">0</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>  | [x] -&gt; x</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>  | _ :: xs -&gt; get_last xs</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> last_sum mtx =</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> lasts = map (<span class="kw">fun</span> x -&gt; get_last x) mtx <span class="kw">in</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>  fold_left (+) <span class="dv">0</span> lasts</span></code></pre></div>
</div></p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="SubFlow"><p>Write a function <span class="stt">last_prod</span> which takes in a <span class="stt">int list list</span> and returns the product of the last elements in each <span class="stt">int list</span>. If a list is empty, it multiplies the value by 1.</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* last_prod has type int list list -&gt; int *)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">(* Examples:</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">   last_prod [] = 1</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co">   last_prod [[1;2;3];[4;5;6];[7;8;9]] = 162  (* 3 * 6 * 9 *)</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co">   last_prod [[];[1];[2;3]] = 3                (* 1 * 1 * 3 *)</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co">*)</span></span></code></pre></div>
</div></p></blockquote></summary><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* Using map and fold_left *)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> last_prod mtx =</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> lasts = map (<span class="kw">fun</span> x -&gt; fold_left (<span class="kw">fun</span> acc el -&gt; el) <span class="dv">1</span> x) mtx <span class="kw">in</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  fold_left ( * ) <span class="dv">1</span> lasts</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co">(* Alternatively, using only fold_left *)</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> last_prod mtx =</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  fold_left (<span class="kw">fun</span> a x -&gt; a * (fold_left (<span class="kw">fun</span> a x -&gt; x) <span class="dv">1</span> x)) <span class="dv">1</span> mtx</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="co">(* Alternatively, with a helper function *)</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> get_last lst = <span class="kw">match</span> lst <span class="kw">with</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>  | [] -&gt; <span class="dv">1</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>  | [x] -&gt; x</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>  | _ :: xs -&gt; get_last xs</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> last_prod mtx =</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> lasts = map (<span class="kw">fun</span> x -&gt; get_last x) mtx <span class="kw">in</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>  fold_left ( * ) <span class="dv">1</span> lasts</span></code></pre></div>
</div></p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="SubFlow"><p>Write a function <span class="stt">last_concat</span> which takes in a <span class="stt">string list list</span> and returns the result of concatenating the last elements in each <span class="stt">string list</span>. If a list is empty, it should not modify the resulting string.</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* last_concat has type string list list -&gt; string *)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">(* Examples:</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">   last_concat [] = &quot;&quot;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co">   last_concat [[&quot;a&quot;;&quot;b&quot;];[&quot;c&quot;;&quot;d&quot;];[&quot;e&quot;;&quot;f&quot;]] = &quot;bdf&quot;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co">   last_concat [[];[&quot;a&quot;];[&quot;b&quot;;&quot;c&quot;]] = &quot;ac&quot;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co">*)</span></span></code></pre></div>
</div></p></blockquote></summary><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* Using map and fold_right *)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> last_concat mtx =</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> lasts = map (<span class="kw">fun</span> x -&gt; fold_left (<span class="kw">fun</span> acc el -&gt; el) <span class="st">&quot;&quot;</span> x) mtx <span class="kw">in</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  fold_right ( ^ ) lasts <span class="st">&quot;&quot;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co">(* Alternatively, with a helper function *)</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> get_last lst = <span class="kw">match</span> lst <span class="kw">with</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  | [] -&gt; <span class="st">&quot;&quot;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  | [x] -&gt; x</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  | _ :: xs -&gt; get_last xs</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> last_concat mtx =</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> lasts = map (<span class="kw">fun</span> x -&gt; get_last x) mtx <span class="kw">in</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>  fold_right ( ^ ) lasts <span class="st">&quot;&quot;</span></span></code></pre></div>
</div></p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="SubFlow"><p>Write a function <span class="stt">encode</span> that takes a <span class="stt">int list</span> and returns a <span class="stt">string list</span>, which consists of the string <span class="stt">"1"</span> repeated by each number in the <span class="stt">int list</span>. You may assume that all values in the input list are &gt;= 0.</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* Examples:</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">   encode [0;1;2;3] = [&quot;&quot;;&quot;1&quot;;&quot;11&quot;;&quot;111&quot;]</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">   encode [0;0;3] = [&quot;&quot;;&quot;&quot;;&quot;111&quot;]</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co">*)</span></span></code></pre></div>
</div></p></blockquote></summary><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> encode lst =</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> repeat n =</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> n = <span class="dv">0</span> <span class="kw">then</span> <span class="st">&quot;&quot;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> <span class="st">&quot;1&quot;</span> ^ repeat (n - <span class="dv">1</span>) <span class="kw">in</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  map repeat lst</span></code></pre></div>
</div></p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="SubFlow"><p>Write a function <span class="stt">calc</span> that takes a <span class="stt">(int * bool) list</span> and returns a <span class="stt">(int * bool)</span>, which consists of the sum of the ints and the result of AND&rsquo;ing the bools.</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* Examples:</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">   calc [(1,true); (2,false)] = (3,false)</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">   calc [(3,true); (4,true)] = (7,true)</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co">*)</span></span></code></pre></div>
</div></p></blockquote></summary><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* Recursive version *)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> calc lst = <span class="kw">match</span> lst <span class="kw">with</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  | [] -&gt; (<span class="dv">0</span>, <span class="kw">true</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  | (i, b) :: xs -&gt;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> (s, a) = calc xs <span class="kw">in</span> (s + i, b &amp;&amp; a)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co">(* Fold version *)</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> calc lst =</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  fold (<span class="kw">fun</span> (a, b) (c, d) -&gt; (a + c, b &amp;&amp; d)) (<span class="dv">0</span>, <span class="kw">true</span>) lst</span></code></pre></div>
</div></p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="SubFlow"><p>Using either <span class="stt">map</span> or <span class="stt">fold</span> and an anonymous function, write a curried function called <span class="stt">divisible</span> which, given a number <span class="stt">n</span> and a list of ints <span class="stt">lst</span>, returns a list of all elements of <span class="stt">lst</span> that are divisible by <span class="stt">n</span> (maintaining their relative ordering). You are allowed to use <span class="stt">List.rev</span> (reverses a list) and the (curried) <span class="stt">map</span> and <span class="stt">fold</span> functions provided, but no other OCaml library functions. Hint: <span class="stt">x</span> is divisible by <span class="stt">y</span> iff <span class="stt">(x mod y = 0)</span> is true.</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* divisible has type int -&gt; int list -&gt; int list *)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">(* Examples:</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">   divisible 4 [3;16;24] = [16; 24]</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co">   divisible 3 [4;1;11] = []</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co">   divisible 3 [] = []</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co">*)</span></span></code></pre></div>
</div></p></blockquote></summary><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> divisible v lst = <span class="dt">List</span>.rev</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  (fold (<span class="kw">fun</span> a h -&gt; <span class="kw">if</span> (h <span class="kw">mod</span> v = <span class="dv">0</span>) <span class="kw">then</span> (h::a) <span class="kw">else</span> a) [] lst)</span></code></pre></div>
</div></p></details></details></section><section class="SsectionLevel3" id="section 14.2"><h3 class="heading">14.2<span class="stt">&nbsp;</span><a name="(part._exercise-imperative-ocaml)"></a>Imperative OCaml<span class="button-group"><a href="#(part._exercise-imperative-ocaml)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h3><details class="SubFlow accordion-section"><summary><span style="font-weight: bold">True or False</span></summary><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>Using mutable variables can cause side effects.</p><p><label class="quiz-option"><input type="radio" name="sp25-1-2" value="true" data-correct="true"/> True</label></p><p><label class="quiz-option"><input type="radio" name="sp25-1-2" value="false"/> False</label></p></blockquote></summary><p>Answer: True. Mutable variables allow state to be changed, which is a side effect. Modifying a mutable variable affects the program state beyond just returning a value.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>Functional Programming Languages favor mutable data.</p><p><label class="quiz-option"><input type="radio" name="sp24-1-2" value="true"/> True</label></p><p><label class="quiz-option"><input type="radio" name="sp24-1-2" value="false" data-correct="true"/> False</label></p></blockquote></summary><p>Answer: False. Functional programming languages favor immutable data. Immutability helps avoid side effects and makes programs easier to reason about.</p></details></details><details class="SubFlow accordion-section"><summary><span style="font-weight: bold">Multiple Choice: Typing and Evaluating</span></summary><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>Given the following OCaml definition using a shared mutable reference:</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> inc =</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> x = <span class="dt">ref</span> <span class="dv">0</span> <span class="kw">in</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">fun</span> y -&gt; x := !x + y; !x</span></code></pre></div>
</div></p><p>What does <span class="stt">map inc [1; 2; 3; 4]</span> evaluate to?</p><p><label class="quiz-option"><input type="radio" name="sp16-m1-21" value="1" data-correct="true"/> [1; 3; 6; 10]</label></p><p><label class="quiz-option"><input type="radio" name="sp16-m1-21" value="2"/> [1; 2; 3; 4]</label></p><p><label class="quiz-option"><input type="radio" name="sp16-m1-21" value="3"/> [1; 4; 9; 16]</label></p><p><label class="quiz-option"><input type="radio" name="sp16-m1-21" value="4"/> Type Error</label></p></blockquote></summary><p>Answer: [1; 3; 6; 10]. The reference x is shared across all calls (captured in the closure). inc 1: x=1; inc 2: x=3; inc 3: x=6; inc 4: x=10.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What does the following OCaml expression evaluate to? (x is a mutable reference.)</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = <span class="dt">ref</span> <span class="dv">5</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>fold (<span class="kw">fun</span> a h -&gt; x := (!x) + h; a + (!x)) <span class="dv">0</span> [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>];;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="sp16-f-16" value="1" data-correct="true"/> 25</label></p><p><label class="quiz-option"><input type="radio" name="sp16-f-16" value="2"/> 21</label></p><p><label class="quiz-option"><input type="radio" name="sp16-f-16" value="3"/> 6</label></p><p><label class="quiz-option"><input type="radio" name="sp16-f-16" value="4"/> 11</label></p></blockquote></summary><p>Answer: 25. Step h=1: x:=5+1=6; a=0+6=6. Step h=2: x:=6+2=8; a=6+8=14. Step h=3: x:=8+3=11; a=14+11=25.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>Which of the following best describes the imperative programming paradigm?</p><p><label class="quiz-option"><input type="radio" name="sp16-f-6" value="1"/> Programs are described in terms of the desired results of computation.</label></p><p><label class="quiz-option"><input type="radio" name="sp16-f-6" value="2" data-correct="true"/> Programs are described in terms of the control flows of computation.</label></p><p><label class="quiz-option"><input type="radio" name="sp16-f-6" value="3"/> Programs use expressions as opposed to statements.</label></p><p><label class="quiz-option"><input type="radio" name="sp16-f-6" value="4"/> Programs use statements as opposed to expressions.</label></p></blockquote></summary><p>Answer: B. Imperative programming describes computation as sequences of statements and control flow (loops, conditionals). Examples: C, Java, Python.</p></details></details></section></section><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="Software_Security.html" title="backward to &quot;13 Software Security&quot;" data-pltdoc="x" rel="prev">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;CMSC 330 Lecture Notes&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<span class="nonavigation">next &rarr;</span></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>