<!DOCTYPE html>
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>2&nbsp;Functional Programming with OCaml</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><link rel="stylesheet" type="text/css" href="extra.css" title="default"/><link rel="stylesheet" type="text/css" href="faq.css" title="default"/><link rel="stylesheet" type="text/css" href="fancyverb.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript">
(function() {
  document.write('<link rel="stylesheet" href="katex/katex.min.css" />');
})();(function() {document.write('<scr' + 'ipt type="text/javascript" src="katex/katex.min.js"></scr' + 'ipt>');})();(function(f) {
  // A "simple" onLoad function
  if (window.document.readyState == "complete") {
    f();
  } else if (window.document.addEventListener) {
    window.document.addEventListener("DOMContentLoaded", f, false);
  } else if (window.attachEvent) {
    window.attachEvent("onreadystatechange", function() {
      if (window.document.readyState == "complete") {
        f();
      }
    });
  } else {
    var oldLoad = window.onload;
    if (typeof(oldLoad) == "function") {
      window.onload = function() {
        try {
          oldLoad();
        } finally {
          f();
        }
      };
    } else {
      window.onload = f;
    }
  }
})(function() {
  // This is an ugly way to change the doctype, in case the scribble document
  // did not use (with-html5).
  if (!(document.doctype && document.doctype.publicId == '')) {
    if (console && console.log) {
      console.log("Re-wrote the document to use the HTML5 doctype.\n"
                  + "  Consider using the following declaration:\n"
                  + "      @title[#:style (with-html5 manual-doc-style)]{â€¦}");
    }
    var wholeDoc = '<!doctype HTML>\n' + document.documentElement.outerHTML;
    document.open();
    document.clear();
    document.write(wholeDoc);
  }
  var inlineElements = document.getElementsByClassName("texMathInline");
  for (var i = 0; i < inlineElements.length; i++) {
    var e = inlineElements[i];
    katex.render(e.textContent, e, { displayMode:false, throwOnError:false });
  }
  var displayElements = document.getElementsByClassName("texMathDisplay");
  for (var i = 0; i < displayElements.length; i++) {
    var e = displayElements[i];
    katex.render(e.textContent, e, { displayMode:true, throwOnError:false });
  }
});
</script><script type="text/javascript" src="quiz.js"></script><script type="text/javascript" src="manual-racket.js"></script></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">CMSC 330 Lecture Notes</a></td></tr></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="intro.html" class="tocviewlink" data-pltdoc="x">Introduction</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Functional Programming with OCaml</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="imperative-ocaml.html" class="tocviewlink" data-pltdoc="x">Imperative Programming with OCaml</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="pbt.html" class="tocviewlink" data-pltdoc="x">Property-<wbr></wbr>Based Randomized Testing (PBT)</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="regexp.html" class="tocviewlink" data-pltdoc="x">OCaml Regular Expressions</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="Finite_Automata.html" class="tocviewlink" data-pltdoc="x">Finite Automata</a></td></tr><tr><td align="right">7&nbsp;</td><td><a href="Context_Free_Grammars.html" class="tocviewlink" data-pltdoc="x">Context Free Grammars</a></td></tr><tr><td align="right">8&nbsp;</td><td><a href="Parsing.html" class="tocviewlink" data-pltdoc="x">Parsing</a></td></tr><tr><td align="right">9&nbsp;</td><td><a href="Operational_Semantics.html" class="tocviewlink" data-pltdoc="x">Operational Semantics</a></td></tr><tr><td align="right">10&nbsp;</td><td><a href="Type_Checking.html" class="tocviewlink" data-pltdoc="x">Type Checking</a></td></tr><tr><td align="right">11&nbsp;</td><td><a href="Lambda_Calculus.html" class="tocviewlink" data-pltdoc="x">Lambda Calculus</a></td></tr><tr><td align="right">12&nbsp;</td><td><a href="Rust.html" class="tocviewlink" data-pltdoc="x">Rust</a></td></tr><tr><td align="right">13&nbsp;</td><td><a href="Software_Security.html" class="tocviewlink" data-pltdoc="x">Software Security</a></td></tr><tr><td align="right">14&nbsp;</td><td><a href="exercises.html" class="tocviewlink" data-pltdoc="x">Exercises</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td>2&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Functional Programming with OCaml</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">2.1&nbsp;</td><td><a href="#%28part._.Books%29" class="tocviewlink" data-pltdoc="x">Books</a></td></tr><tr><td align="right">2.2&nbsp;</td><td><a href="#%28part._.Installing_.O.Caml%29" class="tocviewlink" data-pltdoc="x">Installing OCaml</a></td></tr><tr><td align="right">2.3&nbsp;</td><td><a href="#%28part.__.O.P.A.M__.O.Caml_.Package_.Manager%29" class="tocviewlink" data-pltdoc="x"> OPAM:<span class="mywbr"> &nbsp;</span> OCaml Package Manager</a></td></tr><tr><td align="right">2.4&nbsp;</td><td><a href="#%28part._.Running_.O.Caml_.Programs%29" class="tocviewlink" data-pltdoc="x">Running OCaml Programs</a></td></tr><tr><td align="right">2.5&nbsp;</td><td><a href="#%28part._.Building_.Projects_with_dune%29" class="tocviewlink" data-pltdoc="x">Building Projects with dune</a></td></tr><tr><td align="right">2.6&nbsp;</td><td><a href="#%28part.__.O.Caml_.Basics%29" class="tocviewlink" data-pltdoc="x"> OCaml Basics</a></td></tr><tr><td align="right">2.7&nbsp;</td><td><a href="#%28part._.O.Caml_toplevel__a_.R.E.P.L_for_.O.Caml%29" class="tocviewlink" data-pltdoc="x">OCaml toplevel, a REPL for OCaml</a></td></tr><tr><td align="right">2.8&nbsp;</td><td><a href="#%28part._.First_.O.Caml_.Example%29" class="tocviewlink" data-pltdoc="x">First OCaml Example</a></td></tr><tr><td align="right">2.9&nbsp;</td><td><a href="#%28part._.Expressions%29" class="tocviewlink" data-pltdoc="x">Expressions</a></td></tr><tr><td align="right">2.10&nbsp;</td><td><a href="#%28part._.Values%29" class="tocviewlink" data-pltdoc="x">Values</a></td></tr><tr><td align="right">2.11&nbsp;</td><td><a href="#%28part._.Types%29" class="tocviewlink" data-pltdoc="x">Types</a></td></tr><tr><td align="right">2.12&nbsp;</td><td><a href="#%28part._.If_expression%29" class="tocviewlink" data-pltdoc="x">If expression</a></td></tr><tr><td align="right">2.13&nbsp;</td><td><a href="#%28part._.Functions%29" class="tocviewlink" data-pltdoc="x">Functions</a></td></tr><tr><td align="right">2.14&nbsp;</td><td><a href="#%28part._.Type_.Checking_of_.Function_.Application%29" class="tocviewlink" data-pltdoc="x">Type Checking of Function Application</a></td></tr><tr><td align="right">2.15&nbsp;</td><td><a href="#%28part._.Lists%29" class="tocviewlink" data-pltdoc="x">Lists</a></td></tr><tr><td align="right">2.16&nbsp;</td><td><a href="#%28part._.Pattern_.Matching%29" class="tocviewlink" data-pltdoc="x">Pattern Matching</a></td></tr><tr><td align="right">2.17&nbsp;</td><td><a href="#%28part._.Lists_and_.Recursion%29" class="tocviewlink" data-pltdoc="x">Lists and Recursion</a></td></tr><tr><td align="right">2.18&nbsp;</td><td><a href="#%28part._.Let_.Expressions%29" class="tocviewlink" data-pltdoc="x">Let Expressions</a></td></tr><tr><td align="right">2.19&nbsp;</td><td><a href="#%28part._.Tuples%29" class="tocviewlink" data-pltdoc="x">Tuples</a></td></tr><tr><td align="right">2.20&nbsp;</td><td><a href="#%28part._.Records%29" class="tocviewlink" data-pltdoc="x">Records</a></td></tr><tr><td align="right">2.21&nbsp;</td><td><a href="#%28part._.Anonymous_.Functions%29" class="tocviewlink" data-pltdoc="x">Anonymous Functions</a></td></tr><tr><td align="right">2.22&nbsp;</td><td><a href="#%28part._.Higher_.Order_.Functions%29" class="tocviewlink" data-pltdoc="x">Higher Order Functions</a></td></tr><tr><td align="right">2.23&nbsp;</td><td><a href="#%28part._.Tail_.Recursion%29" class="tocviewlink" data-pltdoc="x">Tail Recursion</a></td></tr><tr><td align="right">2.24&nbsp;</td><td><a href="#%28part._.O.Caml_.Data_.Types__.Variants_%29" class="tocviewlink" data-pltdoc="x">OCaml Data Types (Variants)</a></td></tr><tr><td align="right">2.25&nbsp;</td><td><a href="#%28part._.User_.Defined_.Types%29" class="tocviewlink" data-pltdoc="x">User Defined Types</a></td></tr><tr><td align="right">2.26&nbsp;</td><td><a href="#%28part._.Exceptions%29" class="tocviewlink" data-pltdoc="x">Exceptions</a></td></tr><tr><td align="right">2.27&nbsp;</td><td><a href="#%28part._.Closures%29" class="tocviewlink" data-pltdoc="x">Closures</a></td></tr><tr><td align="right">2.28&nbsp;</td><td><a href="#%28part._.O.Caml_.Quick_.Reference%29" class="tocviewlink" data-pltdoc="x">OCaml Quick Reference</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">2.1<span class="stt">&nbsp;</span></span><a href="#%28part._.Books%29" class="tocsubseclink" data-pltdoc="x">Books</a></td></tr><tr><td><span class="tocsublinknumber">2.1.1<span class="stt">&nbsp;</span></span><a href="#%28part._.Similar_.Courses%29" class="tocsubseclink" data-pltdoc="x">Similar Courses</a></td></tr><tr><td><span class="tocsublinknumber">2.2<span class="stt">&nbsp;</span></span><a href="#%28part._.Installing_.O.Caml%29" class="tocsubseclink" data-pltdoc="x">Installing OCaml</a></td></tr><tr><td><span class="tocsublinknumber">2.3<span class="stt">&nbsp;</span></span><a href="#%28part.__.O.P.A.M__.O.Caml_.Package_.Manager%29" class="tocsubseclink" data-pltdoc="x"> OPAM:<span class="mywbr"> &nbsp;</span> OCaml Package Manager</a></td></tr><tr><td><span class="tocsublinknumber">2.4<span class="stt">&nbsp;</span></span><a href="#%28part._.Running_.O.Caml_.Programs%29" class="tocsubseclink" data-pltdoc="x">Running OCaml Programs</a></td></tr><tr><td><span class="tocsublinknumber">2.5<span class="stt">&nbsp;</span></span><a href="#%28part._.Building_.Projects_with_dune%29" class="tocsubseclink" data-pltdoc="x">Building Projects with dune</a></td></tr><tr><td><span class="tocsublinknumber">2.6<span class="stt">&nbsp;</span></span><a href="#%28part.__.O.Caml_.Basics%29" class="tocsubseclink" data-pltdoc="x"> OCaml Basics</a></td></tr><tr><td><span class="tocsublinknumber">2.7<span class="stt">&nbsp;</span></span><a href="#%28part._.O.Caml_toplevel__a_.R.E.P.L_for_.O.Caml%29" class="tocsubseclink" data-pltdoc="x">OCaml toplevel, a REPL for OCaml</a></td></tr><tr><td><span class="tocsublinknumber">2.8<span class="stt">&nbsp;</span></span><a href="#%28part._.First_.O.Caml_.Example%29" class="tocsubseclink" data-pltdoc="x">First OCaml Example</a></td></tr><tr><td><span class="tocsublinknumber">2.9<span class="stt">&nbsp;</span></span><a href="#%28part._.Expressions%29" class="tocsubseclink" data-pltdoc="x">Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.10<span class="stt">&nbsp;</span></span><a href="#%28part._.Values%29" class="tocsubseclink" data-pltdoc="x">Values</a></td></tr><tr><td><span class="tocsublinknumber">2.11<span class="stt">&nbsp;</span></span><a href="#%28part._.Types%29" class="tocsubseclink" data-pltdoc="x">Types</a></td></tr><tr><td><span class="tocsublinknumber">2.12<span class="stt">&nbsp;</span></span><a href="#%28part._.If_expression%29" class="tocsubseclink" data-pltdoc="x">If expression</a></td></tr><tr><td><span class="tocsublinknumber">2.13<span class="stt">&nbsp;</span></span><a href="#%28part._.Functions%29" class="tocsubseclink" data-pltdoc="x">Functions</a></td></tr><tr><td><span class="tocsublinknumber">2.13.1<span class="stt">&nbsp;</span></span><a href="#%28part._.Calling_.Functions__.Function_.Application_%29" class="tocsubseclink" data-pltdoc="x">Calling Functions (Function Application)</a></td></tr><tr><td><span class="tocsublinknumber">2.13.2<span class="stt">&nbsp;</span></span><a href="#%28part._.Function_.Types%29" class="tocsubseclink" data-pltdoc="x">Function Types</a></td></tr><tr><td><span class="tocsublinknumber">2.14<span class="stt">&nbsp;</span></span><a href="#%28part._.Type_.Checking_of_.Function_.Application%29" class="tocsubseclink" data-pltdoc="x">Type Checking of Function Application</a></td></tr><tr><td><span class="tocsublinknumber">2.14.1<span class="stt">&nbsp;</span></span><a href="#%28part._.More_.Examples_on_.Function_.Type_.Checking%29" class="tocsubseclink" data-pltdoc="x">More Examples on Function Type Checking</a></td></tr><tr><td><span class="tocsublinknumber">2.14.2<span class="stt">&nbsp;</span></span><a href="#%28part._.Mutually_.Recursive_.Functions%29" class="tocsubseclink" data-pltdoc="x">Mutually Recursive Functions</a></td></tr><tr><td><span class="tocsublinknumber">2.14.3<span class="stt">&nbsp;</span></span><a href="#%28part._.Polymorphic_.Types%29" class="tocsubseclink" data-pltdoc="x">Polymorphic Types</a></td></tr><tr><td><span class="tocsublinknumber">2.14.4<span class="stt">&nbsp;</span></span><a href="#%28part._.Type_annotations%29" class="tocsubseclink" data-pltdoc="x">Type annotations</a></td></tr><tr><td><span class="tocsublinknumber">2.15<span class="stt">&nbsp;</span></span><a href="#%28part._.Lists%29" class="tocsubseclink" data-pltdoc="x">Lists</a></td></tr><tr><td><span class="tocsublinknumber">2.15.1<span class="stt">&nbsp;</span></span><a href="#%28part._.Typing_.Lists%29" class="tocsubseclink" data-pltdoc="x">Typing Lists</a></td></tr><tr><td><span class="tocsublinknumber">2.15.2<span class="stt">&nbsp;</span></span><a href="#%28part.____.Operator%29" class="tocsubseclink" data-pltdoc="x">:<span class="mywbr"> &nbsp;</span>:<span class="mywbr"> &nbsp;</span> Operator</a></td></tr><tr><td><span class="tocsublinknumber">2.15.3<span class="stt">&nbsp;</span></span><a href="#%28part._.Lists_of_.Lists%29" class="tocsubseclink" data-pltdoc="x">Lists of Lists</a></td></tr><tr><td><span class="tocsublinknumber">2.16<span class="stt">&nbsp;</span></span><a href="#%28part._.Pattern_.Matching%29" class="tocsubseclink" data-pltdoc="x">Pattern Matching</a></td></tr><tr><td><span class="tocsublinknumber">2.16.1<span class="stt">&nbsp;</span></span><a href="#%28part._.Pattern_.Matching_.Lists%29" class="tocsubseclink" data-pltdoc="x">Pattern Matching Lists</a></td></tr><tr><td><span class="tocsublinknumber">2.16.2<span class="stt">&nbsp;</span></span><a href="#%28part._.Pattern_.Matching_~e2~80~93_.An_.Abbreviation%29" class="tocsubseclink" data-pltdoc="x">Pattern Matching &#8211; An Abbreviation</a></td></tr><tr><td><span class="tocsublinknumber">2.17<span class="stt">&nbsp;</span></span><a href="#%28part._.Lists_and_.Recursion%29" class="tocsubseclink" data-pltdoc="x">Lists and Recursion</a></td></tr><tr><td><span class="tocsublinknumber">2.18<span class="stt">&nbsp;</span></span><a href="#%28part._.Let_.Expressions%29" class="tocsubseclink" data-pltdoc="x">Let Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.18.1<span class="stt">&nbsp;</span></span><a href="#%28part._.Let_.Definitions_vs__.Let_.Expressions_%29" class="tocsubseclink" data-pltdoc="x">Let Definitions vs. Let Expressions </a></td></tr><tr><td><span class="tocsublinknumber">2.18.2<span class="stt">&nbsp;</span></span><a href="#%28part._.Let_.Expressions__.Scope%29" class="tocsubseclink" data-pltdoc="x">Let Expressions:<span class="mywbr"> &nbsp;</span> Scope</a></td></tr><tr><td><span class="tocsublinknumber">2.18.3<span class="stt">&nbsp;</span></span><a href="#%28part._.Nested_.Let_.Expressions%29" class="tocsubseclink" data-pltdoc="x">Nested Let Expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.18.4<span class="stt">&nbsp;</span></span><a href="#%28part._.Let_.Expressions_in_.Functions%29" class="tocsubseclink" data-pltdoc="x">Let Expressions in Functions</a></td></tr><tr><td><span class="tocsublinknumber">2.18.5<span class="stt">&nbsp;</span></span><a href="#%28part._.Shadowing_.Names%29" class="tocsubseclink" data-pltdoc="x">Shadowing Names</a></td></tr><tr><td><span class="tocsublinknumber">2.19<span class="stt">&nbsp;</span></span><a href="#%28part._.Tuples%29" class="tocsubseclink" data-pltdoc="x">Tuples</a></td></tr><tr><td><span class="tocsublinknumber">2.19.1<span class="stt">&nbsp;</span></span><a href="#%28part._.Pattern_.Matching_.Tuples%29" class="tocsubseclink" data-pltdoc="x">Pattern Matching Tuples</a></td></tr><tr><td><span class="tocsublinknumber">2.20<span class="stt">&nbsp;</span></span><a href="#%28part._.Records%29" class="tocsubseclink" data-pltdoc="x">Records</a></td></tr><tr><td><span class="tocsublinknumber">2.21<span class="stt">&nbsp;</span></span><a href="#%28part._.Anonymous_.Functions%29" class="tocsubseclink" data-pltdoc="x">Anonymous Functions</a></td></tr><tr><td><span class="tocsublinknumber">2.21.1<span class="stt">&nbsp;</span></span><a href="#%28part._.Binding_.Functions%29" class="tocsubseclink" data-pltdoc="x">Binding Functions</a></td></tr><tr><td><span class="tocsublinknumber">2.22<span class="stt">&nbsp;</span></span><a href="#%28part._.Higher_.Order_.Functions%29" class="tocsubseclink" data-pltdoc="x">Higher Order Functions</a></td></tr><tr><td><span class="tocsublinknumber">2.22.1<span class="stt">&nbsp;</span></span><a href="#%28part._.Map%29" class="tocsubseclink" data-pltdoc="x">Map</a></td></tr><tr><td><span class="tocsublinknumber">2.22.1.1<span class="stt">&nbsp;</span></span><a href="#%28part._.Implementing_map%29" class="tocsubseclink" data-pltdoc="x">Implementing map</a></td></tr><tr><td><span class="tocsublinknumber">2.22.2<span class="stt">&nbsp;</span></span><a href="#%28part._.Fold%29" class="tocsubseclink" data-pltdoc="x">Fold</a></td></tr><tr><td><span class="tocsublinknumber">2.22.3<span class="stt">&nbsp;</span></span><a href="#%28part._.Filter%29" class="tocsubseclink" data-pltdoc="x">Filter</a></td></tr><tr><td><span class="tocsublinknumber">2.23<span class="stt">&nbsp;</span></span><a href="#%28part._.Tail_.Recursion%29" class="tocsubseclink" data-pltdoc="x">Tail Recursion</a></td></tr><tr><td><span class="tocsublinknumber">2.23.1<span class="stt">&nbsp;</span></span><a href="#%28part._fold_left_vs_fold_right%29" class="tocsubseclink" data-pltdoc="x">fold_<span class="mywbr"> &nbsp;</span>left vs fold_<span class="mywbr"> &nbsp;</span>right</a></td></tr><tr><td><span class="tocsublinknumber">2.23.2<span class="stt">&nbsp;</span></span><a href="#%28part._.Tail_.Recursion_.Pattern%29" class="tocsubseclink" data-pltdoc="x">Tail Recursion Pattern</a></td></tr><tr><td><span class="tocsublinknumber">2.23.3<span class="stt">&nbsp;</span></span><a href="#%28part._.Optional_.Reading__.Continuation-.Passing_.Style__.C.P.S_%29" class="tocsubseclink" data-pltdoc="x">Optional Reading:<span class="mywbr"> &nbsp;</span> Continuation-<wbr></wbr>Passing Style (CPS)</a></td></tr><tr><td><span class="tocsublinknumber">2.24<span class="stt">&nbsp;</span></span><a href="#%28part._.O.Caml_.Data_.Types__.Variants_%29" class="tocsubseclink" data-pltdoc="x">OCaml Data Types (Variants)</a></td></tr><tr><td><span class="tocsublinknumber">2.25<span class="stt">&nbsp;</span></span><a href="#%28part._.User_.Defined_.Types%29" class="tocsubseclink" data-pltdoc="x">User Defined Types</a></td></tr><tr><td><span class="tocsublinknumber">2.25.1<span class="stt">&nbsp;</span></span><a href="#%28part._.Option_.Type%29" class="tocsubseclink" data-pltdoc="x">Option Type</a></td></tr><tr><td><span class="tocsublinknumber">2.25.2<span class="stt">&nbsp;</span></span><a href="#%28part._.Recursive_.Data_.Types%29" class="tocsubseclink" data-pltdoc="x">Recursive Data Types</a></td></tr><tr><td><span class="tocsublinknumber">2.25.3<span class="stt">&nbsp;</span></span><a href="#%28part._.Polymorphic_.List%29" class="tocsubseclink" data-pltdoc="x">Polymorphic List</a></td></tr><tr><td><span class="tocsublinknumber">2.25.4<span class="stt">&nbsp;</span></span><a href="#%28part._.Binary_.Trees%29" class="tocsubseclink" data-pltdoc="x">Binary Trees</a></td></tr><tr><td><span class="tocsublinknumber">2.25.5<span class="stt">&nbsp;</span></span><a href="#%28part._.N-ary_.Trees%29" class="tocsubseclink" data-pltdoc="x">N-<wbr></wbr>ary Trees</a></td></tr><tr><td><span class="tocsublinknumber">2.26<span class="stt">&nbsp;</span></span><a href="#%28part._.Exceptions%29" class="tocsubseclink" data-pltdoc="x">Exceptions</a></td></tr><tr><td><span class="tocsublinknumber">2.27<span class="stt">&nbsp;</span></span><a href="#%28part._.Closures%29" class="tocsubseclink" data-pltdoc="x">Closures</a></td></tr><tr><td><span class="tocsublinknumber">2.27.1<span class="stt">&nbsp;</span></span><a href="#%28part._.Multi-argument_.Functions%29" class="tocsubseclink" data-pltdoc="x">Multi-<wbr></wbr>argument Functions</a></td></tr><tr><td><span class="tocsublinknumber">2.27.2<span class="stt">&nbsp;</span></span><a href="#%28part._.Currying%29" class="tocsubseclink" data-pltdoc="x">Currying</a></td></tr><tr><td><span class="tocsublinknumber">2.27.3<span class="stt">&nbsp;</span></span><a href="#%28part._.How_.Do_.We_.Implement_.Currying_%29" class="tocsubseclink" data-pltdoc="x">How Do We Implement Currying?</a></td></tr><tr><td><span class="tocsublinknumber">2.27.4<span class="stt">&nbsp;</span></span><a href="#%28part._.Environment%29" class="tocsubseclink" data-pltdoc="x">Environment</a></td></tr><tr><td><span class="tocsublinknumber">2.27.5<span class="stt">&nbsp;</span></span><a href="#%28part._.Scope%29" class="tocsubseclink" data-pltdoc="x">Scope</a></td></tr><tr><td><span class="tocsublinknumber">2.27.6<span class="stt">&nbsp;</span></span><a href="#%28part._.Higher-.Order_.Functions_in_.C%29" class="tocsubseclink" data-pltdoc="x">Higher-<wbr></wbr>Order Functions in C</a></td></tr><tr><td><span class="tocsublinknumber">2.28<span class="stt">&nbsp;</span></span><a href="#%28part._.O.Caml_.Quick_.Reference%29" class="tocsubseclink" data-pltdoc="x">OCaml Quick Reference</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">9.0</span></div><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="intro.html" title="backward to &quot;1 Introduction&quot;" data-pltdoc="x" rel="prev">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;CMSC 330 Lecture Notes&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="imperative-ocaml.html" title="forward to &quot;3 Imperative Programming with OCaml&quot;" data-pltdoc="x" rel="next">next &rarr;</a></span>&nbsp;</div><section class="SsectionLevel2" id="section 2"><h2 class="heading">2<span class="stt">&nbsp;</span><a name="(part._ocaml)"></a>Functional Programming with OCaml<span class="button-group"><a href="#(part._ocaml)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h2><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Books%29" class="toclink" data-pltdoc="x">2.1<span class="hspace">&nbsp;</span>Books</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Installing_.O.Caml%29" class="toclink" data-pltdoc="x">2.2<span class="hspace">&nbsp;</span>Installing OCaml</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part.__.O.P.A.M__.O.Caml_.Package_.Manager%29" class="toclink" data-pltdoc="x">2.3<span class="hspace">&nbsp;</span> OPAM: OCaml Package Manager</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Running_.O.Caml_.Programs%29" class="toclink" data-pltdoc="x">2.4<span class="hspace">&nbsp;</span>Running OCaml Programs</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Building_.Projects_with_dune%29" class="toclink" data-pltdoc="x">2.5<span class="hspace">&nbsp;</span>Building Projects with dune</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part.__.O.Caml_.Basics%29" class="toclink" data-pltdoc="x">2.6<span class="hspace">&nbsp;</span> OCaml Basics</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.O.Caml_toplevel__a_.R.E.P.L_for_.O.Caml%29" class="toclink" data-pltdoc="x">2.7<span class="hspace">&nbsp;</span>OCaml toplevel, a REPL for OCaml</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.First_.O.Caml_.Example%29" class="toclink" data-pltdoc="x">2.8<span class="hspace">&nbsp;</span>First OCaml Example</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Expressions%29" class="toclink" data-pltdoc="x">2.9<span class="hspace">&nbsp;</span>Expressions</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Values%29" class="toclink" data-pltdoc="x">2.10<span class="hspace">&nbsp;</span>Values</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Types%29" class="toclink" data-pltdoc="x">2.11<span class="hspace">&nbsp;</span>Types</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.If_expression%29" class="toclink" data-pltdoc="x">2.12<span class="hspace">&nbsp;</span>If expression</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Functions%29" class="toclink" data-pltdoc="x">2.13<span class="hspace">&nbsp;</span>Functions</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Type_.Checking_of_.Function_.Application%29" class="toclink" data-pltdoc="x">2.14<span class="hspace">&nbsp;</span>Type Checking of Function Application</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Lists%29" class="toclink" data-pltdoc="x">2.15<span class="hspace">&nbsp;</span>Lists</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Pattern_.Matching%29" class="toclink" data-pltdoc="x">2.16<span class="hspace">&nbsp;</span>Pattern Matching</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Lists_and_.Recursion%29" class="toclink" data-pltdoc="x">2.17<span class="hspace">&nbsp;</span>Lists and Recursion</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Let_.Expressions%29" class="toclink" data-pltdoc="x">2.18<span class="hspace">&nbsp;</span>Let Expressions</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Tuples%29" class="toclink" data-pltdoc="x">2.19<span class="hspace">&nbsp;</span>Tuples</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Records%29" class="toclink" data-pltdoc="x">2.20<span class="hspace">&nbsp;</span>Records</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Anonymous_.Functions%29" class="toclink" data-pltdoc="x">2.21<span class="hspace">&nbsp;</span>Anonymous Functions</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Higher_.Order_.Functions%29" class="toclink" data-pltdoc="x">2.22<span class="hspace">&nbsp;</span>Higher Order Functions</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Tail_.Recursion%29" class="toclink" data-pltdoc="x">2.23<span class="hspace">&nbsp;</span>Tail Recursion</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.O.Caml_.Data_.Types__.Variants_%29" class="toclink" data-pltdoc="x">2.24<span class="hspace">&nbsp;</span>OCaml Data Types (Variants)</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.User_.Defined_.Types%29" class="toclink" data-pltdoc="x">2.25<span class="hspace">&nbsp;</span>User Defined Types</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Exceptions%29" class="toclink" data-pltdoc="x">2.26<span class="hspace">&nbsp;</span>Exceptions</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Closures%29" class="toclink" data-pltdoc="x">2.27<span class="hspace">&nbsp;</span>Closures</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.O.Caml_.Quick_.Reference%29" class="toclink" data-pltdoc="x">2.28<span class="hspace">&nbsp;</span>OCaml Quick Reference</a></p></td></tr></table><p><div class="SIntrapara">OCaml is a dialect of the ML programming language family, originally developed at INRIA in France.
The features of ML include:
</div><div class="SIntrapara"><ul><li><p>First-class functions: Functions are treated as values. They can be passed as arguments to
other functions and returned as results.</p></li><li><p>Immutability by default: Variables are typically assigned once, encouraging a functional style of programming.</p></li><li><p>Algebraic data types and pattern matching: These provide expressive and concise ways to define and manipulate
structured data.</p></li><li><p><div class="SIntrapara">Type inference
</div><div class="SIntrapara"><ul><li><p>OCaml is statically typed, but there is no need to write type annotations explicitly.</p></li><li><p>The language supports parametric polymorphism,
similar to Generics in Java, templates in C++</p></li></ul></div></p></li><li><p>Exceptions</p></li><li><p>Automatic garbage collection</p></li></ul></div><div class="SIntrapara">Many ideas from functional programming have since influenced modern programming languages,
including first-class and anonymous functions, as well as automatic memory management
through garbage collection.</div></p><section class="SsectionLevel3" id="section 2.1"><h3 class="heading">2.1<span class="stt">&nbsp;</span><a name="(part._.Books)"></a>Books<span class="button-group"><a href="#(part._.Books)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h3><p><div class="SIntrapara">Below is a list of free online books available on OCaml.
</div><div class="SIntrapara"><ul><li><p>Developing Applications with Objective Caml <a href="https://caml.inria.fr/pub/docs/oreilly-book/ocaml-ora-book.pdf">https://caml.inria.fr/pub/docs/oreilly-book/ocaml-ora-book.pdf</a></p></li><li><p>Introduction to the Objective Caml Programming Language <a href="http://courses.cms.caltech.edu/cs134/cs134b/book.pdf">http://courses.cms.caltech.edu/cs134/cs134b/book.pdf</a></p></li><li><p>Real World OCaml 2nd Edition <a href="https://dev.realworldocaml.org/">https://dev.realworldocaml.org/</a></p></li><li><p>OCaml from the Very Beginning <a href="https://johnwhitington.net/ocamlfromtheverybeginning/mlbook.pdf">https://johnwhitington.net/ocamlfromtheverybeginning/mlbook.pdf</a></p></li><li><p>Cornell cs3110 book <a href="https://cs3110.github.io/textbook/cover.html">https://cs3110.github.io/textbook/cover.html</a> is another course which uses OCaml; it is more focused on programming and less on PL theory than this class is.</p></li><li><p><a href="https://ocaml.org">ocaml.org</a> is the home of OCaml for finding downloads, documentation, etc. The tutorials are also very good and there is a page of books.</p></li><li><p><a href="https://ocaml.org/exercises">OCaml exercises</a></p></li></ul></div></p><section class="SsectionLevel4" id="section 2.1.1"><h4 class="heading">2.1.1<span class="stt">&nbsp;</span><a name="(part._.Similar_.Courses)"></a>Similar Courses<span class="button-group"><a href="#(part._.Similar_.Courses)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>If you&rsquo;re interested, I&#8217;ve listed several similar courses from other universities. For example, Cornell offers a comparable course&#8212;CS 3110&#8212;and there are also similar offerings from the University of Washington, Princeton, Harvard, and UIUC. You can check out their websites; Cornell&#8217;s, in particular, provides an online textbook along with videos and other helpful resources.</p><p>You might find it helpful to watch their lectures, go through their examples, or even try out their projects or exams. They all use OCaml, and the course structure is quite similar.</p><p>So, it&#8217;s more than just a textbook&#8212;you have access to notes, slides, exams, and other useful materials.</p><ul><li><p><a href="https://www.cs.cornell.edu/courses/cs3110/2025sp/">CS3110</a> (Cornell)</p></li><li><p><a href="https://courses.cs.washington.edu/courses/cse341/">CSE341</a> (Washington)</p></li><li><p><a href="https://pl.cs.jhu.edu/pl/">601.426</a> (Johns Hopkins)</p></li><li><p><a href="https://www.cs.princeton.edu/courses/archive/fall23/cos326/">COS326</a> (Princeton)</p></li><li><p><a href="https://groups.seas.harvard.edu/courses/cs152/">CS152</a> (Harvard)</p></li><li><p><a href="https://courses.engr.illinois.edu/cs421/">CS421</a> (UIUC)</p></li></ul></section></section><section class="SsectionLevel3" id="section 2.2"><h3 class="heading">2.2<span class="stt">&nbsp;</span><a name="(part._.Installing_.O.Caml)"></a>Installing OCaml<span class="button-group"><a href="#(part._.Installing_.O.Caml)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h3><p><div class="SIntrapara">Install the latest version of OCaml from https://ocaml.org/
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">shell</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode fish"><code class="sourceCode fish"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="er">&gt;</span> ocaml --version</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">The</span> OCaml toplevel, version 5.4.1</span></code></pre></div>
</div></p></blockquote></blockquote></div></p></section><section class="SsectionLevel3" id="section 2.3"><h3 class="heading">2.3<span class="stt">&nbsp;</span><a name="(part.__.O.P.A.M__.O.Caml_.Package_.Manager)"></a> OPAM: OCaml Package Manager<span class="button-group"><a href="#(part.__.O.P.A.M__.O.Caml_.Package_.Manager)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h3><p><div class="SIntrapara">Opam is the package manager for OCaml. It manages libraries and different compiler installations. For the class projects, you should install the following packages with <span style="font-weight: bold">opam</span>.
</div><div class="SIntrapara"><ul><li><p>ounit, a testing framework similar to minitest</p></li><li><p>utop, a top-level interface</p></li><li><p>dune, a build system for larger projects</p></li></ul></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">shell</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode fish"><code class="sourceCode fish"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="er">&gt;</span> dune --version</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>3<span class="fu">.21.1</span></span></code></pre></div>
</div></p></blockquote></blockquote></div></p></section><section class="SsectionLevel3" id="section 2.4"><h3 class="heading">2.4<span class="stt">&nbsp;</span><a name="(part._.Running_.O.Caml_.Programs)"></a>Running OCaml Programs<span class="button-group"><a href="#(part._.Running_.O.Caml_.Programs)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>You can compile OCaml programs with either the bytecode compiler (<span style="font-weight: bold">ocamlc</span>) or the native-code compiler (<span class="stt">ocamlopt</span>).
The -o option specifies the output file name.
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>ocamlc -o main main.ml</span></code></pre></div>
</div>
creates an executable named main.</p><p><span style="font-weight: bold">ocamlc -c</span> compiles the source file without linking and produces <span style="font-weight: bold">.cmo</span> (compiled object) and <span style="font-weight: bold">.cmi</span> (compiled interface)
files. <span style="font-weight: bold">ocamlopt</span> produces <span style="font-weight: bold">.cmx</span> files, which contain native code: faster, but not platform-independent (or as easily debugged)
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>ocamlopt -o main main.ml</span></code></pre></div>
</div></p><p>You can also run an OCaml program directly using the OCaml interpreter (<span style="font-weight: bold">ocaml</span>). This is similar to running a Python program.
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>ocaml main.ml</span></code></pre></div>
</div>
This will run the OCaml program <span style="font-weight: bold">main.ml</span>.</p></section><section class="SsectionLevel3" id="section 2.5"><h3 class="heading">2.5<span class="stt">&nbsp;</span><a name="(part._.Building_.Projects_with_dune)"></a>Building Projects with dune<span class="button-group"><a href="#(part._.Building_.Projects_with_dune)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h3><p><span style="font-weight: bold">ocamlc</span> is convenient for compiling a single OCaml file.
However, for class projects you will use <span style="font-weight: bold">dune</span>, the build system.
Dune automatically discovers dependencies and invokes the compiler and
linker for you. Let us create a new project using <span style="font-weight: bold">dune</span>:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">shell</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode fish"><code class="sourceCode fish"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="er">&gt;</span> dune init project HelloWorld</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">Success:</span> initialized project component named HelloWorld</span></code></pre></div>
</div></p></blockquote></blockquote><p><div class="SIntrapara">It creates a <span style="font-weight: bold">HelloWorld</span> project with the following files:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">shell</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode fish"><code class="sourceCode fish"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="er">&gt;</span> tree HelloWorld</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">HelloWorld</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>â”œâ”€â”€ <span class="fu">HelloWorld.opam</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>â”œâ”€â”€ <span class="fu">_build</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>â”‚Â Â  â””â”€â”€ <span class="fu">log</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>â”œâ”€â”€ <span class="fu">bin</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>â”‚Â Â  â”œâ”€â”€ <span class="fu">dune</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>â”‚Â Â  â””â”€â”€ <span class="fu">main.ml</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>â”œâ”€â”€ <span class="fu">dune-project</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>â”œâ”€â”€ <span class="fu">lib</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>â”‚Â Â  â””â”€â”€ <span class="fu">dune</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>â””â”€â”€ <span class="bu">test</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    â”œâ”€â”€ <span class="fu">dune</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    â””â”€â”€ <span class="fu">test_HelloWorld.ml</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>5 <span class="fu">directories,</span> 8 files</span></code></pre></div>
</div></p></blockquote></blockquote></div></p><p>Build the project:
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>cd HelloWorld </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>dune build</span></code></pre></div>
</div></p><p>Run it:
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>dune exec bin/main.exe</span></code></pre></div>
</div>
or
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>_build/default/bin/main.exe</span></code></pre></div>
</div>
Run the tests
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>dune runtest</span></code></pre></div>
</div></p></section><section class="SsectionLevel3" id="section 2.6"><h3 class="heading">2.6<span class="stt">&nbsp;</span><a name="(part.__.O.Caml_.Basics)"></a> OCaml Basics<span class="button-group"><a href="#(part.__.O.Caml_.Basics)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h3><p><div class="SIntrapara">OCaml files are written with a <span style="font-weight: bold">.ml</span> extension. There is no special main function. An OCaml file consists of
</div><div class="SIntrapara"><ul><li><p>A series of open statements for including other modules</p></li><li><p>A series of declarations for defining datatypes, functions, and constants</p></li><li><p>A series of (though often just one) toplevel expressions to evaluate.</p></li></ul></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* A small OCaml program *)</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="dt">print_string</span> <span class="st">&quot;Hello world!</span><span class="ch">\n</span><span class="st">&quot;</span>;;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>Hello world!</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">unit</span> = ()</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">Or
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">open</span> <span class="dt">Printf</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> message = <span class="st">&quot;Hello world&quot;</span>;; </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> (printf <span class="st">&quot;%s</span><span class="ch">\n</span><span class="st">&quot;</span> message);;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> message : <span class="dt">string</span> = <span class="st">&quot;Hello world&quot;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>Hello world</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">unit</span> = ()</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">The first line includes the built-in library for printing,
which provides functions similar to <span style="font-weight: bold">fprintf</span> and <span style="font-weight: bold">printf</span>
 from <span style="font-weight: bold">stdlib</span> in <span style="font-weight: bold">C</span>. The next two lines define a
 constant named message, and then call the <span style="font-weight: bold">printf</span> function with a format string (where &lsquo;%s&lsquo; means "format as string"), and the constant message we defined on the line before.</div></p><p><div class="SIntrapara">To compile and run
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">shell</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode fish"><code class="sourceCode fish"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="er">&gt;</span> ocamlc hello.ml -o hello</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="er">&gt;</span> ./hello</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">Hello</span> world!</span></code></pre></div>
</div></p></blockquote></blockquote></div></p><p><div class="SIntrapara">We can also compile multiple files to generate a single executable.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><a href="code/main.ml"><span class="stt">main.ml</span></a></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* main.ml *)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> main () =</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">print_int</span> (Util.add <span class="dv">10</span> <span class="dv">20</span>); <span class="dt">print_string</span> <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> () = main ()</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><a href="code/util.ml"><span class="stt">util.ml</span></a></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* util.ml *)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> add x y = x + y</span></code></pre></div>
</div></p></blockquote></blockquote></div></p><p>Compile and run:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">shell</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode fish"><code class="sourceCode fish"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="er">&gt;</span> ocamlc util.ml main.ml -o main</span></code></pre></div>
</div></p></blockquote></blockquote><p>Or compile separately</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">shell</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode fish"><code class="sourceCode fish"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="er">&gt;</span> ocamlc -c util.ml</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="er">&gt;</span> ocamlc util.cmo main.ml</span></code></pre></div>
</div></p></blockquote></blockquote><p><div class="SIntrapara">It generates an executable <span style="font-weight: bold">main</span>. We can execute it by
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">shell</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode fish"><code class="sourceCode fish"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="er">&gt;</span> ./main</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>30</span></code></pre></div>
</div></p></blockquote></blockquote></div></p></section><section class="SsectionLevel3" id="section 2.7"><h3 class="heading">2.7<span class="stt">&nbsp;</span><a name="(part._.O.Caml_toplevel__a_.R.E.P.L_for_.O.Caml)"></a>OCaml toplevel, a REPL for OCaml<span class="button-group"><a href="#(part._.O.Caml_toplevel__a_.R.E.P.L_for_.O.Caml)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>We will begin exploration of OCaml in the interactive top level. A top level is also called a read-eval-print loop (REPL) and it works like a terminal shell. To run the ocaml
toplevel, simply run &lsquo;ocaml&lsquo;
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> % ocaml</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> OCaml version <span class="fl">5.4</span>.<span class="dv">0</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> # <span class="dt">print_string</span> <span class="st">&quot;Hello world!</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;</span>;;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    Hello world!</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a> - : <span class="dt">unit</span> = ()</span></code></pre></div>
</div>
There is an alternative toplevel called <span style="font-weight: bold">utop</span>. It is more user friendly, and we will be using &lsquo;utop&lsquo; in the class. You can install <span style="font-weight: bold">utop</span> by
running <span style="font-weight: bold">opam install utop</span>. Follow the instructions in the project 0 for installing opam and ocaml.</p><p>To load a <span style="font-weight: bold">.ml</span> file into top level:
<div class='fancy-box'><pre class="&quot;ocaml&quot;"><code>
#use &quot;hello.ml&quot;

Hello world!
- : unit = ()</code></pre>
</div></p><p><div class="SIntrapara">To exit the top-level, type <span style="font-weight: bold">^D</span> (Control D) or call the exit 0
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt"># exit 0;;</span></p></td></tr></table></div></p></section><section class="SsectionLevel3" id="section 2.8"><h3 class="heading">2.8<span class="stt">&nbsp;</span><a name="(part._.First_.O.Caml_.Example)"></a>First OCaml Example<span class="button-group"><a href="#(part._.First_.O.Caml_.Example)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h3><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* A small OCaml program (* with nested comments *) *)</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> x = <span class="dv">37</span>;; </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> y = x + <span class="dv">5</span>;; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> <span class="dt">print_int</span> y;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> x : <span class="dt">int</span> = <span class="dv">37</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> y : <span class="dt">int</span> = <span class="dv">42</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="dv">42</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">unit</span> = ()</span></code></pre></div>
</div></p></blockquote></blockquote><p><div class="SIntrapara">OCaml comments start with <span style="font-weight: bold">(*</span> and end with <span style="font-weight: bold">*)</span>. Comments can be nested.
OCaml is strictly typed. It does not implicitly cast types. For example, <span style="font-weight: bold">print_int</span> only prints <span style="font-weight: bold">int</span>s.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">print_int</span> <span class="dv">10</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="dv">10</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">unit</span> = ()</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">The <span style="font-weight: bold">unit = ()</span> is the return value of the <span style="font-weight: bold">print_int</span> function.
<span style="font-weight: bold">( )</span> is called unit. It is similar to &lsquo;void&lsquo; in other languages. It means the <span style="font-weight: bold">print_int</span> function returns nothing.
The following expressions do not type check
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">print_int</span> <span class="fl">10.5</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>Line <span class="dv">1</span>, characters <span class="dv">10-14</span>:</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> | <span class="dt">print_int</span> <span class="fl">10.5</span>;;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>              ^^^^</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>Error: The constant <span class="fl">10.5</span> has <span class="kw">type</span> <span class="dt">float</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>       but an expression was expected <span class="kw">of</span> <span class="kw">type</span> <span class="dt">int</span></span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">because <span style="font-weight: bold">print_int</span> does not take <span style="font-weight: bold">float</span> as an argument.</div></p><p><div class="SIntrapara">The following code does not typecheck because <span style="font-weight: bold">+</span> operator
requires both operands to be integers. Adding a float to an integer results in a type error.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> + <span class="fl">0.5</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>Line <span class="dv">1</span>, characters <span class="dv">4-7</span>:</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> | <span class="dv">1</span> + <span class="fl">0.5</span>;;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        ^^^</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>Error: The constant <span class="fl">0.5</span> has <span class="kw">type</span> <span class="dt">float</span> but an expression was expected <span class="kw">of</span> <span class="kw">type</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>         <span class="dt">int</span></span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">Adding a boolean to an integer results in a type error too.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> + <span class="kw">true</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>Line <span class="dv">1</span>, characters <span class="dv">4-8</span>:</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> | <span class="dv">1</span> + <span class="kw">true</span>;;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        ^^^^</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>Error: The constructor <span class="kw">true</span> has <span class="kw">type</span> <span class="dt">bool</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>       but an expression was expected <span class="kw">of</span> <span class="kw">type</span> <span class="dt">int</span></span></code></pre></div>
</div></p></blockquote></blockquote></div></p><p><div class="SIntrapara">As expected, <span style="font-weight: bold">print_int</span> does not take a string as an argument.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">print_int</span> <span class="st">&quot;This function expected an int&quot;</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>Line <span class="dv">1</span>, characters <span class="dv">10-41</span>:</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> | <span class="dt">print_int</span> <span class="st">&quot;This function expected an int&quot;</span>;;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>Error: This constant has <span class="kw">type</span> <span class="dt">string</span> but an expression was expected <span class="kw">of</span> <span class="kw">type</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>         <span class="dt">int</span></span></code></pre></div>
</div></p></blockquote></blockquote></div></p></section><section class="SsectionLevel3" id="section 2.9"><h3 class="heading">2.9<span class="stt">&nbsp;</span><a name="(part._.Expressions)"></a>Expressions<span class="button-group"><a href="#(part._.Expressions)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>In OCaml, expressions are the fundamental building blocks of programs, and evaluating an expression always produces a value. Unlike many imperative languages, which distinguish between statements (actions) and expressions (values), OCaml is expression-oriented&#8212;almost everything in the language is an expression that yields a result.</p><p><div class="SIntrapara">Every kind of expression has syntax and semantics. Semantics include:
 </div><div class="SIntrapara"><ul><li><p>Type checking rules (static semantics): produce a type or fail with an error message</p></li><li><p>Evaluation rules (dynamic semantics): produce a value or an exception or infinite loop. Evaluation rules are used only on expressions that type-check</p></li></ul></div></p><p>We use metavariable <span style="font-weight: bold">e</span> to designate an arbitrary expression.</p></section><section class="SsectionLevel3" id="section 2.10"><h3 class="heading">2.10<span class="stt">&nbsp;</span><a name="(part._.Values)"></a>Values<span class="button-group"><a href="#(part._.Values)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>A value is an expression that is final. For example, <span style="font-weight: bold">34</span> and <span style="font-weight: bold">true</span> are values because we cannot evaluate them any further. On the contrary, <span style="font-weight: bold">34+17</span> is an expression, but not a value because we can further evaluate it. Evaluating an expression means running it until it is a value. For example <span style="font-weight: bold">34+17</span> evaluates to 51, which is a value. We use metavariable <span style="font-weight: bold">v</span> to designate an arbitrary value</p></section><section class="SsectionLevel3" id="section 2.11"><h3 class="heading">2.11<span class="stt">&nbsp;</span><a name="(part._.Types)"></a>Types<span class="button-group"><a href="#(part._.Types)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>Types classify expressions. It is the set of values an expression could evaluate to.
Examples include <span class="stt">int</span>, <span class="stt">bool</span>, <span class="stt">string</span>, and more. We use metavariable <span style="font-weight: bold">t</span> to designate an arbitrary type. Expression <span style="font-weight: bold">e</span> has type <span style="font-weight: bold">t</span> if <span style="font-weight: bold">e</span> will (always) evaluate to a value of type <span style="font-weight: bold">t</span>. For example <span style="font-weight: bold">0</span>, <span style="font-weight: bold">1</span>, and <span style="font-weight: bold">-1</span> are values of type <span style="font-weight: bold">int</span> while <span style="font-weight: bold">true</span> has type <span style="font-weight: bold">bool</span>. <span style="font-weight: bold">34+17</span> is an expression of type <span style="font-weight: bold">int</span>, since it evaluates to <span style="font-weight: bold">51</span>, which has type <span style="font-weight: bold">int</span>. We usually write <span style="font-weight: bold">e : t</span> to say <span style="font-weight: bold">e</span> has type <span style="font-weight: bold">t</span>.  The process of determining <span style="font-weight: bold">e</span> has type <span style="font-weight: bold">t</span> is called <span style="font-weight: bold">type checking</span> simply, <span style="font-weight: bold">typing</span>.</p></section><section class="SsectionLevel3" id="section 2.12"><h3 class="heading">2.12<span class="stt">&nbsp;</span><a name="(part._.If_expression)"></a>If expression<span class="button-group"><a href="#(part._.If_expression)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>The syntax of the if expression is
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span> e1 <span class="kw">then</span> e2 <span class="kw">else</span> e3</span></code></pre></div>
</div></p><p>We type check the <span class="stt">if</span> expression using the following type checking rules:</p><p><span class="texMathDisplay">\frac{\Gamma \vdash e_1 : bool \quad \Gamma \vdash e_2 : t \quad \Gamma \vdash e_3 : t}
     {\Gamma \vdash \texttt{if e1 then e2 else e3} : t}</span></p><p><div class="SIntrapara">This format is called inference rules. It is a formal way to express
how you can derive a conclusion from premises. They&#8217;re everywhere in
logic, type systems, and formal proofs. Visually, an inference rule looks
like this:
<span class="texMathDisplay">\frac{premises}
     {conclusion}</span>
</div><div class="SIntrapara"><ul><li><p>Premises (top part) &#8212; things you already know or assumptions.</p></li><li><p>Conclusion (bottom part) &#8212; what follows logically from the premises.</p></li><li><p>The line separates what&#8217;s assumed from what&#8217;s derived.</p></li></ul></div></p><p><div class="SIntrapara">In plain English, it reads: In context &#915; (&#915;, "Gamma", is the type
environment. It is a map of variables and their types.), if <span class="stt">e1</span> has type <span class="stt">bool</span>, and <span class="stt">e2</span> has type <span class="stt">t</span>, and <span class="stt">e3</span> has (the same) type
<span class="stt">t</span> then the expression <span class="stt">if e1 then e2 else e3</span> has type <span class="stt">t</span>.
</div><div class="SIntrapara"><ul><li><p>Condition must be a bool: The expression e1 (the condition) must have type bool. For example, writing <span class="stt">if 1 then ...</span>
causes a type error, since 1 has type <span style="font-weight: bold">int</span>, not <span style="font-weight: bold">bool</span>.</p></li><li><p>Then- and Else-branches must have the same type: Both e2 and e3 must evaluate to values of the same type.</p></li></ul></div></p><p><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span> <span class="dv">7</span> &gt; <span class="dv">42</span> <span class="kw">then</span> <span class="st">&quot;hello&quot;</span> <span class="kw">else</span> <span class="st">&quot;goodbye&quot;</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">string</span> = <span class="st">&quot;goodbye&quot;</span></span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">The following expression does not type check because the two branches of the <span class="stt">if</span>
expression do not return the same type. The <span class="stt">true</span> branch returns <span class="stt">string</span>, while the <span class="stt">false</span> branch returns <span class="stt">int</span>
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span> <span class="dv">7</span> &gt; <span class="dv">42</span> <span class="kw">then</span> <span class="st">&quot;hello&quot;</span> <span class="kw">else</span> <span class="dv">10</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>Line <span class="dv">1</span>, characters <span class="dv">28-30</span>:</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> | <span class="kw">if</span> <span class="dv">7</span> &gt; <span class="dv">42</span> <span class="kw">then</span> <span class="st">&quot;hello&quot;</span> <span class="kw">else</span> <span class="dv">10</span>;;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>                                ^^</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>Error: The constant <span class="dv">10</span> has <span class="kw">type</span> <span class="dt">int</span> but an expression was expected <span class="kw">of</span> <span class="kw">type</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>         <span class="dt">string</span></span></code></pre></div>
</div></p></blockquote></blockquote></div></p><p><div class="SIntrapara">Evaluating an <span style="font-weight: bold">if</span> expression returns a value. For example:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span> <span class="dv">10</span>&gt;<span class="dv">5</span> <span class="kw">then</span> <span class="dv">100</span> <span class="kw">else</span> <span class="dv">200</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">100</span></span></code></pre></div>
</div></p></blockquote></blockquote></div></p><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>Quiz: To what value does this expression evaluate?</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym">if</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">10</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">&lt;</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">20</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">then</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">2</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">else</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktMeta"></span></td></tr></table></blockquote><p><label class="quiz-option"><input type="radio" name="q-if-1" value="0"/> 0</label></p><p><label class="quiz-option"><input type="radio" name="q-if-1" value="1"/> 1</label></p><p><label class="quiz-option"><input type="radio" name="q-if-1" value="2" data-correct="true"/> 2</label></p><p><label class="quiz-option"><input type="radio" name="q-if-1" value="error"/> Error</label></p></blockquote></summary><p>Answer: 2. Since 10&lt;20 is true, the value of the if expression is equal to the value of the true branch.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>Quiz: To what value does this expression evaluate?</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym">if</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">10</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">&lt;</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">20</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">then</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">print_int</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">10</span><span class="RktMeta"></span></td></tr></table></blockquote><p><label class="quiz-option"><input type="radio" name="q-if-2" value="10"/> 10</label></p><p><label class="quiz-option"><input type="radio" name="q-if-2" value="20"/> 20</label></p><p><label class="quiz-option"><input type="radio" name="q-if-2" value="unit" data-correct="true"/> ()</label></p><p><label class="quiz-option"><input type="radio" name="q-if-2" value="error"/> Error</label></p></blockquote></summary><p>Answer: Unit (). Since <span style="font-weight: bold">print_int 10</span> returns unit, we did not need to include an else branch. </p></details></section><section class="SsectionLevel3" id="section 2.13"><h3 class="heading">2.13<span class="stt">&nbsp;</span><a name="(part._.Functions)"></a>Functions<span class="button-group"><a href="#(part._.Functions)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>OCaml functions are like mathematical functions. They compute a result from provided arguments. We use <span class="stt">let</span> to define a function:</p><p>We now define the function <span style="font-weight: bold">next</span>, which accepts an integer <span style="font-weight: bold">n</span> and produces its successor.</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> next n = n + <span class="dv">1</span>;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> next <span class="dv">10</span>;; <span class="co">(* call the function next with an argument 10 *)</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> next : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">11</span></span></code></pre></div>
</div></p></blockquote></blockquote><p><div class="SIntrapara">Here is another function Factorial:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> fact n = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> n = <span class="dv">0</span> <span class="kw">then</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>       <span class="dv">1</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>       n * fact (n<span class="dv">-1</span>);; </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a> fact <span class="dv">5</span>;;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> fact : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">120</span></span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara"><span style="font-weight: bold">rec</span> keyword is used to define <span style="font-weight: bold">recursive</span> functions. <span style="font-weight: bold">;;</span> ends an expression in the top-level of OCaml. We use it to say:  &#8220;Give me the value of this expression&#8221;. It is not used in the body of a function and it is not needed in the real OCaml development.
</div><div class="SIntrapara"><details class="SubFlow"><summary>Quiz: Write a function sum that takes a positive integer n and returns the value of 1+2+3+...n.</summary><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> sum n = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> n = <span class="dv">1</span> <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> n + sum (n<span class="dv">-1</span>);; </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    sum <span class="dv">10</span>;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> sum : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">55</span></span></code></pre></div>
</div></p></blockquote></blockquote></details></div></p><section class="SsectionLevel4" id="section 2.13.1"><h4 class="heading">2.13.1<span class="stt">&nbsp;</span><a name="(part._.Calling_.Functions__.Function_.Application_)"></a>Calling Functions (Function Application)<span class="button-group"><a href="#(part._.Calling_.Functions__.Function_.Application_)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>In OCaml, calling a function is very straightforward &#8212; you just write the function name followed by its arguments, separated by spaces (not commas, and no parentheses are required unless for grouping). The calling syntax is:</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>f e1 e2 â€¦ en</span></code></pre></div>
</div>
Here is an example where we call the function <span style="font-weight: bold">square</span> with the argument <span style="font-weight: bold">5</span>.</p><p><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> square x = x * x;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> square <span class="dv">5</span>;;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> square : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">25</span></span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">Nullary functions (Functions with no arguments) are a little special compared to languages like C or Python.</div></p><p>OCaml does not truly have &#8220;argumentless&#8221; functions. Instead, a nullary function is defined as one that takes the special value <span style="font-weight: bold">( )</span> of type <span style="font-weight: bold">unit</span>.</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> greet () = <span class="st">&quot;Hello&quot;</span>;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> greet ();;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> greet : <span class="dt">unit</span> -&gt; <span class="dt">string</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">string</span> = <span class="st">&quot;Hello&quot;</span></span></code></pre></div>
</div></p></blockquote></blockquote><p><div class="SIntrapara">We evaluate a function call expression according to these steps:
</div><div class="SIntrapara"><ul><li><p>Locate the definition of <span style="font-weight: bold">f</span>, i.e., <span style="font-weight: bold">let rec f x1 &#8230; xn = e</span>.</p></li><li><p>Evaluate the arguments <span style="font-weight: bold">e1 &#8230; en</span> to obtain values <span style="font-weight: bold">v1 &#8230; vn</span>.</p></li><li><p>Substitute the values <span style="font-weight: bold">v1 &#8230; vn</span> for the parameters <span style="font-weight: bold">x1 &#8230; xn</span> in the function body <span style="font-weight: bold">e</span>, yielding a new expression <span style="font-weight: bold">e&#8217;</span>.</p></li><li><p>Evaluate <span style="font-weight: bold">e&#8217;</span> to value <span style="font-weight: bold">v</span>, which is the final result</p></li></ul></div></p><p><div class="SIntrapara">Following is an example of evaluating <span style="font-weight: bold">fact 2</span>
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> fact n = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> n = <span class="dv">0</span> <span class="kw">then</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>         <span class="dv">1</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>      <span class="kw">else</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>         n * fact (n<span class="dv">-1</span>);;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> fact : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></div></p><p><table cellspacing="0" cellpadding="0" class="boxed" style="border-collapse: collapse;"><tr><td align="left" style="border: 1px solid black;"><p><span style="font-weight: bold">expression</span></p></td><td align="left" style="border: 1px solid black;"><p><span style="font-weight: bold">semantics</span></p></td></tr><tr><td align="left" style="border: 1px solid black;"><p><span class="emph">fact (1+1)</span></p></td><td align="left" style="border: 1px solid black;"><p>evaluate the argument 1+1</p></td></tr><tr><td align="left" style="border: 1px solid black;"><p><span class="emph">fact 2</span></p></td><td align="left" style="border: 1px solid black;"><p>substitute every occurrence of n inside the body of fact with 2 </p></td></tr><tr><td align="left" style="border: 1px solid black;"><p><span class="emph">if 2=0 then 1 else 2*fact(2-1)</span></p></td><td align="left" style="border: 1px solid black;"><p>evaluate the if expression</p></td></tr><tr><td align="left" style="border: 1px solid black;"><p><span class="emph">2 * fact 1</span></p></td><td align="left" style="border: 1px solid black;"><p>result of the else branch</p></td></tr><tr><td align="left" style="border: 1px solid black;"><p><span class="emph">2 * (if 1=0 then 1 else 1*fact(1-1))</span></p></td><td align="left" style="border: 1px solid black;"><p>substitute n with 1</p></td></tr><tr><td align="left" style="border: 1px solid black;"><p><span class="emph">2 * 1 * fact 0</span></p></td><td align="left" style="border: 1px solid black;"><p>evaluate fact 0</p></td></tr><tr><td align="left" style="border: 1px solid black;"><p><span class="emph">2 * 1 * (if 0=0 then 1 else 0*fact(0-1))</span></p></td><td align="left" style="border: 1px solid black;"><p>base case</p></td></tr><tr><td align="left" style="border: 1px solid black;"><p><span class="emph">2 * 1 * 1</span></p></td><td align="left" style="border: 1px solid black;"><p></p></td></tr><tr><td align="left" style="border: 1px solid black;"><p><span class="emph">2</span></p></td><td align="left" style="border: 1px solid black;"><p></p></td></tr></table></p><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>Quiz: To what value does this code evaluate?
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> mystery n m=<span class="kw">if</span> n&gt;m <span class="kw">then</span> <span class="dv">0</span> <span class="kw">else</span> n + mystery (n+<span class="dv">1</span>) m;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>mystery <span class="dv">5</span> <span class="dv">10</span>;;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="q-fn-1" value="5"/> 5</label></p><p><label class="quiz-option"><input type="radio" name="q-fn-1" value="15"/> 15</label></p><p><label class="quiz-option"><input type="radio" name="q-fn-1" value="45" data-correct="true"/> 45</label></p><p><label class="quiz-option"><input type="radio" name="q-fn-1" value="55"/> 55</label></p></blockquote></summary><p>Answer: 45. <span class="stt">mystery n m</span> computes the sum of the integers from n to m, inclusive.
For example, mystery 5 10 = 45 (since 5 + 6 + 7 + 8 + 9 + 10 = 45)</p></details></section><section class="SsectionLevel4" id="section 2.13.2"><h4 class="heading">2.13.2<span class="stt">&nbsp;</span><a name="(part._.Function_.Types)"></a>Function Types<span class="button-group"><a href="#(part._.Function_.Types)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p><div class="SIntrapara">In OCaml, <span style="font-weight: bold">&#8594;</span> is the function type constructor. Type <span style="font-weight: bold">t1 &#8594; t</span> is a function
with argument or domain type <span style="font-weight: bold">t1</span> and return or range type <span style="font-weight: bold">t</span>. Type
<span style="font-weight: bold">t1 &#8594; t2 &#8594; t</span> is a function that takes two inputs, of types <span style="font-weight: bold">t1</span> and <span style="font-weight: bold">t2</span>,
and returns a value of type <span style="font-weight: bold">t</span>.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* function add takes two integer arguments and </span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">    returns an integer value *)</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> add x y = x + y;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> add : <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></div></p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* function greet takes a unit and returns a unit *)</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> greet () = <span class="dt">print_string</span> <span class="st">&quot;Whatâ€™s up?&quot;</span>;;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> greet : <span class="dt">unit</span> -&gt; <span class="dt">unit</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></section></section><section class="SsectionLevel3" id="section 2.14"><h3 class="heading">2.14<span class="stt">&nbsp;</span><a name="(part._.Type_.Checking_of_.Function_.Application)"></a>Type Checking of Function Application<span class="button-group"><a href="#(part._.Type_.Checking_of_.Function_.Application)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>As we have seen before, the syntax of a function application is
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>f e1 â€¦ en</span></code></pre></div>
</div></p><p>We use the following type checking rule for a single argument function application</p><p><span class="texMathDisplay">\frac{\Gamma \vdash f:t_1 \rightarrow t_2 \quad \Gamma \vdash e : t_1 }
     {\Gamma \vdash \texttt{f e} : t_2}</span>
It reads: if <span style="font-weight: bold">f</span> has type <span style="font-weight: bold">t1&#8594;t2</span> and <span style="font-weight: bold">e</span> has type <span style="font-weight: bold">t1</span> then <span style="font-weight: bold">(f e)</span> has type <span style="font-weight: bold">t2</span></p><p>In general, we use the following type checking rule for the function application
<span class="texMathDisplay">\frac{\Gamma \vdash f:t_1 \rightarrow t_2 ... \rightarrow t_n \rightarrow u, \quad \Gamma \vdash e_1 : t_1 \quad \Gamma \vdash e_2 : t_2 \quad ... \Gamma \vdash e_n : t_n }
     {\Gamma \vdash \texttt{f e1 e2 .. en} : u}</span>
It reads: if <span style="font-weight: bold">f : t1 &#8594; &#8230; &#8594; tn &#8594; u</span> and <span style="font-weight: bold">e1 : t1,  &#8230;, en : tn</span> then
the type of <span style="font-weight: bold">f e1 &#8230; en</span> is <span style="font-weight: bold">u</span>.</p><p><div class="SIntrapara">For example: the type of <span style="font-weight: bold">not true</span> is <span style="font-weight: bold">bool</span> because <span style="font-weight: bold">not : bool &#8594; bool</span> and <span style="font-weight: bold">true : bool</span>.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">not</span>;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">true</span>;; </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="dt">not</span> <span class="kw">true</span>;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">bool</span> -&gt; <span class="dt">bool</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">bool</span> = <span class="kw">true</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">bool</span> = <span class="kw">false</span></span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">Another example: the type of (+) is <span style="font-weight: bold">int &#8594; int &#8594; int</span>, the type of <span style="font-weight: bold">1+2</span> and <span style="font-weight: bold">3*4</span> are <span style="font-weight: bold">int</span>.
Therefore, the type of <span style="font-weight: bold">(+) (1+2) (3 * 4)</span> is <span style="font-weight: bold">int</span>
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>(+);; <span class="co">(* int -&gt; int -&gt; int *)</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> (<span class="dv">1</span>+<span class="dv">2</span>);; <span class="co">(* int *)</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> (<span class="dv">3</span>*<span class="dv">4</span>);; <span class="co">(* int *)</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> (+) (<span class="dv">1</span>+<span class="dv">2</span>) (<span class="dv">3</span>*<span class="dv">4</span>);; <span class="co">(* int *)</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> (<span class="dv">1</span>+<span class="dv">2</span>) + (<span class="dv">3</span>*<span class="dv">4</span>);; <span class="co">(* int *)</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">3</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">12</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">15</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">15</span></span></code></pre></div>
</div></p></blockquote></blockquote></div></p><section class="SsectionLevel4" id="section 2.14.1"><h4 class="heading">2.14.1<span class="stt">&nbsp;</span><a name="(part._.More_.Examples_on_.Function_.Type_.Checking)"></a>More Examples on Function Type Checking<span class="button-group"><a href="#(part._.More_.Examples_on_.Function_.Type_.Checking)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>As illustrated by the preceding examples, OCaml does not require programmers to
explicitly annotate types as in languages such as C or Java. Instead, OCaml
employs the Hindley&#8211;Milner type system to automatically infer the types
of expressions before performing type checking.</p><p><div class="SIntrapara">For example, the following function <span style="font-weight: bold">double</span> multiplies its integer argument by two:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> double x = x * <span class="dv">2</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> double : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">OCaml infers the type of double as <span style="font-weight: bold">int &#8594; int</span> as follows: the operator <span style="font-weight: bold">*</span> denotes integer
multiplication, so both of its operands must have type <span style="font-weight: bold">int</span>. Therefore, <span style="font-weight: bold">x</span> must have
type <span style="font-weight: bold">int</span>. Consequently, both the parameter type and the return type of double are <span style="font-weight: bold">int</span>.
In other words, <span style="font-weight: bold">double</span> is a function that takes an <span style="font-weight: bold">int</span> as input and returns an <span style="font-weight: bold">int</span> as output.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> double x = x * <span class="dv">2</span>;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> double <span class="dv">10</span>;;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> double : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">20</span></span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">Calling <span style="font-weight: bold">double</span> with an argument of a different type results in a type-checking error.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> double x = x * <span class="dv">2</span>;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> double <span class="fl">10.5</span>;;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> double : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>Line <span class="dv">1</span>, characters <span class="dv">8-12</span>:</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> |  double <span class="fl">10.5</span>;;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>            ^^^^</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>Error: The constant <span class="fl">10.5</span> has <span class="kw">type</span> <span class="dt">float</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>       but an expression was expected <span class="kw">of</span> <span class="kw">type</span> <span class="dt">int</span></span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">The function <span style="font-weight: bold">add</span> takes three integers as arguments, computes their sum, and returns an integer result.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* Adding three integers *)</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> add x y z = x + y + z;;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> add : <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">The function <span style="font-weight: bold">fn</span> takes a floating-point value as its argument, converts it to an
integer, multiplies it by 3, and returns an integer result.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> fn x = (<span class="dt">int_of_float</span> x) * <span class="dv">3</span>;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> fn <span class="fl">2.5</span>;;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> fn : <span class="dt">float</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">6</span></span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">In OCaml, <span style="font-weight: bold">int_of_float</span> converts a floating-point value (float) to an integer (int).
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int_of_float</span> <span class="fl">3.7</span>;;     <span class="co">(* = 3 *)</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="dt">int_of_float</span> <span class="fl">3.0</span>;;     <span class="co">(* = 3 *)</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="dt">int_of_float</span> (<span class="fl">-3.7</span>);;  <span class="co">(* = -3 *)</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">3</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">3</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">-3</span></span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">The following are more examples in which OCaml infers the type of a function:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* Greatest Common Divisor of Two Positive Integer Numbers *)</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> <span class="kw">rec</span> gcd a b = </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> b = <span class="dv">0</span> <span class="kw">then</span> a <span class="kw">else</span> gcd b (a <span class="kw">mod</span> b);; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>       <span class="co">(* mod: int â†’ int â†’ int. It implies a and b must be int. </span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co">          The return type is int because it returns a *)</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> gcd : <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* Sum of the first n natural numbers *)</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> <span class="kw">rec</span> sum n = </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> n = <span class="dv">0</span> <span class="kw">then</span> <span class="dv">0</span> <span class="kw">else</span> n + sum (n<span class="dv">-1</span>);; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">(* n=0 implies n must be int. Return type is int </span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co">       because it returns 0 in one branch. *)</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> sum : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* Prime Factors of a Given Positive Integer *)</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">rec</span> aux d n = </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> n = <span class="dv">1</span> <span class="kw">then</span> [] <span class="kw">else</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>          <span class="kw">if</span> n <span class="kw">mod</span> d = <span class="dv">0</span> <span class="kw">then</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>             d :: aux d (n / d) </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>          <span class="kw">else</span> aux (d + <span class="dv">1</span>) n </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    ;; </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> factors n = aux <span class="dv">2</span> n;; </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    factors <span class="dv">210</span>;;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> aux : <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> factors : <span class="dt">int</span> -&gt; <span class="dt">int</span> <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">5</span>; <span class="dv">7</span>]</span></code></pre></div>
</div></p></blockquote></blockquote></div></p></section><section class="SsectionLevel4" id="section 2.14.2"><h4 class="heading">2.14.2<span class="stt">&nbsp;</span><a name="(part._.Mutually_.Recursive_.Functions)"></a>Mutually Recursive Functions<span class="button-group"><a href="#(part._.Mutually_.Recursive_.Functions)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Mutually recursive functions are functions that call each other (directly or indirectly). You define them using the <span style="font-weight: bold">and</span> keyword along with <span style="font-weight: bold">let rec</span>.</p><p><div class="SIntrapara">Suppose we want two functions, <span style="font-weight: bold">even</span> and <span style="font-weight: bold">odd</span>, to determine whether a number is even or odd, with <span style="font-weight: bold">even</span> calling <span style="font-weight: bold">odd</span> and <span style="font-weight: bold">odd</span> calling <span style="font-weight: bold">even</span>. We define them together using <span style="font-weight: bold">let rec ... and</span>
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> odd n = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> n = <span class="dv">0</span> <span class="kw">then</span> <span class="kw">false</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> even(n<span class="dv">-1</span>) </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> <span class="kw">and</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    even n = </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> n = <span class="dv">0</span> <span class="kw">then</span> <span class="kw">true</span> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>      <span class="kw">else</span> odd(n<span class="dv">-1</span>);; </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a> even <span class="dv">100</span>;; </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a> odd <span class="dv">101</span>;;</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> odd : <span class="dt">int</span> -&gt; <span class="dt">bool</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> even : <span class="dt">int</span> -&gt; <span class="dt">bool</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">bool</span> = <span class="kw">true</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">bool</span> = <span class="kw">true</span></span></code></pre></div>
</div></p></blockquote></blockquote></div></p></section><section class="SsectionLevel4" id="section 2.14.3"><h4 class="heading">2.14.3<span class="stt">&nbsp;</span><a name="(part._.Polymorphic_.Types)"></a>Polymorphic Types<span class="button-group"><a href="#(part._.Polymorphic_.Types)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p><div class="SIntrapara">In OCaml, a polymorphic type is a type that contains one or more type
variables (written <span class="stt"></span><span class="stt">&rsquo;</span><span class="stt">a, </span><span class="stt">&rsquo;</span><span class="stt">b</span>, etc.), meaning the function or value can
operate uniformly on values of many different types. A polymorphic
function works for any type, not just one specific type. The following functions <span style="font-weight: bold">swap</span> and <span style="font-weight: bold">eq</span>
are polymorphic function. The types <span class="stt"></span><span class="stt">&rsquo;</span><span class="stt">a</span> and <span class="stt"></span><span class="stt">&rsquo;</span><span class="stt">b</span> can be read as <span style="font-weight: bold">for all type a and b</span>
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* Swapping two values of a tuple (we will cover tuples later) *)</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> swap (x,y) = (y,x);;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> swap : &#39;a * &#39;b -&gt; &#39;b * &#39;a = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">The function <span class="stt">eq x y</span> returns true if x and y are structurally equal, and false otherwise.
It has type <span class="stt"></span><span class="stt">&rsquo;</span><span class="stt">a -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a -&gt; bool</span>, meaning that
for any type <span class="stt"></span><span class="stt">&rsquo;</span><span class="stt">a</span>, it takes two values of type <span class="stt"></span><span class="stt">&rsquo;</span><span class="stt">a</span> and produces a boolean result.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* structural equality *)</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> eq x y = x = y;; </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> eq <span class="dv">3</span> <span class="dv">3</span>;;           <span class="co">(* true *)</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> eq <span class="dv">1</span> <span class="dv">2</span>;;           <span class="co">(* false *)</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> eq <span class="st">&quot;hello&quot;</span> <span class="st">&quot;hello&quot;</span>;; <span class="co">(* true *)</span> </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> eq [<span class="dv">1</span>;<span class="dv">2</span>] [<span class="dv">1</span>;<span class="dv">2</span>];;   <span class="co">(* true *)</span> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a> eq [<span class="dv">1</span>;<span class="dv">2</span>] [<span class="dv">2</span>;<span class="dv">1</span>];;   <span class="co">(* false *)</span> </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a> eq <span class="st">&quot;hello&quot;</span> <span class="dv">1</span>;;    <span class="co">(* type error *)</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> eq : &#39;a -&gt; &#39;a -&gt; <span class="dt">bool</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">bool</span> = <span class="kw">true</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">bool</span> = <span class="kw">false</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">bool</span> = <span class="kw">true</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">bool</span> = <span class="kw">true</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">bool</span> = <span class="kw">false</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>Line <span class="dv">1</span>, characters <span class="dv">12-13</span>:</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> |  eq <span class="st">&quot;hello&quot;</span> <span class="dv">1</span>;;    <span class="co">(* type error *)</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>                ^</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>Error: The constant <span class="dv">1</span> has <span class="kw">type</span> <span class="dt">int</span> but an expression was expected <span class="kw">of</span> <span class="kw">type</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>         <span class="dt">string</span></span></code></pre></div>
</div></p></blockquote></blockquote></div></p><p><div class="SIntrapara">The types <span class="stt"></span><span class="stt">&rsquo;</span><span class="stt">a</span> <span class="stt"></span><span class="stt">&rsquo;</span><span class="stt">b</span> are basically generic types in Java. The Java version of the <span class="stt">eq</span> is:
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>public <span class="dt">static</span> <span class="op">&lt;</span>T<span class="op">&gt;</span> boolean eq<span class="op">(</span>T x<span class="op">,</span> T y<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x<span class="op">.</span>equals<span class="op">(</span>y<span class="op">);</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div><div class="SIntrapara"><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>Quiz: What is the type of the following function?
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f x y =</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> x = y <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span></span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="q-poly-1" value="1"/> 'a -&gt; 'b -&gt; int</label></p><p><label class="quiz-option"><input type="radio" name="q-poly-1" value="2"/> int</label></p><p><label class="quiz-option"><input type="radio" name="q-poly-1" value="3"/> 'a -&gt; 'a -&gt; bool</label></p><p><label class="quiz-option"><input type="radio" name="q-poly-1" value="4" data-correct="true"/> 'a -&gt; 'a -&gt; int</label></p></blockquote></summary><p>Answer: &rsquo;a -&gt; &rsquo;a -&gt; int</p></details></div></p></section><section class="SsectionLevel4" id="section 2.14.4"><h4 class="heading">2.14.4<span class="stt">&nbsp;</span><a name="(part._.Type_annotations)"></a>Type annotations<span class="button-group"><a href="#(part._.Type_annotations)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>The OCaml compiler can infer types automatically, but type inference can be tricky and sometimes
produces vague error messages. To avoid this, we can provide type annotations manually.
Annotations are useful for clarity, documentation, and resolving ambiguities.</p><p><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (x : <span class="dt">int</span>) = <span class="dv">3</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> x : <span class="dt">int</span> = <span class="dv">3</span></span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> fn (x:<span class="dt">int</span>):<span class="dt">float</span> = (<span class="dt">float_of_int</span> x) *. <span class="fl">3.14</span>;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="co">(* (x : int) explicitly states that x is an integer. </span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">     float states the return type is float *)</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> add (x:<span class="dt">int</span>) (y:<span class="dt">int</span>):<span class="dt">int</span> = x + y;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> fn : <span class="dt">int</span> -&gt; <span class="dt">float</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> add : <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> id x = x;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> id : &#39;a -&gt; &#39;a = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> id (x:<span class="dt">int</span>) = x;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="co">(* This annotation constrains the function to take an int </span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">     as its argument and to return an int. *)</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> id : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></div></p></section></section><section class="SsectionLevel3" id="section 2.15"><h3 class="heading">2.15<span class="stt">&nbsp;</span><a name="(part._.Lists)"></a>Lists<span class="button-group"><a href="#(part._.Lists)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h3><p><div class="SIntrapara">The list is a fundamental data structure in OCaml. Lists can have arbitrary length and are implemented as linked structures. All elements in a list must be of the same type (i.e., lists are homogeneous). We will learn how to construct lists and deconstruct them using pattern matching.
In OCaml, <span style="font-weight: bold">[ ]</span> is a value, represents an empty list. Elements are separated by semicolons.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>[];; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">4</span>];; </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> [<span class="st">&quot;apple&quot;</span>; <span class="st">&quot;banana&quot;</span>; <span class="st">&quot;cherry&quot;</span>];;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>- : &#39;a <span class="dt">list</span> = []</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">4</span>]</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">string</span> <span class="dt">list</span> = [<span class="st">&quot;apple&quot;</span>; <span class="st">&quot;banana&quot;</span>; <span class="st">&quot;cherry&quot;</span>]</span></code></pre></div>
</div></p></blockquote></blockquote></div></p><p>To evaluate <span style="font-weight: bold">[e1; e2;...;en]</span>, we evaluate <span style="font-weight: bold">e1</span> to a value <span style="font-weight: bold">v1</span>, <span style="font-weight: bold">e2</span> to a value <span style="font-weight: bold">v2</span>, and <span style="font-weight: bold">en</span> to a value <span style="font-weight: bold">vn</span>, and return <span style="font-weight: bold">[v1;&#8230;;vn]</span>.</p><p>In OCaml, the list notation [e1; e2] is syntactic sugar for using the cons operator ::(pronounced &#8220;cons&#8221;). <span style="font-weight: bold">::</span> constructs a list by prepending an element to an existing list. Specifically:
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>[e1; e2];;  <span class="co">(* syntactic sugar *)</span></span></code></pre></div>
</div>
is equivalent to:
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>e1 :: e2 :: [];;  <span class="co">(* desugared form *)</span></span></code></pre></div>
</div></p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> y = [<span class="dv">1</span>; <span class="dv">1</span>+<span class="dv">1</span>; <span class="dv">1</span>+<span class="dv">1</span>+<span class="dv">1</span>] ;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> x = <span class="dv">4</span>::y ;; </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> z = <span class="dv">5</span>::y ;; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> m = <span class="st">&quot;hello&quot;</span> :: <span class="st">&quot;bob&quot;</span> ::[];;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> y : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>]</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> x : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">4</span>; <span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>]</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> z : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">5</span>; <span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>]</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> m : <span class="dt">string</span> <span class="dt">list</span> = [<span class="st">&quot;hello&quot;</span>; <span class="st">&quot;bob&quot;</span>]</span></code></pre></div>
</div></p></blockquote></blockquote><section class="SsectionLevel4" id="section 2.15.1"><h4 class="heading">2.15.1<span class="stt">&nbsp;</span><a name="(part._.Typing_.Lists)"></a>Typing Lists<span class="button-group"><a href="#(part._.Typing_.Lists)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>The type of an empty list <span class="emph">[ ]</span> is <span style="font-weight: bold">&rsquo;a list</span>. The type of <span style="font-weight: bold">Cons</span> is
<span class="texMathDisplay">\frac{\Gamma \vdash e_1 : t \quad \Gamma \vdash e_2 : t\;\text{list}}
     {\Gamma \vdash e_1 :: e_2 : t\;\text{list}}
\quad (\text{T-Cons})</span></p><p>It reads: if (e1 : t) and (e2 : t list) then (e1::e2) : (t list).</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> l = [];; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> m = [[<span class="dv">1</span>];[<span class="dv">2</span>;<span class="dv">3</span>]];; </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> w = [<span class="st">&quot;apple&quot;</span>; <span class="st">&quot;banana&quot;</span>; <span class="st">&quot;watermelon&quot;</span>];;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> l : &#39;a <span class="dt">list</span> = []</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> m : <span class="dt">int</span> <span class="dt">list</span> <span class="dt">list</span> = [[<span class="dv">1</span>]; [<span class="dv">2</span>; <span class="dv">3</span>]]</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> w : <span class="dt">string</span> <span class="dt">list</span> = [<span class="st">&quot;apple&quot;</span>; <span class="st">&quot;banana&quot;</span>; <span class="st">&quot;watermelon&quot;</span>]</span></code></pre></div>
</div></p></blockquote></blockquote><p><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> y = <span class="dv">0</span>::[<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>] ;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> y : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">0</span>; <span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>]</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = [<span class="dv">1</span>;<span class="st">&quot;world&quot;</span>] ;; <span class="co">(* all elements must have same type *)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>Line <span class="dv">1</span>, characters <span class="dv">11-18</span>:</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> | <span class="kw">let</span> x = [<span class="dv">1</span>;<span class="st">&quot;world&quot;</span>] ;; <span class="co">(* all elements must have same type *)</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>               ^^^^^^^</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>Error: This constant has <span class="kw">type</span> <span class="dt">string</span> but an expression was expected <span class="kw">of</span> <span class="kw">type</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>         <span class="dt">int</span></span></code></pre></div>
</div></p></blockquote></blockquote></div></p><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>Quiz: What is the type of the following expression?
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>[<span class="fl">1.0</span>; <span class="fl">2.0</span>; <span class="fl">3.0</span>; <span class="fl">4.0</span>]</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="q-list-1" value="array"/> array</label></p><p><label class="quiz-option"><input type="radio" name="q-list-1" value="list"/> list</label></p><p><label class="quiz-option"><input type="radio" name="q-list-1" value="float list" data-correct="true"/> float list</label></p><p><label class="quiz-option"><input type="radio" name="q-list-1" value="4"/> int list</label></p></blockquote></summary><p>Answer: float list</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>Quiz: What is the type of the following expression?
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dv">10</span>::[<span class="dv">20</span>]</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="q-list-2" value="1"/> int</label></p><p><label class="quiz-option"><input type="radio" name="q-list-2" value="2" data-correct="true"/> int list</label></p><p><label class="quiz-option"><input type="radio" name="q-list-2" value="3"/> int int list</label></p><p><label class="quiz-option"><input type="radio" name="q-list-2" value="4"/> error</label></p></blockquote></summary><p>Answer: int list</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>Quiz: What is the type of the function f?
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f a = <span class="st">&quot;umd&quot;</span>::[a]</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="q-list-3" value="1"/> string -&gt; string</label></p><p><label class="quiz-option"><input type="radio" name="q-list-3" value="2"/> string list</label></p><p><label class="quiz-option"><input type="radio" name="q-list-3" value="3"/> string list -&gt; string list</label></p><p><label class="quiz-option"><input type="radio" name="q-list-3" value="4" data-correct="true"/> string -&gt; string list</label></p></blockquote></summary><p>Answer: string -&gt; string list</p></details></section><section class="SsectionLevel4" id="section 2.15.2"><h4 class="heading">2.15.2<span class="stt">&nbsp;</span><a name="(part.____.Operator)"></a>:: Operator<span class="button-group"><a href="#(part.____.Operator)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p><div class="SIntrapara">&lsquo;::&lsquo; operator appends a single item, not a list, to the front of another list. The left argument of &lsquo;::&lsquo; is an element, the right is a list
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> y = <span class="dv">0</span>::[<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>] ;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> w = [<span class="dv">1</span>;<span class="dv">2</span>]::y ;; <span class="co">(* error *)</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> y : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">0</span>; <span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>]</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>Line <span class="dv">1</span>, characters <span class="dv">16-17</span>:</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> |  <span class="kw">let</span> w = [<span class="dv">1</span>;<span class="dv">2</span>]::y ;; <span class="co">(* error *)</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>                    ^</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>Error: The value y has <span class="kw">type</span> <span class="dt">int</span> <span class="dt">list</span> but an expression was expected <span class="kw">of</span> <span class="kw">type</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>         <span class="dt">int</span> <span class="dt">list</span> <span class="dt">list</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>       Type <span class="dt">int</span> is <span class="dt">not</span> compatible <span class="kw">with</span> <span class="kw">type</span> <span class="dt">int</span> <span class="dt">list</span></span></code></pre></div>
</div></p></blockquote></blockquote></div></p><p><div class="SIntrapara"><details class="SubFlow"><summary>Quiz: Can you construct a list y such that [1;2]::y? </summary><p>Yes. If the type of <span style="font-weight: bold">y</span> is <span style="font-weight: bold">int list list</span>,i.e., <span style="font-weight: bold">[1;2]::[[3;4]]</span>.
Each element of this list is an <span style="font-weight: bold">int list</span>.</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> y = [[<span class="dv">3</span>;<span class="dv">4</span>;<span class="dv">5</span>];[<span class="dv">6</span>]];; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> [<span class="dv">1</span>;<span class="dv">2</span>]::y;;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> y : <span class="dt">int</span> <span class="dt">list</span> <span class="dt">list</span> = [[<span class="dv">3</span>; <span class="dv">4</span>; <span class="dv">5</span>]; [<span class="dv">6</span>]]</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> <span class="dt">list</span> = [[<span class="dv">1</span>; <span class="dv">2</span>]; [<span class="dv">3</span>; <span class="dv">4</span>; <span class="dv">5</span>]; [<span class="dv">6</span>]]</span></code></pre></div>
</div></p></blockquote></blockquote></details></div><div class="SIntrapara">A nonempty list is a <span style="font-weight: bold">pair (element, rest of list)</span>. The <span style="font-weight: bold">element</span> is the head of the list, and <span style="font-weight: bold">rest of the list</span>
 is itself a list. Thus in math (i.e., inductively) a list is either
</div><div class="SIntrapara"><ul><li><p>The empty list [ ]</p></li><li><p>Or a pair consisting of an element and a list</p></li></ul></div><div class="SIntrapara">.
This recursive structure will come in handy shortly. <span style="font-weight: bold">[1;2;3]</span> is represented as:
<img src="lists.png" alt="" width="536" height="211"/></div></p></section><section class="SsectionLevel4" id="section 2.15.3"><h4 class="heading">2.15.3<span class="stt">&nbsp;</span><a name="(part._.Lists_of_.Lists)"></a>Lists of Lists<span class="button-group"><a href="#(part._.Lists_of_.Lists)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p><div class="SIntrapara">Lists can be nested arbitrarily. For example:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>[ [<span class="dv">9</span>; <span class="dv">10</span>; <span class="dv">11</span>]; [<span class="dv">5</span>; <span class="dv">4</span>; <span class="dv">3</span>; <span class="dv">2</span>] ];;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> <span class="dt">list</span> = [[<span class="dv">9</span>; <span class="dv">10</span>; <span class="dv">11</span>]; [<span class="dv">5</span>; <span class="dv">4</span>; <span class="dv">3</span>; <span class="dv">2</span>]]</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">The type <span style="font-weight: bold">int list list</span> can also be written as <span style="font-weight: bold">(int list) list</span>.</div></p><p><div class="SIntrapara">Lists are immutable in OCaml; you cannot change an element of a list. Instead, you create new
lists from existing ones, for example using the :: operator.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>;<span class="dv">4</span>];; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> y = <span class="dv">5</span>::x;; </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> z = <span class="dv">6</span>::x;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> x : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">4</span>]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> y : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">5</span>; <span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">4</span>]</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> z : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">6</span>; <span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">4</span>]</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">Since <span style="font-weight: bold">x</span> refers to an immutable list, the tails of both y and z share the same list x.
<img src="linked-list-prepend.png" alt="" width="525" height="170"/></div></p></section></section><section class="SsectionLevel3" id="section 2.16"><h3 class="heading">2.16<span class="stt">&nbsp;</span><a name="(part._.Pattern_.Matching)"></a>Pattern Matching<span class="button-group"><a href="#(part._.Pattern_.Matching)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>Pattern matching in OCaml is a powerful way to destructure values, test their shape,
and bind variables to parts of the value &#8212; all in a single, concise construct. It
is used extensively with algebraic data types (like option, list, trees, and custom types).</p><p><div class="SIntrapara">The syntax of the match expression is:
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">match</span> e <span class="kw">with</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>| p1 -&gt; e1 </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>| â€¦ </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>| pn -&gt; en</span></code></pre></div>
</div>
Where:
</div><div class="SIntrapara"><ul><li><p>e is the expression being matched.</p></li><li><p>p1, ..., pn are patterns.</p></li><li><p>e1, ..., en are the expressions executed when a pattern matches.</p></li></ul></div></p><p>The pattern-matching part of the
<span style="font-weight: bold">match</span> is a sequence of clauses, each one of the form: <span style="font-weight: bold">pattern &#8594; expr</span>, separated by
vertical bars (|). The clauses are processed in order, and only the <span style="font-weight: bold">expr</span> of first matching
 clause is evaluated. The value of the entire match expression is the value of the <span style="font-weight: bold">expr</span>
 of the matching clause; If no <span style="font-weight: bold">pattern</span> matches <span style="font-weight: bold">expr</span>, your match is said to be
 <span style="font-weight: bold">non-exhaustive</span> and when a match fails it raises the exception <span style="font-weight: bold">Match_failure</span>.</p><p><div class="SIntrapara">We use the following type checking rules for the match expression:
Let t be the type of e.
</div><div class="SIntrapara"><ul><li><p>Each pattern <span style="font-weight: bold">pi</span> must be a pattern of type <span style="font-weight: bold">t</span>. (i.e., e and the patterns have same type)</p></li><li><p>Each branch expression <span style="font-weight: bold">ei</span> must have the same type <span style="font-weight: bold">t2</span>. So the whole match expression has type <span style="font-weight: bold">t2</span>.</p></li></ul></div><div class="SIntrapara">For example: the function <span style="font-weight: bold">neg</span> negates the boolean argument.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> neg x = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> x <span class="kw">with</span> <span class="co">(* x must be bool *)</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    | <span class="kw">true</span> -&gt; <span class="kw">false</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    | <span class="kw">false</span> -&gt; <span class="kw">true</span>;; </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    neg <span class="kw">true</span>;; </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    neg (<span class="dv">10</span> &gt; <span class="dv">20</span>);;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> neg : <span class="dt">bool</span> -&gt; <span class="dt">bool</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">bool</span> = <span class="kw">false</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">bool</span> = <span class="kw">true</span></span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">The function <span style="font-weight: bold">is_empty</span> checks if a list is empty:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> is_empty l = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> l <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>              [] -&gt; <span class="kw">true</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>            | (h::t) -&gt; <span class="kw">false</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> ;; </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> is_empty [];; </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a> is_empty [<span class="dv">1</span>];; </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a> is_empty [<span class="dv">1</span>;<span class="dv">2</span>];;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> is_empty : &#39;a <span class="dt">list</span> -&gt; <span class="dt">bool</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">bool</span> = <span class="kw">true</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">bool</span> = <span class="kw">false</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">bool</span> = <span class="kw">false</span></span></code></pre></div>
</div></p></blockquote></blockquote></div></p><p><div class="SIntrapara">The function <span style="font-weight: bold">is_odd</span> checks if a value is odd:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> is_odd x = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>          <span class="kw">match</span> x <span class="kw">mod</span> <span class="dv">2</span> <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>          <span class="dv">0</span> -&gt; <span class="kw">false</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>          | <span class="dv">1</span> -&gt; <span class="kw">true</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>          | _ -&gt; <span class="dt">raise</span> (<span class="dt">Invalid_argument</span> <span class="st">&quot;is_odd&quot;</span>);;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> is_odd : <span class="dt">int</span> -&gt; <span class="dt">bool</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">An underscore <span style="font-weight: bold">_</span> is a wildcard pattern. It matches anything, but doesn&#8217;t add any bindings. It is useful to
hold a place but discard the value i.e., when the variable does not appear in the branch expression.</div></p><details class="SubFlow"><summary>Quiz: In is_odd, why do we need the third match case | _ -&gt;?</summary><p><span style="font-weight: bold">-1 mod 2</span> returns -1. The <span style="font-weight: bold">mod</span> operator can produce
values other than 0 and 1.</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dv">11</span> <span class="kw">mod</span> <span class="dv">2</span>;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="dv">10</span> <span class="kw">mod</span> <span class="dv">2</span>;; </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="dv">-11</span> <span class="kw">mod</span> <span class="dv">2</span>;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">1</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">0</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">-1</span></span></code></pre></div>
</div></p></blockquote></blockquote></details><p><div class="SIntrapara">Logical implication
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> imply v = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> v <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">true</span>,<span class="kw">true</span>)   -&gt; <span class="kw">true</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    | (<span class="kw">true</span>,<span class="kw">false</span>)  -&gt; <span class="kw">false</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    | (<span class="kw">false</span>,<span class="kw">true</span>)  -&gt; <span class="kw">true</span> </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    | (<span class="kw">false</span>,<span class="kw">false</span>) -&gt; <span class="kw">true</span>;;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> imply : <span class="dt">bool</span> * <span class="dt">bool</span> -&gt; <span class="dt">bool</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">Or, we can make it even simpler:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> imply v = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> v <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">true</span>,x)  -&gt; x </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>      | (<span class="kw">false</span>,x) -&gt; <span class="kw">true</span>;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> imply : <span class="dt">bool</span> * <span class="dt">bool</span> -&gt; <span class="dt">bool</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></div></p><p><div class="SIntrapara">For characters, OCaml also recognizes the range patterns in the form of &rsquo;c1&rsquo; .. &rsquo;cn&rsquo; as shorthand for any ASCII character in the range.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> is_vowel c = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> c <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    (<span class="ch">&#39;a&#39;</span> | <span class="ch">&#39;e&#39;</span> | <span class="ch">&#39;i&#39;</span> | <span class="ch">&#39;o&#39;</span> | <span class="ch">&#39;u&#39;</span>) -&gt; <span class="kw">true</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    | _ -&gt; <span class="kw">false</span>;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> is_vowel : <span class="dt">char</span> -&gt; <span class="dt">bool</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">Determine whether a character is uppercase:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> is_upper x = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> x <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="ch">&#39;A&#39;</span> .. <span class="ch">&#39;Z&#39;</span> -&gt; <span class="kw">true</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    | _ -&gt; <span class="kw">false</span>;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> is_upper : <span class="dt">char</span> -&gt; <span class="dt">bool</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></div></p><p>In OCaml, the underscore <span style="font-weight: bold">_</span> in a match is a wildcard pattern. It is like the default in the switch statement.
It matches anything, but doesn&#8217;t bind a variable to the value.</p><section class="SsectionLevel4" id="section 2.16.1"><h4 class="heading">2.16.1<span class="stt">&nbsp;</span><a name="(part._.Pattern_.Matching_.Lists)"></a>Pattern Matching Lists<span class="button-group"><a href="#(part._.Pattern_.Matching_.Lists)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p><div class="SIntrapara">In OCaml, you can destruct lists using pattern matching by matching against the list constructors:
</div><div class="SIntrapara"><ul><li><p>[ ] represents the empty list.</p></li><li><p>h :: t (pronounced "head cons tail") represents a list with head element h and tail list t.</p></li></ul></div></p><p><div class="SIntrapara">Here are the primary techniques for destructuring lists with examples. Patterns can also be nested for more precise matches.
</div><div class="SIntrapara"><ul><li><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>a::b <span class="co">(* matches lists with at least one element *)</span></span></code></pre></div>
</div> For example:
  <div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">match</span> [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>] <span class="kw">with</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> |a::b -&gt; a;;</span></code></pre></div>
</div>
matches and binds a to 1 and b to [2;3]</p></li><li><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>a::[] <span class="co">(* matches lists with exactly one element *)</span></span></code></pre></div>
</div> For example:
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">match</span> [<span class="dv">1</span>] <span class="kw">with</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>| a::[]</span></code></pre></div>
</div>
 binds a to 1. we could also write pattern <span style="font-weight: bold">a::[]</span> as <span style="font-weight: bold">[a]</span></p></li><li><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>a::b::[] <span class="co">(* matches lists with @bold{exactly two elements} *)</span></span></code></pre></div>
</div> For example:
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">match</span> [<span class="dv">1</span>;<span class="dv">2</span>] <span class="kw">with</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>|a::b::[]</span></code></pre></div>
</div>
 binds a to 1 and b to 2. We could also write pattern <span style="font-weight: bold">a::b::[]</span> as <span style="font-weight: bold">[a;b]</span></p></li><li><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>a::b::c::d <span class="co">(* matches lists with at least three elements *)</span></span></code></pre></div>
</div> For example:
  <div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">match</span> [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>] <span class="kw">with</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>|a::b::c::d</span></code></pre></div>
</div>
binds a to 1, b to 2, c to 3, and d to [].</p></li></ul></div></p><p>OCaml can detect non-exhaustive patterns and warn you about them. For example:
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> hd l = <span class="kw">match</span> l <span class="kw">with</span> (h::_) -&gt; h;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>Warning: this pattern-matching is <span class="dt">not</span> exhaustive.</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>Here is an example <span class="kw">of</span> a value that is <span class="dt">not</span> matched: []</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a># hd [];;</span></code></pre></div>
</div></p><p>Therefore, you can&#8217;t forget a case because compiler issues inexhaustive
pattern-match warning. You can&#8217;t duplicate a case because compiler issues
unused match case warning. Pattern matching leads to elegant, concise, beautiful code .</p><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>Quiz: To what does the following expression evaluate?
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">match</span> [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>] <span class="kw">with</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>[] -&gt; [<span class="dv">0</span>] </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>| h::t -&gt; t</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="q-pm-1" value="1"/> [ ]</label></p><p><label class="quiz-option"><input type="radio" name="q-pm-1" value="2"/> [0]</label></p><p><label class="quiz-option"><input type="radio" name="q-pm-1" value="3"/> [1]</label></p><p><label class="quiz-option"><input type="radio" name="q-pm-1" value="4" data-correct="true"/> [2;3]</label></p></blockquote></summary><p>Answer: [2;3]</p></details><p><div class="SIntrapara"><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>Quiz: To what does the following expression evaluate?
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">match</span> [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>] <span class="kw">with</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  | <span class="dv">1</span>::[]    -&gt; [<span class="dv">0</span>]</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  | _::_     -&gt; [<span class="dv">1</span>]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  | <span class="dv">1</span>::_::[] -&gt; []</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="q-pm-2" value="1"/> [ ]</label></p><p><label class="quiz-option"><input type="radio" name="q-pm-2" value="2"/> [0]</label></p><p><label class="quiz-option"><input type="radio" name="q-pm-2" value="3" data-correct="true"/> [1]</label></p><p><label class="quiz-option"><input type="radio" name="q-pm-2" value="4"/> [2;3]</label></p></blockquote></summary><p>Answer: [1]</p></details></div><div class="SIntrapara"><details class="SubFlow"><summary>Quiz: Can write pattern as [a;b;c]::d?</summary><p>Yes. It matches a list whose first element is itself a 3-element list.</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">match</span> [[<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>]; [<span class="dv">4</span>;<span class="dv">5</span>]; [<span class="dv">6</span>]] <span class="kw">with</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    [a;b;c]::d -&gt; d </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    |_ -&gt; [] </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> ;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> <span class="dt">list</span> = [[<span class="dv">4</span>; <span class="dv">5</span>]; [<span class="dv">6</span>]]</span></code></pre></div>
</div></p></blockquote></blockquote></details></div></p><p>In the earlier examples, many values of h or t were unused. In such cases, we can replace them with the wildcard _.
 For example, in the <span style="font-weight: bold">is_empty</span>, the h and t bindings are unused. We can replace them with <span style="font-weight: bold">_</span>.</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* check if a list is empty *)</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> is_empty l = </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> l <span class="kw">with</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    | [] -&gt; <span class="kw">true</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    | _::_ -&gt; <span class="kw">false</span>;; </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a> is_empty [];; </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a> is_empty [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>];; </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a> is_empty [<span class="st">&quot;a&quot;</span>; <span class="st">&quot;b&quot;</span>; <span class="st">&quot;c&quot;</span>];;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> is_empty : &#39;a <span class="dt">list</span> -&gt; <span class="dt">bool</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">bool</span> = <span class="kw">true</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">bool</span> = <span class="kw">false</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">bool</span> = <span class="kw">false</span></span></code></pre></div>
</div></p></blockquote></blockquote><p><div class="SIntrapara">Let&#8217;s define a function that computes the sum of all elements in an <span style="font-weight: bold">int list</span>.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> sum l = <span class="kw">match</span> l <span class="kw">with</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>      [] -&gt; <span class="dv">0</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    | (h::t) -&gt; h + (sum t);; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    sum [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>;<span class="dv">4</span>];;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> sum : <span class="dt">int</span> <span class="dt">list</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">10</span></span></code></pre></div>
</div></p></blockquote></blockquote></div></p><p>The <span style="font-weight: bold">sum</span> function works only for int lists, but the <span style="font-weight: bold">is_empty</span> function works for any type of list.
OCaml gives such functions polymorphic types. <div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>is_empty : &#39;a <span class="dt">list</span> -&gt; <span class="dt">bool</span></span></code></pre></div>
</div></p></section><section class="SsectionLevel4" id="section 2.16.2"><h4 class="heading">2.16.2<span class="stt">&nbsp;</span><a name="(part._.Pattern_.Matching_~e2~80~93_.An_.Abbreviation)"></a>Pattern Matching &#8211; An Abbreviation<span class="button-group"><a href="#(part._.Pattern_.Matching_~e2~80~93_.An_.Abbreviation)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p><div class="SIntrapara">If there&#8217;s only one acceptable input, the pattern matching <div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f x = <span class="kw">match</span> x <span class="kw">with</span> p -&gt; e</span></code></pre></div>
</div>
can be abbreviated to <div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f p = e</span></code></pre></div>
</div>
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="dt">fst</span> pair = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> pair <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    | (x, _) -&gt; x;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="dt">fst</span> : &#39;a * &#39;b -&gt; &#39;a = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">You can abbreviate by putting the pattern directly in the function parameter:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="dt">fst</span> (x, _) = x;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="dt">fst</span> : &#39;a * &#39;b -&gt; &#39;a = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></div></p><p><div class="SIntrapara">With the <span style="font-weight: bold">function</span> keyword, you can abbreviate
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f x = <span class="kw">match</span> x <span class="kw">with</span> ...</span></code></pre></div>
</div> to
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f = <span class="kw">function</span></span></code></pre></div>
</div> We can abbreviate
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f x = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> x <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    | <span class="dv">0</span> -&gt; <span class="st">&quot;zero&quot;</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    | <span class="dv">1</span> -&gt; <span class="st">&quot;one&quot;</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    | _ -&gt; <span class="st">&quot;many&quot;</span>;;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> f : <span class="dt">int</span> -&gt; <span class="dt">string</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">to
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f = <span class="kw">function</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    | <span class="dv">0</span> -&gt; <span class="st">&quot;zero&quot;</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    | <span class="dv">1</span> -&gt; <span class="st">&quot;one&quot;</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    | _ -&gt; <span class="st">&quot;many&quot;</span>;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> f : <span class="dt">int</span> -&gt; <span class="dt">string</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></div></p></section></section><section class="SsectionLevel3" id="section 2.17"><h3 class="heading">2.17<span class="stt">&nbsp;</span><a name="(part._.Lists_and_.Recursion)"></a>Lists and Recursion<span class="button-group"><a href="#(part._.Lists_and_.Recursion)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h3><p><div class="SIntrapara">Lists have a recursive structure and so most functions over lists will be recursive.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> length l = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> l <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    |[] -&gt; <span class="dv">0</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    | (_::t) -&gt; <span class="dv">1</span> + (length t);; </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    length [<span class="dv">1</span>;<span class="dv">3</span>;<span class="dv">6</span>;<span class="dv">9</span>];;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> length : &#39;a <span class="dt">list</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">4</span></span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">This is just like an inductive definition:
</div><div class="SIntrapara"><ul><li><p>The length of the empty list is zero</p></li><li><p>The length of a nonempty list is 1 plus the length of the tail.</p></li></ul></div></p><p><div class="SIntrapara">Negate elements in list
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> negate l = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>          <span class="kw">match</span> l <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>       [] -&gt; [] </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>       | (h::t) -&gt; (-h) :: (negate t);; </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> negate [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">-10</span>];;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> negate : <span class="dt">int</span> <span class="dt">list</span> -&gt; <span class="dt">int</span> <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">-1</span>; <span class="dv">-2</span>; <span class="dv">10</span>]</span></code></pre></div>
</div></p></blockquote></blockquote></div></p><p><div class="SIntrapara">Get the last element of a list
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> last l = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> l <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    | []-&gt;[] </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    | [x] -&gt; [x] </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    | (h::t) -&gt; last t;; </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    last [];; </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    last [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>;<span class="dv">4</span>];;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> last : &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>- : &#39;a <span class="dt">list</span> = []</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">4</span>]</span></code></pre></div>
</div></p></blockquote></blockquote></div></p><p><div class="SIntrapara">Append two lists, that is, produce a list containing all elements of l followed by all elements of m.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> append l m = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> l <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>     [] -&gt; m </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    | (h::t) -&gt; h::(append t m);; </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> append [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>] [<span class="dv">4</span>;<span class="dv">5</span>;<span class="dv">6</span>];; </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a> <span class="co">(* Reversing a list *)</span> </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> <span class="kw">rec</span> rev l = <span class="kw">match</span> l <span class="kw">with</span> </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>      [] -&gt; [] </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    | (h::t) -&gt; append (rev t) [h];; </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a> rev [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>;<span class="dv">4</span>];;</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> append : &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">4</span>; <span class="dv">5</span>; <span class="dv">6</span>]</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> rev : &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">4</span>; <span class="dv">3</span>; <span class="dv">2</span>; <span class="dv">1</span>]</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara"><span style="font-weight: bold">rev</span> takes <span class="texMathInline">O(n^2)</span>$ time.  Can you do better? Here is a  clever version of reverse, which takes O(n) time.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> rev_helper l a = <span class="kw">match</span> l <span class="kw">with</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    [] -&gt; a </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    | (x::xs) -&gt; rev_helper xs (x::a);; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> rev l = rev_helper l [];; </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a> rev [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>;<span class="dv">4</span>];;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> rev_helper : &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> rev : &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">4</span>; <span class="dv">3</span>; <span class="dv">2</span>; <span class="dv">1</span>]</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">Let&#8217;s give it a try
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>rev [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>] â†’</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>rev_helper [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>] [] â†’</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>rev_helper [<span class="dv">2</span>;<span class="dv">3</span>] [<span class="dv">1</span>] â†’</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>rev_helper [<span class="dv">3</span>] [<span class="dv">2</span>;<span class="dv">1</span>] â†’</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>rev_helper [] [<span class="dv">3</span>;<span class="dv">2</span>;<span class="dv">1</span>] â†’</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>[<span class="dv">3</span>;<span class="dv">2</span>;<span class="dv">1</span>]</span></code></pre></div>
</div></div></p><p><div class="SIntrapara">Check if x is member of a list
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> member lst x= </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> lst <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    |[]-&gt;<span class="kw">false</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    |h::t-&gt;<span class="kw">if</span> h = x <span class="kw">then</span> <span class="kw">true</span> <span class="kw">else</span> member t x;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> member : &#39;a <span class="dt">list</span> -&gt; &#39;a -&gt; <span class="dt">bool</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></div></p><p><div class="SIntrapara">Merge two sorted lists into one sorted list
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> merge l1 l2 = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> l1,l2 <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>     [],l-&gt;l </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>     |l,[]-&gt;l </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>     |(h1::t1, h2::t2)-&gt; </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>          <span class="kw">if</span> h1 &lt; h2 <span class="kw">then</span> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>            h1::merge t1 l2 </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>          <span class="kw">else</span> </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>            h2::merge l1 t2;; </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a> merge [<span class="dv">1</span>;<span class="dv">3</span>;<span class="dv">7</span>;<span class="dv">9</span>] [<span class="dv">2</span>;<span class="dv">3</span>;<span class="dv">4</span>;<span class="dv">5</span>;<span class="dv">6</span>];;</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> merge : &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">3</span>; <span class="dv">4</span>; <span class="dv">5</span>; <span class="dv">6</span>; <span class="dv">7</span>; <span class="dv">9</span>]</span></code></pre></div>
</div></p></blockquote></blockquote></div></p><p><div class="SIntrapara">Insert x into a sorted list l in sorted order
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> insert x l= </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> l <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    |[]-&gt;[x] </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    |h::t-&gt;<span class="kw">if</span> x &lt; h <span class="kw">then</span> x::h::t <span class="kw">else</span> h::insert x t;; </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> insert <span class="dv">10</span> [<span class="dv">5</span>;<span class="dv">9</span>;<span class="dv">20</span>;<span class="dv">30</span>];;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> insert : &#39;a -&gt; &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">5</span>; <span class="dv">9</span>; <span class="dv">10</span>; <span class="dv">20</span>; <span class="dv">30</span>]</span></code></pre></div>
</div></p></blockquote></blockquote></div></p><p><div class="SIntrapara">Insertion sort
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> insert x l= </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>          <span class="kw">match</span> l <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>          |[]-&gt;[x] </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>          |h::t-&gt; </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> x &lt; h <span class="kw">then</span> x::h::t </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">else</span> h::insert x t;; </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> <span class="kw">rec</span> sort l = </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">match</span> l <span class="kw">with</span> </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>                  []-&gt;[] </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>                  |[x]-&gt;[x] </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>                  |h::t-&gt;insert h (sort t);; </span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a> sort [<span class="dv">1</span>;<span class="dv">6</span>;<span class="dv">2</span>;<span class="dv">10</span>;<span class="dv">-5</span>];;</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> insert : &#39;a -&gt; &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> sort : &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">-5</span>; <span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">6</span>; <span class="dv">10</span>]</span></code></pre></div>
</div></p></blockquote></blockquote></div></p><p>The following sorting algorithms illustrate how recursion and pattern matching on lists combine to express classic algorithms concisely in OCaml.</p><p><div class="SIntrapara">QuickSort
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> qsort = <span class="kw">function</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>        | [] -&gt; []</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        | pivot :: rest -&gt;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> left, right = <span class="dt">List</span>.partition (<span class="kw">fun</span> x-&gt; x &lt; pivot) rest <span class="kw">in</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    qsort left @ [pivot] @ qsort right;;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> qsort : &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">MergeSort
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(** split list a into two even parts *)</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> split a = </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">rec</span> aux lst b c = </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">match</span> lst <span class="kw">with</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>                    [] -&gt; (b, c) </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>                  | hd :: tail -&gt; aux tail c (hd :: b) </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>          <span class="kw">in</span> aux a [] [];; </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a> <span class="co">(* merge lists xs and ys *)</span> </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> <span class="kw">rec</span> merge cmp xs ys = </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">match</span> (xs, ys) <span class="kw">with</span> </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>                    ([], []) -&gt; [] </span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>                  | (_, []) -&gt; xs </span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>                  | ([], _) -&gt; ys </span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>                  | (xhd :: xtail, yhd :: ytail) -&gt; </span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">if</span> (cmp xhd yhd) <span class="kw">then</span> </span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>                          xhd :: (merge cmp xtail ys) </span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>            <span class="kw">else</span> </span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>                          yhd :: (merge cmp xs ytail);; </span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> <span class="kw">rec</span> mergesort cmp os  = </span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">match</span> os <span class="kw">with</span> </span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>                  [] -&gt; [] </span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>                  | [x] -&gt; [x] </span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>                  | _ -&gt; </span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">let</span> (ls, rs) = split os <span class="kw">in</span> </span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>          merge cmp (mergesort cmp ls) (mergesort cmp rs);; </span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> lt a b = a &lt; b;; </span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>    mergesort lt [<span class="dv">1</span>;<span class="dv">6</span>;<span class="dv">2</span>;<span class="dv">10</span>;<span class="dv">-5</span>];;</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> split : &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> * &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> merge : (&#39;a -&gt; &#39;a -&gt; <span class="dt">bool</span>) -&gt; &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> mergesort : (&#39;a -&gt; &#39;a -&gt; <span class="dt">bool</span>) -&gt; &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> lt : &#39;a -&gt; &#39;a -&gt; <span class="dt">bool</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">-5</span>; <span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">6</span>; <span class="dv">10</span>]</span></code></pre></div>
</div></p></blockquote></blockquote></div></p></section><section class="SsectionLevel3" id="section 2.18"><h3 class="heading">2.18<span class="stt">&nbsp;</span><a name="(part._.Let_.Expressions)"></a>Let Expressions<span class="button-group"><a href="#(part._.Let_.Expressions)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>In OCaml, a let expression binds a name to a value.
Its general form is:</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = e1 <span class="kw">in</span> e2</span></code></pre></div>
</div></p><p><div class="SIntrapara">In this construct:
</div><div class="SIntrapara"><ul><li><p>x is the bound variable</p></li><li><p>e1 is the binding expression</p></li><li><p>e2 is the body expression in which the binding is visible.</p></li></ul></div></p><p><div class="SIntrapara">We evaluate a let expression using the following rule:
<span class="texMathDisplay">\frac{e_1 \Rightarrow{} v_1&#160;&#160;\quad&#160;&#160;&#160; e_2[v1/x] \Rightarrow{} v_2}
     {\texttt{let } x = e_1 \texttt{ in } e_2 \Rightarrow{} v_2}</span>
This rule is read as:
</div><div class="SIntrapara"><ul><li><p>Evaluate e1 to a value v1</p></li><li><p>Substitute <span style="font-weight: bold">v1</span> for <span style="font-weight: bold">x</span> in <span style="font-weight: bold">e2</span>, producing a new expression <span style="font-weight: bold">e2&rsquo;</span></p></li><li><p>Evaluate <span style="font-weight: bold">e2&#8217;</span> to <span style="font-weight: bold">v2</span>, which is the final result</p></li></ul></div><div class="SIntrapara">For example:
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = <span class="dv">20</span> + <span class="dv">1</span> <span class="kw">in</span> x + x </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = <span class="dv">21</span> <span class="kw">in</span> x + x <span class="co">(* evaluate e1, 20+1 ==&gt; 21)</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">21 + 21 (* Substitute 21 for x in e2 *) </span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co">42</span></span></code></pre></div>
</div>
Here is the type checking rule for the let expression:
<span class="texMathDisplay">\frac{\Gamma \vdash e_1 : t_1 \quad \Gamma, x:t_1\vdash e_2 : t_2}
     {\Gamma \vdash \texttt{let } x = e_1 \texttt{ in } e_2 : t_2}
\quad (\text{T-Let})</span>
This rule is read as: Under the typing context Gamma, if <span style="font-weight: bold">e1 : t1</span> and
if assuming <span style="font-weight: bold">x : t1</span> implies <span style="font-weight: bold">e2 : t</span> then <span style="font-weight: bold">(let x = e1 in e2) : t</span></div></p><section class="SsectionLevel4" id="section 2.18.1"><h4 class="heading">2.18.1<span class="stt">&nbsp;</span><a name="(part._.Let_.Definitions_vs__.Let_.Expressions_)"></a>Let Definitions vs. Let Expressions <span class="button-group"><a href="#(part._.Let_.Definitions_vs__.Let_.Expressions_)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p><div class="SIntrapara">At the top level (in utop), we write <span style="font-weight: bold">let x = e;;</span>. Notice that there
is no <span style="font-weight: bold">in e2</span> part, unlike with a <span style="font-weight: bold">let expression</span>.
This is called a <span style="font-weight: bold">let definition</span>. The difference is that a
let definition does not itself produce a value when evaluated;
instead, it installs a new name into the top-level environment.
In other words, by omitting <span style="font-weight: bold">in</span>, we are saying &#8220;<span style="font-weight: bold">from now on</span>,
 the name x refers to the result of evaluating e.&#8221;
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> pi = <span class="fl">3.14</span>;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="co">(* pi is now bound in the rest of the top-level scope *)</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> pi : <span class="dt">float</span> = <span class="fl">3.14</span></span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">We can write any expression at top-level, too
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>e;;</span></code></pre></div>
</div>
This says to evaluate <span style="font-weight: bold">e</span> and then ignore the result. It is equivalent to
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> _ = e;;</span></code></pre></div>
</div>
Useful when &lsquo;e&lsquo; has a side effect, such as reading/writing a file, printing to the screen, etc.</div></p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = <span class="dv">37</span>;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> y = x + <span class="dv">5</span>;; </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="dt">print_int</span> y;; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> <span class="dt">print_string</span> <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> x : <span class="dt">int</span> = <span class="dv">37</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> y : <span class="dt">int</span> = <span class="dv">42</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="dv">42</span>- : <span class="dt">unit</span> = ()</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">unit</span> = ()</span></code></pre></div>
</div></p></blockquote></blockquote></section><section class="SsectionLevel4" id="section 2.18.2"><h4 class="heading">2.18.2<span class="stt">&nbsp;</span><a name="(part._.Let_.Expressions__.Scope)"></a>Let Expressions: Scope<span class="button-group"><a href="#(part._.Let_.Expressions__.Scope)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p><div class="SIntrapara">In <span style="font-weight: bold">let x = e1 in e2</span>, variable <span style="font-weight: bold">x</span> is not visible outside of <span style="font-weight: bold">e2</span>. For example:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> pi = <span class="fl">3.14</span> <span class="kw">in</span> pi *. <span class="fl">3.0</span> *. <span class="fl">3.0</span>;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="co">(* pi is only visible inside pi *. 3.0 *. 3.0. *)</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="dt">print_float</span> pi;; <span class="co">(* pi is not visible here *)</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">float</span> = <span class="fl">28.259999999999998</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>Line <span class="dv">2</span>, characters <span class="dv">13-15</span>:</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span> |  <span class="dt">print_float</span> pi;; <span class="co">(* pi is not visible here *)</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>                 ^^</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>Error: Unbound value pi</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">It binds <span style="font-weight: bold">pi</span> (only) in body of let (which is <span style="font-weight: bold">pi *. 3.0 *. 3.0</span>). Outside <span style="font-weight: bold">e2</span>,
the variable <span style="font-weight: bold">x</span> is not visible. After <span style="font-weight: bold">e2</span> <span style="font-weight: bold">(pi *. 3.0 *. 3.0)</span> is evaluated, <span style="font-weight: bold">pi</span>
 is out of scope. Therefore, <span style="font-weight: bold">print_float pi;;</span> shows <span style="font-weight: bold">pi not bound error</span>.
 This is similar to the scoping in C/JAVA.
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">float</span> pi <span class="op">=</span> <span class="fl">3.14</span><span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  pi <span class="op">*</span> <span class="fl">3.0</span> <span class="op">*</span> <span class="fl">3.0</span><span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>pi<span class="op">;</span> <span class="co">/* pi unbound! */</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co">/* After the curly bracket, @bold{pi} is not visible.  */</span></span></code></pre></div>
</div></div></p><p>More examples on let expressions:
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>x;; <span class="co">(* Unbound value x *)</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = <span class="dv">1</span> <span class="kw">in</span> x + <span class="dv">1</span>;;  <span class="co">(* 2 *)</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = x <span class="kw">in</span> x + <span class="dv">1</span>;; <span class="co">(* Unbound value x *)</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = <span class="dv">1</span> <span class="kw">in</span>  x + <span class="dv">1</span> + x   ;;    <span class="co">(* 3 *)</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>(<span class="kw">let</span> x = <span class="dv">1</span> <span class="kw">in</span> x + <span class="dv">1</span>) ;;  x;;   <span class="co">(* Unbound value x *)</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = <span class="dv">4</span> <span class="kw">in</span> (<span class="kw">let</span> x = x + <span class="dv">1</span> <span class="kw">in</span> x) </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>             <span class="kw">let</span> x = <span class="dv">4</span> + <span class="dv">1</span> <span class="kw">in</span> x</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>             <span class="kw">let</span> x = <span class="dv">5</span> <span class="kw">in</span> x</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>             <span class="dv">5</span></span></code></pre></div>
</div></p></section><section class="SsectionLevel4" id="section 2.18.3"><h4 class="heading">2.18.3<span class="stt">&nbsp;</span><a name="(part._.Nested_.Let_.Expressions)"></a>Nested Let Expressions<span class="button-group"><a href="#(part._.Nested_.Let_.Expressions)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p><div class="SIntrapara">Uses of <span style="font-weight: bold">let</span> can be nested
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> res = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">let</span> area = </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">let</span> pi = <span class="fl">3.14</span> <span class="kw">in</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> r = <span class="fl">3.0</span> <span class="kw">in</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>      pi *. r *. r) <span class="kw">in</span> </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>      <span class="co">(* pi and r are not visible here *)</span> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    area /. <span class="fl">2.0</span>);; </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">(* area is not visible here *)</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> res : <span class="dt">float</span> = <span class="fl">14.129999999999999</span></span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">Similar scoping possibilities in C and Java
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> res<span class="op">;</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span> <span class="dt">float</span> area<span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span> <span class="dt">float</span> pi <span class="op">=</span> <span class="fl">3.14</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> r <span class="op">=</span> <span class="fl">3.0</span><span class="op">;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    area <span class="op">=</span> pi <span class="op">*</span> r <span class="op">*</span> r<span class="op">;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span>  <span class="co">// p and r are not visible here.</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  res <span class="op">=</span> area <span class="op">/</span> <span class="fl">2.0</span><span class="op">;</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="co">// area is not visible here</span></span></code></pre></div>
</div>
You should generally avoid nested let Style. Sometimes a nested binding
can be rewritten in a more linear style to make the code easier to understand. For example:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> res = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">let</span> area = </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">let</span> pi = <span class="fl">3.14</span> <span class="kw">in</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> r = <span class="fl">3.0</span> <span class="kw">in</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>      pi *. r *. r) <span class="kw">in</span> </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    area /. <span class="fl">2.0</span>);;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> res : <span class="dt">float</span> = <span class="fl">14.129999999999999</span></span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">can be written as
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> res = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> pi = <span class="fl">3.14</span> <span class="kw">in</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> r = <span class="fl">3.0</span> <span class="kw">in</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> area = pi *. r *. r <span class="kw">in</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    area /. <span class="fl">2.0</span>;;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> res : <span class="dt">float</span> = <span class="fl">14.129999999999999</span></span></code></pre></div>
</div></p></blockquote></blockquote></div></p></section><section class="SsectionLevel4" id="section 2.18.4"><h4 class="heading">2.18.4<span class="stt">&nbsp;</span><a name="(part._.Let_.Expressions_in_.Functions)"></a>Let Expressions in Functions<span class="button-group"><a href="#(part._.Let_.Expressions_in_.Functions)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p><div class="SIntrapara">You can use <span style="font-weight: bold">let</span> inside of functions for local variables:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> area d = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> pi = <span class="fl">3.14</span> <span class="kw">in</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> r = d /. <span class="fl">2.0</span> <span class="kw">in</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> square x = x *. x <span class="kw">in</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    pi *. (square r);; </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> area <span class="fl">10.0</span>;;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> area : <span class="dt">float</span> -&gt; <span class="dt">float</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">float</span> = <span class="fl">78.5</span></span></code></pre></div>
</div></p></blockquote></blockquote></div></p></section><section class="SsectionLevel4" id="section 2.18.5"><h4 class="heading">2.18.5<span class="stt">&nbsp;</span><a name="(part._.Shadowing_.Names)"></a>Shadowing Names<span class="button-group"><a href="#(part._.Shadowing_.Names)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p><div class="SIntrapara">Shadowing is rebinding a name in an inner scope to have a different meaning.
Some languages such as java do not allow it. For example:
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f<span class="op">(</span><span class="dt">float</span> i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="op">*</span>i <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span> <span class="co">// Here i refer to the inner character variable.</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span> <span class="co">// Here, i refers to the global integer variable</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
Similarly, OCaml allows shadowing variables:
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = <span class="dv">3</span>+<span class="dv">4</span> <span class="kw">in</span> <span class="kw">let</span> x = <span class="dv">3</span>*x <span class="kw">in</span> x+<span class="dv">1</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = <span class="dv">7</span> <span class="kw">in</span> <span class="kw">let</span> x = <span class="dv">3</span>*x <span class="kw">in</span> x+<span class="dv">1</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = <span class="dv">3</span>*<span class="dv">7</span> <span class="kw">in</span> x+<span class="dv">1</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = <span class="dv">21</span> <span class="kw">in</span> x+<span class="dv">1</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="dv">21</span>+<span class="dv">1</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="dv">22</span></span></code></pre></div>
</div>
In this example, the <span style="font-weight: bold">x</span> in the inner <span style="font-weight: bold">let</span> expression <span style="font-weight: bold">let x = 3*x in x+1</span>
 shadows the <span style="font-weight: bold">x</span> in outer <span style="font-weight: bold">let</span> expression  <span style="font-weight: bold">let x = 3+4 in ...</span>
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = <span class="dv">10</span> <span class="kw">in</span> (<span class="kw">let</span> x = x*<span class="dv">2</span> <span class="kw">in</span> x * x);; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="co">(* inner x shadows the outer x. It is same as *)</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> x = <span class="dv">10</span> <span class="kw">in</span> (<span class="kw">let</span> y = x*<span class="dv">2</span> <span class="kw">in</span> y * y);;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">400</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">400</span></span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara"><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>Quiz: What does this evaluate to?
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = <span class="dv">2</span> <span class="kw">in</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> y = x + x <span class="kw">in</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>y * x</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="q-let-1" value="4"/> 4</label></p><p><label class="quiz-option"><input type="radio" name="q-let-1" value="6"/> 6</label></p><p><label class="quiz-option"><input type="radio" name="q-let-1" value="8" data-correct="true"/> 8</label></p><p><label class="quiz-option"><input type="radio" name="q-let-1" value="Error"/> Error</label></p></blockquote></summary><p>Answer: 8. <span class="stt">x</span> is bound to 2, <span class="stt">y</span> is bound to <span class="stt">x + x = 4</span>, and <span class="stt">y * x = 4 * 2 = 8</span>.</p></details></div></p><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>Quiz: What does this evaluate to?
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = <span class="dv">5</span> <span class="kw">in</span> x = <span class="dv">3</span></span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="q-let-2" value="3"/> 3</label></p><p><label class="quiz-option"><input type="radio" name="q-let-2" value="2"/> 2</label></p><p><label class="quiz-option"><input type="radio" name="q-let-2" value="true"/> true</label></p><p><label class="quiz-option"><input type="radio" name="q-let-2" value="false" data-correct="true"/> false</label></p></blockquote></summary><p>Answer: false. In OCaml, <span class="stt">=</span> is the equality operator, not assignment. <span class="stt">x = 3</span> checks whether <span class="stt">x</span> equals 3, and since <span class="stt">x</span> is 5, it returns <span class="stt">false</span>.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>Quiz: What does this evaluate to?
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> y = <span class="dv">3</span> <span class="kw">in</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = y+<span class="dv">2</span> <span class="kw">in</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> y = <span class="dv">6</span> <span class="kw">in</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>x+y</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="q-let-3" value="8"/> 8</label></p><p><label class="quiz-option"><input type="radio" name="q-let-3" value="11" data-correct="true"/> 11</label></p><p><label class="quiz-option"><input type="radio" name="q-let-3" value="13"/> 13</label></p><p><label class="quiz-option"><input type="radio" name="q-let-3" value="14"/> 14</label></p></blockquote></summary><p>Answer: 11. <span class="stt">y</span> is first bound to 3, then <span class="stt">x</span> is bound to <span class="stt">y+2 = 5</span>. The second <span class="stt">let y = 6</span> shadows the original <span class="stt">y</span>, so <span class="stt">x+y = 5+6 = 11</span>.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>Quiz: To what value does this code evaluate?
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = <span class="dv">5</span> <span class="kw">in</span> (<span class="kw">let</span> x = x * <span class="dv">2</span> <span class="kw">in</span> x * x) * x</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="q-let-4" value="1"/> 1000</label></p><p><label class="quiz-option"><input type="radio" name="q-let-4" value="2" data-correct="true"/> 500</label></p><p><label class="quiz-option"><input type="radio" name="q-let-4" value="3"/> 125</label></p><p><label class="quiz-option"><input type="radio" name="q-let-4" value="55"/> 50</label></p></blockquote></summary><p>Answer: 500.
In the expression let x = 5 in (let x = x * 2 in x * x) * x, the result is 500 because of how let bindings work.
First, in the outer expression, x = 5. This means the last x in (let x = x * 2 in x * x) * x refers to 5.
Next, consider the inner expression: let x = x * 2 in x * x.
The x in x * 2 still refers to the outer x, which is 5. So:
x * 2 = 5 * 2 = 10
Now x is redefined as 10 inside the inner let, and we compute:
x * x = 10 * 10 = 100
So the inner expression evaluates to 100. Substituting this back into the outer expression gives:
100 * 5 = 500. Therefore, the final result of the whole expression is 500.</p></details></section></section><section class="SsectionLevel3" id="section 2.19"><h3 class="heading">2.19<span class="stt">&nbsp;</span><a name="(part._.Tuples)"></a>Tuples<span class="button-group"><a href="#(part._.Tuples)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>A tuple is an ordered sequence of n values written in parenthesis and separated by
commas as <span style="font-weight: bold">(e1, e2, ..., en)</span>. For instance, <span style="font-weight: bold">(330, "hello", true)</span> is a 3-tuple that
contains the integer <span class="stt">330</span> as its first component, the string <span class="stt">"hello"</span> as its second
component, and the boolean value <span class="stt">true</span> as its third component. <span style="font-weight: bold">()</span> denotes the empty
tuple with <span class="stt">0</span> element. It is called <span style="font-weight: bold">unit</span> in OCaml.</p><p><div class="SIntrapara">Tuple types use <span style="font-weight: bold">*</span> to separate the type of its components. For example:
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>(<span class="dv">1</span>, <span class="dv">2</span>) : (<span class="dt">int</span> * <span class="dt">int</span>)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>(<span class="dv">1</span>, <span class="st">&quot;string&quot;</span>, <span class="fl">3.5</span>) : <span class="dt">int</span> * <span class="dt">string</span> * <span class="dt">float</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>(<span class="dv">1</span>, [<span class="st">&quot;a&quot;</span>; <span class="st">&quot;b&quot;</span>], <span class="ch">&#39;c&#39;</span>) :<span class="dt">int</span> * <span class="dt">string</span> <span class="dt">list</span> * <span class="dt">char</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>[(<span class="dv">1</span>,<span class="dv">2</span>)] : (<span class="dt">int</span> * <span class="dt">int</span>) <span class="dt">list</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>[(<span class="dv">1</span>, <span class="dv">2</span>); (<span class="dv">3</span>, <span class="dv">4</span>)] :(<span class="dt">int</span> * <span class="dt">int</span>) <span class="dt">list</span></span></code></pre></div>
</div>
Tuples are fixed size. The following code does not type check
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> foo x = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">match</span> x <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    (a, b) -&gt; a + b </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    |(a, b, c) -&gt; a + b + c;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>Line <span class="dv">4</span>, characters <span class="dv">5-14</span>:</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="dv">4</span> |     |(a, b, c) -&gt; a + b + c;;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>         ^^^^^^^^^</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>Error: This pattern was expected <span class="kw">to</span> <span class="kw">match</span> values <span class="kw">of</span> <span class="kw">type</span> &#39;a * &#39;b,</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>       but it contains an extra unlabeled component.</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">because the pattern <span style="font-weight: bold">(a,b)</span> has the type <span style="font-weight: bold">int * int</span>, and the second
pattern has the type <span style="font-weight: bold">int * int * int</span>, but all the pattern expressions in
a <span style="font-weight: bold">match</span> must have the same type.</div></p><section class="SsectionLevel4" id="section 2.19.1"><h4 class="heading">2.19.1<span class="stt">&nbsp;</span><a name="(part._.Pattern_.Matching_.Tuples)"></a>Pattern Matching Tuples<span class="button-group"><a href="#(part._.Pattern_.Matching_.Tuples)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p><div class="SIntrapara">In OCaml, you can use pattern matching on tuples to directly unpack their components.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> plus3 t = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> t <span class="kw">with</span> (x, y, z) -&gt; x + y + z;; </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> plus3(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>);;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> plus3 : <span class="dt">int</span> * <span class="dt">int</span> * <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">6</span></span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">Because <span style="font-weight: bold">plus3</span> has only one pattern. It can be written as:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> plus3&#39; (x, y, z) = x + y + z;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> plus3&#39;(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>);;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> plus3&#39; : <span class="dt">int</span> * <span class="dt">int</span> * <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">6</span></span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">The function <span style="font-weight: bold">addOne</span> adds 1 to each element of a 3-item tuple.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> addOne (x, y, z) = (x+<span class="dv">1</span>, y+<span class="dv">1</span>, z+<span class="dv">1</span>);; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> addOne(<span class="dv">10</span>,<span class="dv">20</span>,<span class="dv">30</span>);;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> addOne : <span class="dt">int</span> * <span class="dt">int</span> * <span class="dt">int</span> -&gt; <span class="dt">int</span> * <span class="dt">int</span> * <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> * <span class="dt">int</span> * <span class="dt">int</span> = (<span class="dv">11</span>, <span class="dv">21</span>, <span class="dv">31</span>)</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">The function <span style="font-weight: bold">sum</span> adds the second argument to each element of a 2-item tuple.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> sum ((a, b), c) = (a+c, b+c);; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> sum ((<span class="dv">1</span>, <span class="dv">2</span>), <span class="dv">3</span>) = (<span class="dv">4</span>, <span class="dv">5</span>);;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> sum : (<span class="dt">int</span> * <span class="dt">int</span>) * <span class="dt">int</span> -&gt; <span class="dt">int</span> * <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">bool</span> = <span class="kw">true</span></span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">The function <span style="font-weight: bold">plusFirstTwo</span> takes a list and an integer,
and adds the integer to the first two elements of the list.
The OCaml compiler warns about this code because the pattern match
is non-exhaustive: if the list is empty or has fewer than two elements,
the function will throw a <span class="stt">Match_failure</span> exception.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> plusFirstTwo (x::y::_, a) = (x + a, y + a);; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> plusFirstTwo ([<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>], <span class="dv">4</span>) = (<span class="dv">5</span>, <span class="dv">6</span>);;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>Line <span class="dv">1</span>, characters <span class="dv">17-29</span>:</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> | <span class="kw">let</span> plusFirstTwo (x::y::_, a) = (x + a, y + a);; </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>                     ^^^^^^^^^^^^</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>Warning <span class="dv">8</span> [partial-<span class="kw">match</span>]: this pattern-matching is <span class="dt">not</span> exhaustive.</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  Here is an example <span class="kw">of</span> a case that is <span class="dt">not</span> matched: (x::[], _)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> plusFirstTwo : <span class="dt">int</span> <span class="dt">list</span> * <span class="dt">int</span> -&gt; <span class="dt">int</span> * <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">bool</span> = <span class="kw">true</span></span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara"><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>Quiz: What does this evaluate to?
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> get a b = (a+b,<span class="dv">0</span>) <span class="kw">in</span> get <span class="dv">1</span> <span class="dv">2</span></span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="q-tuple-1" value="(3,0)" data-correct="true"/> (3,0)</label></p><p><label class="quiz-option"><input type="radio" name="q-tuple-1" value="(2,0)"/> (2,0)</label></p><p><label class="quiz-option"><input type="radio" name="q-tuple-1" value="3"/> 3</label></p><p><label class="quiz-option"><input type="radio" name="q-tuple-1" value="type error"/> type error</label></p></blockquote></summary><p>Answer: (3,0). <span class="stt">get</span> takes two arguments <span class="stt">a</span> and <span class="stt">b</span> and returns the tuple <span class="stt">(a+b, 0)</span>. So <span class="stt">get 1 2</span> returns <span class="stt">(1+2, 0) = (3, 0)</span>.</p></details></div></p><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>Quiz: What does this evaluate to?
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> get (a,b) y = a+y <span class="kw">in</span> get (<span class="dv">2</span>,<span class="dv">1</span>) <span class="dv">1</span></span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="q-tuple-2" value="3" data-correct="true"/> 3</label></p><p><label class="quiz-option"><input type="radio" name="q-tuple-2" value="type error"/> type error</label></p><p><label class="quiz-option"><input type="radio" name="q-tuple-2" value="2"/> 2</label></p><p><label class="quiz-option"><input type="radio" name="q-tuple-2" value="1"/> 1</label></p></blockquote></summary><p>Answer: 3. <span class="stt">get</span> pattern-matches its first argument as a tuple <span class="stt">(a,b)</span>, binding <span class="stt">a=2</span> and <span class="stt">b=1</span>. Then it computes <span class="stt">a+y = 2+1 = 3</span>.</p></details></section></section><section class="SsectionLevel3" id="section 2.20"><h3 class="heading">2.20<span class="stt">&nbsp;</span><a name="(part._.Records)"></a>Records<span class="button-group"><a href="#(part._.Records)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h3><p><div class="SIntrapara">A record represents a collection of values stored together as one, where each
component is identified by a different field name. The syntax for a record type declaration is as follows:
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &lt;record-name&gt; =</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    { &lt;field&gt; : &lt;<span class="kw">type</span>&gt;;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>      &lt;field&gt; : &lt;<span class="kw">type</span>&gt;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>      ...</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div>
</div>
For example, we can define a record type <span style="font-weight: bold">date</span> as:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> date = { month: <span class="dt">string</span>; day: <span class="dt">int</span>; year: <span class="dt">int</span> } </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="co">(* Now, we can define a record: *)</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> today = { day = <span class="dv">16</span>; year = <span class="dv">2017</span>; month = <span class="st">&quot;f&quot;</span> ^ <span class="st">&quot;eb&quot;</span> };;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> date = { month : <span class="dt">string</span>; day : <span class="dt">int</span>; year : <span class="dt">int</span>; }</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> today : date = {month = <span class="st">&quot;feb&quot;</span>; day = <span class="dv">16</span>; year = <span class="dv">2017</span>}</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">We can access the components of a record by field name or pattern matching.
Here is an example of accessing a record by field name:
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">print_string</span> today.month;; <span class="co">(* prints feb *)</span></span></code></pre></div>
</div></div></p><p><div class="SIntrapara">Here is an example of accessing the record by pattern matching
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> date = { month: <span class="dt">string</span>; day: <span class="dt">int</span>; year: <span class="dt">int</span> } </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> f x = </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> x <span class="kw">with</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    {year; day; month}-&gt; </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Printf</span>.printf <span class="st">&quot;%d</span><span class="ch">\t</span><span class="st">%s</span><span class="ch">\t</span><span class="st">%d</span><span class="ch">\n</span><span class="st">&quot;</span> year month day;; </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a> f {year=<span class="dv">2024</span>;day=<span class="dv">6</span>;month=<span class="st">&quot;Feb&quot;</span>};;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> date = { month : <span class="dt">string</span>; day : <span class="dt">int</span>; year : <span class="dt">int</span>; }</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> f : date -&gt; <span class="dt">unit</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="dv">2024</span>    Feb <span class="dv">6</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">unit</span> = ()</span></code></pre></div>
</div></p></blockquote></blockquote></div></p><p><div class="SIntrapara">We can also bind records fields to pattern variables:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> date = { month: <span class="dt">string</span>; day: <span class="dt">int</span>; year: <span class="dt">int</span> } </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> f x = </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> x <span class="kw">with</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    {year=y; day=d; month=m} -&gt; <span class="dt">Printf</span>.printf <span class="st">&quot;%d</span><span class="ch">\t</span><span class="st">%s</span><span class="ch">\t</span><span class="st">%d</span><span class="ch">\n</span><span class="st">&quot;</span> y m d;; </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> f {year=<span class="dv">2024</span>;day=<span class="dv">6</span>;month=<span class="st">&quot;Feb&quot;</span>};;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> date = { month : <span class="dt">string</span>; day : <span class="dt">int</span>; year : <span class="dt">int</span>; }</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> f : date -&gt; <span class="dt">unit</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="dv">2024</span>    Feb <span class="dv">6</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">unit</span> = ()</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">There is a syntactic sugar for the match
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f3 {year; day; month} = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Printf</span>.printf <span class="st">&quot;%d   %s  %d</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;</span> year month day</span></code></pre></div>
</div>
or
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f {year =y; day=d; month=m} = <span class="dt">Printf</span>.printf <span class="st">&quot;%d %s  %d</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;</span> y m d</span></code></pre></div>
</div></div></p><p><div class="SIntrapara">You can also destruct a record using let expressions.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> date = { month: <span class="dt">string</span>; day: <span class="dt">int</span>; year: <span class="dt">int</span> } </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> today = {year=<span class="dv">2023</span>;day=<span class="dv">6</span>;month=<span class="st">&quot;Feb&quot;</span>};; </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> {year; day; month} = today <span class="kw">in</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Printf</span>.printf <span class="st">&quot;%d</span><span class="ch">\t</span><span class="st">%s</span><span class="ch">\t</span><span class="st">%d</span><span class="ch">\n</span><span class="st">&quot;</span> year month day;; </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> {year=y; day=d; month=m} = today <span class="kw">in</span> </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Printf</span>.printf <span class="st">&quot;%d</span><span class="ch">\t</span><span class="st">%s</span><span class="ch">\t</span><span class="st">%d</span><span class="ch">\n</span><span class="st">&quot;</span> y m d;;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> date = { month : <span class="dt">string</span>; day : <span class="dt">int</span>; year : <span class="dt">int</span>; }</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> today : date = {month = <span class="st">&quot;Feb&quot;</span>; day = <span class="dv">6</span>; year = <span class="dv">2023</span>}</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="dv">2023</span>    Feb <span class="dv">6</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">unit</span> = ()</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="dv">2023</span>    Feb <span class="dv">6</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">unit</span> = ()</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">Or access any number of fields of the record:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> date = { month: <span class="dt">string</span>; day: <span class="dt">int</span>; year: <span class="dt">int</span> } </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> today = {year=<span class="dv">2023</span>;day=<span class="dv">6</span>;month=<span class="st">&quot;Feb&quot;</span>};; </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> {year} = today <span class="kw">in</span> <span class="dt">Printf</span>.printf <span class="st">&quot;%d</span><span class="ch">\n</span><span class="st">&quot;</span> year;; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> {year =y; day=d} = today <span class="kw">in</span> <span class="dt">Printf</span>.printf <span class="st">&quot;%d</span><span class="ch">\t</span><span class="st">%d</span><span class="ch">\n</span><span class="st">&quot;</span> y d;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> date = { month : <span class="dt">string</span>; day : <span class="dt">int</span>; year : <span class="dt">int</span>; }</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> today : date = {month = <span class="st">&quot;Feb&quot;</span>; day = <span class="dv">6</span>; year = <span class="dv">2023</span>}</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="dv">2023</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">unit</span> = ()</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="dv">2023</span>    <span class="dv">6</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">unit</span> = ()</span></code></pre></div>
</div></p></blockquote></blockquote></div></p><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>Quiz: What is the type of shift?
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> point = {x:<span class="dt">int</span>; y:<span class="dt">int</span>}</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> shift { x=px } = [px]::[]</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="q-rec-1" value="1"/> point -&gt; point list</label></p><p><label class="quiz-option"><input type="radio" name="q-rec-1" value="2" data-correct="true"/> point -&gt; int list list</label></p><p><label class="quiz-option"><input type="radio" name="q-rec-1" value="3"/> int -&gt; point list</label></p><p><label class="quiz-option"><input type="radio" name="q-rec-1" value="55"/> int -&gt; int list list</label></p></blockquote></summary><p>Answer: <span style="font-weight: bold">point -&gt; int list list</span>.
Argument { x=px } is a record with a field x.
We know it is the point.  { x=px }also binds the field x of point to px.
Because x is int, px is also int. If px is int, then [px] is int list
and [px]::[] is an int list list. </p></details></section><section class="SsectionLevel3" id="section 2.21"><h3 class="heading">2.21<span class="stt">&nbsp;</span><a name="(part._.Anonymous_.Functions)"></a>Anonymous Functions<span class="button-group"><a href="#(part._.Anonymous_.Functions)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h3><p><div class="SIntrapara">In OCaml, an anonymous function is a function without a name. It is written
using the keyword <span style="font-weight: bold">fun</span> and is often used when you only need a function briefly. For example:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> x -&gt; x + <span class="dv">3</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">This means: &#8220;a function that takes x and returns x + 3.&#8221; Here, <span style="font-weight: bold">x</span> is the parameter and <span style="font-weight: bold">x+3</span> is the body.
We can apply this anonymous function as:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">fun</span> x -&gt; x + <span class="dv">3</span>) <span class="dv">5</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">8</span></span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">The evaluation and typechecking rules are same as functions.
</div><div class="SIntrapara"><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>Quiz: What is this expression&#8217;s type?
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">fun</span> x y -&gt; x) <span class="dv">2</span> <span class="dv">3</span></span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="q-anon-1" value="1"/> 'a &#8594; 'b</label></p><p><label class="quiz-option"><input type="radio" name="q-anon-1" value="2"/> 'a &#8594; 'b &#8594; 'a</label></p><p><label class="quiz-option"><input type="radio" name="q-anon-1" value="3"/> int &#8594; int &#8594; int</label></p><p><label class="quiz-option"><input type="radio" name="q-anon-1" value="4" data-correct="true"/> int</label></p></blockquote></summary><p>Answer: int.

Type of <span style="font-weight: bold">(fun x y &#8594; x)</span> is <span style="font-weight: bold">&rsquo;a &#8594; &rsquo;b &#8594; &rsquo;a</span>. Because we apply this anonymous
function to arguments <span style="font-weight: bold">2 3</span>, <span style="font-weight: bold">&rsquo;a</span> and <span style="font-weight: bold">&rsquo;b</span> will be restricted to <span style="font-weight: bold">int</span>s. Therefore,
 the return type will be an <span style="font-weight: bold">int</span>. </p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">fun</span> x y -&gt; x) <span class="dv">2</span> <span class="dv">3</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">2</span></span></code></pre></div>
</div></p></blockquote></blockquote></details></div></p><section class="SsectionLevel4" id="section 2.21.1"><h4 class="heading">2.21.1<span class="stt">&nbsp;</span><a name="(part._.Binding_.Functions)"></a>Binding Functions<span class="button-group"><a href="#(part._.Binding_.Functions)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p><div class="SIntrapara">In OCaml, functions are first-class. It means functions are values,
just like integers or strings. So you can:
</div><div class="SIntrapara"><ul><li><p>bind them to variables</p></li><li><p>pass them as arguments</p></li><li><p>return them from other functions</p></li><li><p>give them new names</p></li></ul></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f x = x + <span class="dv">3</span>;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> g = f;; </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> g <span class="dv">5</span>;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> f : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> g : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">8</span></span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">In fact, <span style="font-weight: bold">let</span> for functions is a syntactic shorthand.
<span style="font-weight: bold">let f x = body</span> is semantically equivalent to
<span style="font-weight: bold">let f = fun x -&gt;  body</span>. For example:</div></p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> next x = x + <span class="dv">1</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">(* is the short for *)</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> next = <span class="kw">fun</span> x -&gt; x + <span class="dv">1</span></span></code></pre></div>
</div></p><p><div class="SIntrapara">and,
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> plus x y = x + y</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">(* is the short for *)</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> plus = <span class="kw">fun</span> x y -&gt; x + y</span></code></pre></div>
</div>
Here is another example:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f = <span class="kw">fun</span> x y -&gt; x * y <span class="kw">in</span> f <span class="dv">10</span> <span class="dv">20</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">200</span></span></code></pre></div>
</div></p></blockquote></blockquote></div></p><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>Quiz: What does this evaluate to?
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f = <span class="kw">fun</span> x -&gt; <span class="dv">0</span> <span class="kw">in</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> g = f <span class="kw">in</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> h = <span class="kw">fun</span> y -&gt; g (y+<span class="dv">1</span>) <span class="kw">in</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>h <span class="dv">1</span>;;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="q-anon-2" value="1" data-correct="true"/> 0</label></p><p><label class="quiz-option"><input type="radio" name="q-anon-2" value="2"/> 1</label></p><p><label class="quiz-option"><input type="radio" name="q-anon-2" value="3"/> 2</label></p><p><label class="quiz-option"><input type="radio" name="q-anon-2" value="4"/> error</label></p></blockquote></summary><p>Answer: 0.
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>h <span class="dv">1</span> =</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>(<span class="kw">fun</span> y -&gt; g (y+<span class="dv">1</span>)) <span class="dv">1</span> =</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>g (<span class="dv">1</span>+<span class="dv">1</span>) = </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>g <span class="dv">2</span> = </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>f <span class="dv">2</span> = </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>(<span class="kw">fun</span> x -&gt; <span class="dv">0</span>) <span class="dv">2</span> = </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="dv">0</span></span></code></pre></div>
</div></p></details></section></section><section class="SsectionLevel3" id="section 2.22"><h3 class="heading">2.22<span class="stt">&nbsp;</span><a name="(part._.Higher_.Order_.Functions)"></a>Higher Order Functions<span class="button-group"><a href="#(part._.Higher_.Order_.Functions)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h3><p><div class="SIntrapara">In OCaml, a function can take other functions as arguments or return them as results.
 Such functions are called higher-order functions. This works because functions in
 OCaml are first-class values&#8212;you can pass them around just like integers,
 strings, or lists.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> plus3 x = x + <span class="dv">3</span>;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> twice f z = f (f z);; </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> twice plus3 <span class="dv">5</span>;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> plus3 : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> twice : (&#39;a -&gt; &#39;a) -&gt; &#39;a -&gt; &#39;a = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">11</span></span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">In this example, we pass the function <span style="font-weight: bold">plus3</span> as an argument to the function <span style="font-weight: bold">twice</span>.
The function <span style="font-weight: bold">twice</span> then applies <span style="font-weight: bold">plus3</span> to 5 two times as shown below:
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>twice plus3 <span class="dv">5</span> =</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>plus3 (plus3 <span class="dv">5</span>) =</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>plus3 <span class="dv">8</span> =</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="dv">11</span></span></code></pre></div>
</div></div></p><section class="SsectionLevel4" id="section 2.22.1"><h4 class="heading">2.22.1<span class="stt">&nbsp;</span><a name="(part._.Map)"></a>Map<span class="button-group"><a href="#(part._.Map)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>OCaml&#8217;s <span style="font-weight: bold">map</span> is a higher-order function.
It takes a function <span style="font-weight: bold">f</span> and a list <span style="font-weight: bold">lst</span>, applies
<span style="font-weight: bold">f</span> to each element of <span style="font-weight: bold">lst</span>, and returns a new list of the
results while <span style="font-weight: bold">preserving the original order</span>. The <span style="font-weight: bold">map</span>
function is defined in the <span style="font-weight: bold">List</span> module, so you can either
write <span style="font-weight: bold">open List</span> first or call it as <span style="font-weight: bold">List.map</span>.</p><p><div class="SIntrapara">In the following example, <span style="font-weight: bold">map</span> applies <span style="font-weight: bold">add_one</span> to each
element of the list <span style="font-weight: bold">[1;2;3]</span>.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> add_one x = x + <span class="dv">1</span>;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="dt">List</span>.map add_one [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>];;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> add_one : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">4</span>]</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">In the following example, <span style="font-weight: bold">map</span> applies <span style="font-weight: bold">negate</span> to each element of the list <span style="font-weight: bold">[9; -5; 0]</span>.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> negate x = -x;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="dt">List</span>.map negate [<span class="dv">9</span>; <span class="dv">-5</span>; <span class="dv">0</span>];;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> negate : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">-9</span>; <span class="dv">5</span>; <span class="dv">0</span>]</span></code></pre></div>
</div></p></blockquote></blockquote></div></p><section class="SsectionLevel5" id="section 2.22.1.1"><h5 class="heading">2.22.1.1<span class="stt">&nbsp;</span><a name="(part._.Implementing_map)"></a>Implementing map<span class="button-group"><a href="#(part._.Implementing_map)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> map f l = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> l <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    [] -&gt; [] </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    | h::t -&gt; (f h)::(map f t);;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> map : (&#39;a -&gt; &#39;b) -&gt; &#39;a <span class="dt">list</span> -&gt; &#39;b <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote><p>What is the type of <span style="font-weight: bold">map</span>?</p><p><span style="font-weight: bold">map</span> takes two arguments, so its type must look like
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>(type_of_f) -&gt; (type_of_lst) -&gt; type_of_return</span></code></pre></div>
</div></p><p>The function <span style="font-weight: bold">f</span> can take any type as input and return any
type, so its type is <span style="font-weight: bold">&rsquo;a -&gt; &rsquo;b</span>. From the expression <span style="font-weight: bold">f h</span>,
we know that <span style="font-weight: bold">h</span> must have type <span style="font-weight: bold">&rsquo;a</span>. From the expression
<span style="font-weight: bold">(f h) :: (map f t)</span>, we know the result is a list whose elements
have the type of <span style="font-weight: bold">f h</span>, namely <span style="font-weight: bold">&rsquo;b list</span>.</p><p>Putting this all together, the type of <span style="font-weight: bold">map</span> is:
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>(&#39;a -&gt; &#39;b) -&gt; &#39;a <span class="dt">list</span> -&gt; &#39;b <span class="dt">list</span></span></code></pre></div>
</div></p><p><div class="SIntrapara">Example: square every number in a list:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">List</span>.map (<span class="kw">fun</span> x -&gt; x * x) [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">4</span>]</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>Line <span class="dv">1</span>, characters <span class="dv">38-38</span>:</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>Error: Syntax error</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">Example: Compute the length of strings in a list:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">List</span>.map <span class="dt">String</span>.length [<span class="st">&quot;cat&quot;</span>; <span class="st">&quot;elephant&quot;</span>; <span class="st">&quot;hi&quot;</span>]</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>Line <span class="dv">1</span>, characters <span class="dv">48-48</span>:</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>Error: Syntax error</span></code></pre></div>
</div></p></blockquote></blockquote></div></p><p>Let us look at another example:
Apply a list of functions <span style="font-weight: bold">neg</span>, <span style="font-weight: bold">add_one</span>, and <span style="font-weight: bold">double</span> to a list of ints.</p><p><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> neg x = -x;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> add_one x = x+<span class="dv">1</span>;; </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> double x = x + x;; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> fs = [neg; add_one; double];; <span class="co">(* (int -&gt; int) list *)</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> lst = [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>];; </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> <span class="dt">List</span>.map (<span class="kw">fun</span> f-&gt; <span class="dt">List</span>.map f lst) fs;;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> neg : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> add_one : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> double : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> fs : (<span class="dt">int</span> -&gt; <span class="dt">int</span>) <span class="dt">list</span> = [&lt;<span class="kw">fun</span>&gt;; &lt;<span class="kw">fun</span>&gt;; &lt;<span class="kw">fun</span>&gt;]</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> lst : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>]</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> <span class="dt">list</span> = [[<span class="dv">-1</span>; <span class="dv">-2</span>; <span class="dv">-3</span>]; [<span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">4</span>]; [<span class="dv">2</span>; <span class="dv">4</span>; <span class="dv">6</span>]]</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">In the above example, the outer <span style="font-weight: bold">map</span> applies the anonymous function to each element of the function list <span style="font-weight: bold">fs</span>.
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>map (<span class="kw">fun</span> f-&gt; map f [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>]) fs =</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>map (<span class="kw">fun</span> f-&gt; map f [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>]) [neg; add_one; double] =</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>((<span class="kw">fun</span> f-&gt; map f [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>]) neg) :: map (<span class="kw">fun</span> f-&gt; map f [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>]) [add_one; double] =</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>[<span class="dv">-1</span>; <span class="dv">-2</span>; <span class="dv">-3</span>]::map (<span class="kw">fun</span> f-&gt; map f [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>]) [add_one; double] =</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>[<span class="dv">-1</span>; <span class="dv">-2</span>; <span class="dv">-3</span>]::((<span class="kw">fun</span> f-&gt; map f [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>]) add_one) :: map (<span class="kw">fun</span> f-&gt; map f [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>]) [double] =</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>[<span class="dv">-1</span>; <span class="dv">-2</span>; <span class="dv">-3</span>]::[<span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">4</span>]::map (<span class="kw">fun</span> f-&gt; map f [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>]) [double] =</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>[<span class="dv">-1</span>; <span class="dv">-2</span>; <span class="dv">-3</span>]::[<span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">4</span>]::((<span class="kw">fun</span> f-&gt; map f [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>]) double) ::map (<span class="kw">fun</span> f-&gt; map f [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>]) []=</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>[<span class="dv">-1</span>; <span class="dv">-2</span>; <span class="dv">-3</span>]::[<span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">4</span>]::[<span class="dv">2</span>; <span class="dv">4</span>; <span class="dv">6</span>]::[]</span></code></pre></div>
</div></div></p></section></section><section class="SsectionLevel4" id="section 2.22.2"><h4 class="heading">2.22.2<span class="stt">&nbsp;</span><a name="(part._.Fold)"></a>Fold<span class="button-group"><a href="#(part._.Fold)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p><div class="SIntrapara">Fold is a higher order function that takes a function of two arguments, an initial value,
and a list. It processes the list by applying the function to the first element and the result of recursively
applying fold to the rest of the list, and returns the initial value for the empty list.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> fold f a l = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> l <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>      [] -&gt; a </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    | h::t -&gt; fold f (f a h) t;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> fold : (&#39;a -&gt; &#39;b -&gt; &#39;a) -&gt; &#39;a -&gt; &#39;b <span class="dt">list</span> -&gt; &#39;a = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></div></p><p>For example:
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> add x y = x + y</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>fold add <span class="dv">0</span>             [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>] =</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>fold add (add <span class="dv">0</span> <span class="dv">1</span>)     [<span class="dv">2</span>; <span class="dv">3</span>] =</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>fold add <span class="dv">1</span>             [<span class="dv">2</span>; <span class="dv">3</span>] =</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>fold add (add <span class="dv">1</span> <span class="dv">2</span>)     [<span class="dv">3</span>] =</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>fold add <span class="dv">3</span>             [<span class="dv">3</span>] =</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>fold add (add <span class="dv">3</span> <span class="dv">3</span>)     [] =</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>fold add <span class="dv">6</span>            [] =</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="dv">6</span>  <span class="co">(* 1 + 2 + 3 *)</span> =</span></code></pre></div>
</div></p><p>What does fold do?
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>fold f        v        [v1; v2; â€¦; vn] =</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>fold f    (f v v1)     [v2; â€¦; vn] =</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>fold f (f (f v v1) v2)  [â€¦; vn]=</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>â€¦ =</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>f (f (f (f v v1) v2) â€¦) vn</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co">(* example *)</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>fold add <span class="dv">0</span> [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>;<span class="dv">4</span>] = </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>      add (add (add (add <span class="dv">0</span> <span class="dv">1</span>) <span class="dv">2</span>) <span class="dv">3</span>) <span class="dv">4</span> = <span class="dv">10</span></span></code></pre></div>
</div></p><p>We can use <span style="font-weight: bold">fold</span> to build list reverse function.
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> prepend a x = x::a;;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>fold prepend [] [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">4</span>] =</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>fold prepend [<span class="dv">1</span>] [<span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">4</span>] =</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>fold prepend [<span class="dv">2</span>; <span class="dv">1</span>] [<span class="dv">3</span>; <span class="dv">4</span>] =</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>fold prepend [<span class="dv">3</span>; <span class="dv">2</span>; <span class="dv">1</span>] [<span class="dv">4</span>] =</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>fold prepend [<span class="dv">4</span>; <span class="dv">3</span>; <span class="dv">2</span>; <span class="dv">1</span>] [] =</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>[<span class="dv">4</span>; <span class="dv">3</span>; <span class="dv">2</span>; <span class="dv">1</span>]</span></code></pre></div>
</div></p><p><div class="SIntrapara">The <span style="font-weight: bold">fold</span> function is implemented in OCaml List module as <span style="font-weight: bold">List.fold_left</span>. OCaml List
module also provides another implementation of fold called <span style="font-weight: bold">fold_right</span>, which processes
the list from tail to head.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> fold_right f l a = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> l <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>      [] -&gt; a </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    | h::t -&gt; f h (fold_right f t a);;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> fold_right : (&#39;a -&gt; &#39;b -&gt; &#39;b) -&gt; &#39;a <span class="dt">list</span> -&gt; &#39;b -&gt; &#39;b = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></div></p><p><div class="SIntrapara">Depending on the function, the <span style="font-weight: bold">fold_left</span> and <span style="font-weight: bold">fold_right</span> may yield different results.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">List</span>.fold_left (<span class="kw">fun</span> x y -&gt; x - y) <span class="dv">0</span> [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>];;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">-6</span></span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">The result is -6 because ((0-1)-2)-3 = -6.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">List</span>.fold_right  (<span class="kw">fun</span> x y -&gt; x - y) [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>] <span class="dv">0</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">2</span></span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">The result is 2 because 1-(2-(3-0)) = 2</div></p><p>When should we use <span style="font-weight: bold">fold_left</span> versus <span style="font-weight: bold">fold_right</span>?
Many problems are naturally expressed with <span style="font-weight: bold">fold_right</span>, but it
 has a performance drawback: it creates a deep call stack, with
 one frame per recursive call. By contrast, <span style="font-weight: bold">fold_left</span> can be
 optimized through tail recursion, allowing it to run without
 consuming additional stack space.</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* Product of an int list *)</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> mul x y = x * y;; </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> lst = [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">4</span>; <span class="dv">5</span>];; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> <span class="dt">List</span>.fold_left mul <span class="dv">1</span> lst;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> mul : <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> lst : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">4</span>; <span class="dv">5</span>]</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">120</span></span></code></pre></div>
</div></p></blockquote></blockquote><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* Collect even numbers in the list *)</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> f acc y = <span class="kw">if</span> (y <span class="kw">mod</span> <span class="dv">2</span>) = <span class="dv">0</span> <span class="kw">then</span> y::acc </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>                <span class="kw">else</span> acc;; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> <span class="dt">List</span>.fold_left f [] [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>;<span class="dv">4</span>;<span class="dv">5</span>;<span class="dv">6</span>];;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> f : <span class="dt">int</span> <span class="dt">list</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">6</span>; <span class="dv">4</span>; <span class="dv">2</span>]</span></code></pre></div>
</div></p></blockquote></blockquote><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* Count elements of a list satisfying a condition *)</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> countif p l = </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="dt">List</span>.fold_left (<span class="kw">fun</span> counter element -&gt; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>         <span class="kw">if</span> p element <span class="kw">then</span> counter+<span class="dv">1</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>         <span class="kw">else</span> counter) <span class="dv">0</span> l ;; </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a> countif (<span class="kw">fun</span> x -&gt; x &gt; <span class="dv">0</span>) [<span class="dv">30</span>;<span class="dv">-1</span>;<span class="dv">45</span>;<span class="dv">100</span>;<span class="dv">0</span>];;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> countif : (&#39;a -&gt; <span class="dt">bool</span>) -&gt; &#39;a <span class="dt">list</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">3</span></span></code></pre></div>
</div></p></blockquote></blockquote><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* Permute a list *)</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> permute lst = </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">rec</span> rm x l = <span class="dt">List</span>.filter ((&lt;&gt;) x) l </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">and</span> insertToPermute lst x = </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> t = rm x lst <span class="kw">in</span> </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>      <span class="dt">List</span>.map ((<span class="kw">fun</span> a b-&gt;a::b) x )(permuteall t) </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">and</span> permuteall lst = </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>      <span class="kw">match</span> lst <span class="kw">with</span> </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>      |[]-&gt;[] </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>      |[x]-&gt;[[x]] </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>      |_-&gt;<span class="dt">List</span>.flatten(<span class="dt">List</span>.map (insertToPermute lst) lst) </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span> permuteall lst;; </span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>   permute [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>];;</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> permute : &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> <span class="dt">list</span> =</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>[[<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>]; [<span class="dv">1</span>; <span class="dv">3</span>; <span class="dv">2</span>]; [<span class="dv">2</span>; <span class="dv">1</span>; <span class="dv">3</span>]; [<span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">1</span>]; [<span class="dv">3</span>; <span class="dv">1</span>; <span class="dv">2</span>]; [<span class="dv">3</span>; <span class="dv">2</span>; <span class="dv">1</span>]]</span></code></pre></div>
</div></p></blockquote></blockquote><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">(* Power Set *)</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> populate a b =</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> b=[] <span class="kw">then</span> [[a]]</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">else</span>  <span class="kw">let</span> t = <span class="dt">List</span>.map (<span class="kw">fun</span> x-&gt;a::x) b <span class="kw">in</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        [a]::t @ b</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> powerset lst = <span class="dt">List</span>.fold_right populate lst [];;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>powerset [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>];;</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> populate : &#39;a -&gt; &#39;a <span class="dt">list</span> <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> powerset : &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> <span class="dt">list</span> = [[<span class="dv">1</span>]; [<span class="dv">1</span>; <span class="dv">2</span>]; [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>]; [<span class="dv">1</span>; <span class="dv">3</span>]; [<span class="dv">2</span>]; [<span class="dv">2</span>; <span class="dv">3</span>]; [<span class="dv">3</span>]]</span></code></pre></div>
</div></p></blockquote></blockquote><p><span style="font-weight: bold">Inner Product</span>: given two lists of same size <span class="texMathInline">[x_1;x_2;..x_n]</span> and <span class="texMathInline">[y_1;y_2;...y_n]</span>, compute
<span class="texMathInline">[x_1;x_2;x_3]&#8727;[y_1;y_2;y_3] = x_1&#8727;y_1 + x_2&#8727;y_2 +..+ x_n&#8727;y_n</span></p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> map2 f a b = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>      <span class="kw">match</span> (a,b) <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>      |([],[])-&gt;([]) </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>      |(h1::t1,h2::t2)-&gt;(f h1 h2):: (map2 f t1 t2) </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>      |_-&gt;<span class="dt">invalid_arg</span> <span class="st">&quot;map2&quot;</span>;; </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> product v1 v2 = </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">List</span>.fold_left (+) <span class="dv">0</span> (map2 ( * ) v1 v2);; </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a> product [<span class="dv">2</span>;<span class="dv">4</span>;<span class="dv">6</span>] [<span class="dv">1</span>;<span class="dv">3</span>;<span class="dv">5</span>];;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> map2 : (&#39;a -&gt; &#39;b -&gt; &#39;c) -&gt; &#39;a <span class="dt">list</span> -&gt; &#39;b <span class="dt">list</span> -&gt; &#39;c <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> product : <span class="dt">int</span> <span class="dt">list</span> -&gt; <span class="dt">int</span> <span class="dt">list</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">44</span></span></code></pre></div>
</div></p></blockquote></blockquote><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>   <span class="co">(* Find the maximum from a list *)</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> maxList lst = </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>      <span class="kw">match</span> lst <span class="kw">with</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>       []-&gt;<span class="dt">failwith</span> <span class="st">&quot;empty list&quot;</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>      |h::t-&gt; <span class="dt">List</span>.fold_left <span class="dt">max</span> h t ;; </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a> maxList [<span class="dv">3</span>;<span class="dv">10</span>;<span class="dv">5</span>];; </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a> <span class="co">(* </span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co"> maxList [3;10;5] </span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="co"> fold max 3 [10;5] </span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="co"> fold max (max 3 10) [5] </span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="co"> fold max (max 10 5) [] </span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="co"> fold max 10 [] </span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="co"> 10*)</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> maxList : &#39;a <span class="dt">list</span> -&gt; &#39;a = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">10</span></span></code></pre></div>
</div></p></blockquote></blockquote><p><div class="SIntrapara">Sum of sublists: Given a list of int lists, compute the sum of each int list, and return them as list.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> sumList  = <span class="dt">List</span>.map (<span class="dt">List</span>.fold_left (+) <span class="dv">0</span> );; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> sumList [[<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>];[<span class="dv">4</span>;<span class="dv">5</span>;<span class="dv">6</span>];[<span class="dv">10</span>]];;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> sumList : <span class="dt">int</span> <span class="dt">list</span> <span class="dt">list</span> -&gt; <span class="dt">int</span> <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">6</span>; <span class="dv">15</span>; <span class="dv">10</span>]</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">Maximum contiguous sublist: Given an int list, find the contiguous sublist, which has the largest sum and return its sum.</div></p><p><div class="SIntrapara">Example:
    Input: [-2,1,-3,4,-1,2,1,-5,4]
    Output: 6
    Explanation: [4,-1,2,1] has the largest sum = 6
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> f (m, acc) h = </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>     <span class="kw">let</span> m = <span class="dt">max</span> m (acc + h) <span class="kw">in</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>     <span class="kw">let</span>  x = <span class="kw">if</span> acc &lt; <span class="dv">0</span> <span class="kw">then</span> <span class="dv">0</span> <span class="kw">else</span> acc <span class="kw">in</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>     (m, x+h) </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> ;; </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> submax  lst = <span class="kw">let</span> (max_so_far, max_current) = </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>          <span class="dt">List</span>.fold_left f (<span class="dv">0</span>,<span class="dv">0</span>) lst <span class="kw">in</span> </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>          max_so_far;; </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a> submax [<span class="dv">-2</span>; <span class="dv">1</span>; <span class="dv">-3</span>; <span class="dv">4</span>; <span class="dv">-1</span>; <span class="dv">2</span>; <span class="dv">1</span>; <span class="dv">-5</span>; <span class="dv">4</span>];;</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> f : <span class="dt">int</span> * <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> * <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> submax : <span class="dt">int</span> <span class="dt">list</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">6</span></span></code></pre></div>
</div></p></blockquote></blockquote></div></p></section><section class="SsectionLevel4" id="section 2.22.3"><h4 class="heading">2.22.3<span class="stt">&nbsp;</span><a name="(part._.Filter)"></a>Filter<span class="button-group"><a href="#(part._.Filter)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p><span style="font-weight: bold">List.filter</span> is a higher-order function that takes a predicate (a function returning <span style="font-weight: bold">bool</span>) and a list, and returns a new list containing only the elements for which the predicate returns <span style="font-weight: bold">true</span>.</p><p><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* filter the positive numbers *)</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="dt">List</span>.filter (<span class="kw">fun</span> x -&gt; x &gt; <span class="dv">0</span>) [<span class="dv">-3</span>; <span class="dv">1</span>; <span class="dv">-5</span>; <span class="dv">4</span>; <span class="dv">0</span>; <span class="dv">7</span>];;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">1</span>; <span class="dv">4</span>; <span class="dv">7</span>]</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* filter the even numbers *)</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="dt">List</span>.filter (<span class="kw">fun</span> x -&gt; x <span class="kw">mod</span> <span class="dv">2</span> = <span class="dv">0</span>) [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">4</span>; <span class="dv">5</span>; <span class="dv">6</span>];;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">2</span>; <span class="dv">4</span>; <span class="dv">6</span>]</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* filter the true values *)</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="dt">List</span>.filter (<span class="kw">fun</span> x-&gt;x) [<span class="kw">false</span>;<span class="kw">true</span>;<span class="kw">false</span>;<span class="kw">true</span>; <span class="dv">20</span> &gt; <span class="dv">10</span>];;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">bool</span> <span class="dt">list</span> = [<span class="kw">true</span>; <span class="kw">true</span>; <span class="kw">true</span>]</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">We can implement <span style="font-weight: bold">filter</span> as follows:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> filter f l = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> l <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    | [] -&gt; [] </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    | h::t -&gt; <span class="kw">if</span> f h <span class="kw">then</span> h :: (filter f t) </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>               <span class="kw">else</span> filter f t;; </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a> filter (<span class="kw">fun</span> x -&gt; x &gt; <span class="dv">3</span>) [<span class="dv">1</span>; <span class="dv">5</span>; <span class="dv">2</span>; <span class="dv">8</span>; <span class="dv">3</span>];;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> filter : (&#39;a -&gt; <span class="dt">bool</span>) -&gt; &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">5</span>; <span class="dv">8</span>]</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">The type of <span style="font-weight: bold">filter</span> is:
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>(&#39;a -&gt; <span class="dt">bool</span>) -&gt; &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span></span></code></pre></div>
</div></div></p></section></section><section class="SsectionLevel3" id="section 2.23"><h3 class="heading">2.23<span class="stt">&nbsp;</span><a name="(part._.Tail_.Recursion)"></a>Tail Recursion<span class="button-group"><a href="#(part._.Tail_.Recursion)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>Whenever a function&#8217;s result is completely computed by its recursive call, it
is called tail recursive. Its &#8220;tail&#8221; &#8211; the last thing it does &#8211; is recursive.</p><p>Tail recursive functions can be implemented without requiring a stack frame for each call
No intermediate variables need to be saved, so the compiler overwrites them</p><p>Typical pattern is to use an accumulator to build up the result, and return it in the base case.</p><p><div class="SIntrapara">We have seen the recursive factorial function
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> fact  n = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> n = <span class="dv">0</span> <span class="kw">then</span> <span class="dv">1</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>      <span class="kw">else</span> n * fact (n<span class="dv">-1</span>);; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> fact <span class="dv">4</span>;;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> fact : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">24</span></span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">Now, let us look at how <span style="font-weight: bold">fact 3</span> is executed:
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>fact <span class="dv">3</span> = <span class="dv">3</span> * fact <span class="dv">2</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>       = <span class="dv">3</span> * <span class="dv">2</span> * fact <span class="dv">1</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>       = <span class="dv">3</span> * <span class="dv">2</span> * <span class="dv">1</span> * fact <span class="dv">0</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>       = <span class="dv">3</span> * <span class="dv">2</span> * <span class="dv">1</span> * <span class="dv">1</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>       = <span class="dv">3</span> * <span class="dv">2</span> * <span class="dv">1</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>       = <span class="dv">3</span> * <span class="dv">2</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>       = <span class="dv">6</span>   </span></code></pre></div>
</div>
As shown below, each recursive call to the <span style="font-weight: bold">fact</span> function will
create a new stack frame in the memory.
<img src="factorial.png" alt="" width="310" height="175"/></div></p><p>As such, if the recursion is deep, it can cause <span style="font-weight: bold">Stack overflow</span> error. For example:
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> sum n = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> n = <span class="dv">0</span> <span class="kw">then</span> <span class="dv">0</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">else</span> n + sum (n<span class="dv">-1</span>);;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> sum <span class="dv">100000000</span>;;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> - <span class="dt">Stack</span> overflow during evaluation (looping recursion?).</span></code></pre></div>
</div></p><p>Now, let us look at another implementation of the factorial function</p><p><img src="factorial_tail.png" alt="" width="302" height="75"/></p><p><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> fact n = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">rec</span> aux x a = </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> x = <span class="dv">0</span> <span class="kw">then</span> a </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>      <span class="kw">else</span> aux (x<span class="dv">-1</span>) (x*a) </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span> </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    aux n <span class="dv">1</span>;;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> fact : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">Here is the execution of <span style="font-weight: bold">fact 3</span></div></p><p><img src="factorial_tail_stack.png" alt="" width="327" height="228"/></p><p>In the first implementation of the factorial, it makes recursive calls
<span style="font-weight: bold">fact (n-1)</span>, and then it takes the return value of the recursive call
 and calculate the result <span style="font-weight: bold">n * fact (n-1)</span>. In this manner, you don&rsquo;t
 get the result of your calculation until you have returned from every
 recursive call.</p><p>In the second implementation, it carries an accumulator <span style="font-weight: bold">a</span>. It performs
 calculation first, and then you execute the recursive call, passing the
 results of the current step to the next recursive step. This results in
  the last statement being in the form of <span style="font-weight: bold">(return (recursive-function params))</span>.
  Basically, the return value of the last recursive call is the
  final result. The consequence of this is that when you perform the next
  recursive call, you do not need the current stack frame any more.</p><p>As shown above, in the last recursive call to <span style="font-weight: bold">fact 0</span>, it returns the
result of <span style="font-weight: bold">fact 3</span>. Therefore, we do not need all the stack frames for the
previous recursive calls. This allows for some optimization. Some compilers
can optimize the tail recursive calls to use only the current stack frame.
This is called <span style="font-weight: bold">tail recursion optimization</span>. Functional programming language
compilers usually optimize the tail recursive calls because recursion is the
only way to achieve repetition.</p><p><div class="SIntrapara">Let us compare the two implementations of factorial again:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* Waits for recursive callâ€™s result to compute final result *)</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> <span class="kw">rec</span> fact n = </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> n = <span class="dv">0</span> <span class="kw">then</span> <span class="dv">1</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>      <span class="kw">else</span> n * fact (n<span class="dv">-1</span>);;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> fact : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* final result is the result of the recursive call *)</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">let</span> fact n = </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>     <span class="kw">let</span> <span class="kw">rec</span> aux x acc = </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>       <span class="kw">if</span> x = <span class="dv">0</span> <span class="kw">then</span> acc </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>       <span class="kw">else</span> aux (x<span class="dv">-1</span>) (acc*x) </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>     <span class="kw">in</span> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    aux n <span class="dv">1</span>;;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> fact : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">Tail-recursive Sum of List
 </div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">(* non-tail recursive *)</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">let</span> <span class="kw">rec</span> sumlist l = </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>     <span class="kw">match</span> l <span class="kw">with</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>       [] -&gt; <span class="dv">0</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>     | (x::xs) -&gt; (sumlist xs) + x </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> ;; </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>   <span class="co">(* Tail-recursive version: *)</span> </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>   <span class="kw">let</span> sumlist l = </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>     <span class="kw">let</span> <span class="kw">rec</span> helper l a = </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>       <span class="kw">match</span> l <span class="kw">with</span> </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>         [] -&gt; a </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>       | (x::xs) -&gt; helper xs (x+a) <span class="kw">in</span> </span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>   helper l <span class="dv">0</span>;;</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> sumlist : <span class="dt">int</span> <span class="dt">list</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> sumlist : <span class="dt">int</span> <span class="dt">list</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></div></p><section class="SsectionLevel4" id="section 2.23.1"><h4 class="heading">2.23.1<span class="stt">&nbsp;</span><a name="(part._fold_left_vs_fold_right)"></a>fold_left vs fold_right<span class="button-group"><a href="#(part._fold_left_vs_fold_right)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p><div class="SIntrapara">The <span style="font-weight: bold">fold_left</span> is tail recursive and the <span style="font-weight: bold">fold_right</span> is not tail recursive.
 The following examples calculates the sum of <span style="font-weight: bold">100000000</span> integers.
 The <span style="font-weight: bold">fold_left</span> returns the correct result, but <span style="font-weight: bold">fold_right</span> raises
 a <span style="font-weight: bold">Stack overflow</span> error.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">List</span>.fold_left (+) <span class="dv">0</span> (<span class="dt">List</span>.init <span class="dv">100000000</span> (<span class="kw">fun</span> _-&gt;<span class="dv">1</span>));;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">100000000</span></span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">List</span>.fold_right (+) (<span class="dt">List</span>.init <span class="dv">100000000</span> (<span class="kw">fun</span> _-&gt;<span class="dv">1</span>)) <span class="dv">0</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="dt">Stack</span> overflow during evaluation (looping recursion?).</span></code></pre></div>
</div></p></blockquote></blockquote></div></p><p>Why? Let us look at the implementation of <span style="font-weight: bold">fold_left</span> and <span style="font-weight: bold">fold_right</span>.
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> fold_left f a l =</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    [] -&gt; a</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  | h::t -&gt; fold_left f (f a h) t</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>fold_left (+) <span class="dv">0</span> [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>fold_left (+) <span class="dv">1</span> [<span class="dv">2</span>;<span class="dv">3</span>]</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>fold_left (+) <span class="dv">3</span> [<span class="dv">3</span>]</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>fold_left (+) <span class="dv">6</span> []</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="dv">6</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> fold_right f l a =</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    [] -&gt; a</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>  | h::t -&gt; f h (fold_right f t a)</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>fold_right (+) [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>] <span class="dv">0</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> + (fold_right (+) [<span class="dv">2</span>;<span class="dv">3</span>] <span class="dv">0</span>)</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> + (<span class="dv">2</span> + (fold_right (+) [<span class="dv">3</span>] <span class="dv">0</span>))</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> + (<span class="dv">2</span> + (<span class="dv">3</span> + (fold_right (+) [] <span class="dv">0</span>)))</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> + (<span class="dv">2</span> + ( <span class="dv">3</span> + <span class="dv">0</span>))</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> + (<span class="dv">2</span> + <span class="dv">3</span>)</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> + <span class="dv">5</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a><span class="dv">6</span></span></code></pre></div>
</div>
For <span style="font-weight: bold">fold_left</span>, the call to <span style="font-weight: bold">fold_left</span> is in the form of <span style="font-weight: bold">(return
(recursive-function params))</span>.  There is no operation after the recursive call returns.
 However, for <span style="font-weight: bold">fold_right</span>, after the recursive call to <span style="font-weight: bold">fold_right</span> returns, we still
 need to perform the <span style="font-weight: bold">f h (recursive_call_return)</span>. We need to keep the current stack frame
  before calling the next recursive call. Therefore, <span style="font-weight: bold">fold_right</span> is not tail recursive
  and cannot be optimized.</p></section><section class="SsectionLevel4" id="section 2.23.2"><h4 class="heading">2.23.2<span class="stt">&nbsp;</span><a name="(part._.Tail_.Recursion_.Pattern)"></a>Tail Recursion Pattern<span class="button-group"><a href="#(part._.Tail_.Recursion_.Pattern)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p><div class="SIntrapara">Non-tail-recursive functions can often be transformed into tail-recursive ones by following this pattern:
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> func x =</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> helper arg acc =</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> (base case) <span class="kw">then</span> acc</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> arg&#39; = <span class="co">(* argument to recursive call *)</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> acc&#39; = helper arg&#39; acc&#39; <span class="kw">in</span> <span class="co">(* end of helper fun *)</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span> </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  helper x;; <span class="co">(* initial val of accumulator *)</span></span></code></pre></div>
</div>
We now apply this pattern to obtain a tail-recursive version of
the factorial function.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> fact x = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">rec</span> helper arg acc = </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> arg = <span class="dv">0</span> <span class="kw">then</span> acc </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>      <span class="kw">else</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> arg&#39; = arg - <span class="dv">1</span> <span class="kw">in</span> </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> acc&#39; = acc * arg <span class="kw">in</span> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>        helper arg&#39; acc&#39; <span class="kw">in</span> <span class="co">(* end of helper fun *)</span> </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    helper x <span class="dv">1</span>;;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> fact : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">The list reverse function rev can be written in a tail-recursive form as follows:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> rev x = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">rec</span> rev_helper arg acc = </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>      <span class="kw">match</span> arg <span class="kw">with</span> [] -&gt; acc </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>      | h::t -&gt; </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> arg&#39; = t <span class="kw">in</span> </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> acc&#39; = h::acc <span class="kw">in</span> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>        rev_helper arg&#39; acc&#39; <span class="kw">in</span> <span class="co">(* end of helper fun *)</span> </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    rev_helper x [];;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> rev : &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara"><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>Quiz: <span class="stt">map</span> is tail-recursive.</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> map f = <span class="kw">function</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  [] -&gt; []</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>| (h::t) -&gt; (f h)::(map f t)</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="quiz-1" value="true"/> True</label></p><p><label class="quiz-option"><input type="radio" name="quiz-1" value="false" data-correct="true"/> False</label></p></blockquote></summary><p>Answer: False. The recursive call <span class="stt">map f t</span> is not in tail position &#8212;<wbr></wbr> it is an argument to <span class="stt">::</span>. The cons operation <span class="stt">(f h) :: (map f t)</span> must wait for the recursive call to return before it can construct the result.</p></details></div></p><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>Quiz: <span class="stt">fold</span> is tail-recursive.</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> fold f a = <span class="kw">function</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  [] -&gt; a</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>| (h::t) -&gt; fold f (f a h) t</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="quiz-2" value="true" data-correct="true"/> True</label></p><p><label class="quiz-option"><input type="radio" name="quiz-2" value="false"/> False</label></p></blockquote></summary><p>Answer: True. The recursive call <span class="stt">fold f (f a h) t</span> is the last operation &#8212;<wbr></wbr> it is in tail position. The accumulator <span class="stt">(f a h)</span> is computed before the recursive call.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>Quiz: <span class="stt">fold_right</span> is tail-recursive.</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> fold_right f l a =</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    [] -&gt; a</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  | (h::t) -&gt; f h (fold_right f t a)</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="quiz-3" value="true"/> True</label></p><p><label class="quiz-option"><input type="radio" name="quiz-3" value="false" data-correct="true"/> False</label></p></blockquote></summary><p>Answer: False. The recursive call <span class="stt">fold_right f t a</span> is not in tail position &#8212;<wbr></wbr> it is an argument to <span class="stt">f</span>. The function <span class="stt">f</span> must wait for the recursive call to return before it can be applied.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>Quiz: This is a correct tail-recursive <span class="stt">map</span>.</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> map f l =</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> helper l a =</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>      [] -&gt; a</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    | h::t -&gt; helper t ((f h)::a)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span> helper l []</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="quiz-4" value="true"/> True</label></p><p><label class="quiz-option"><input type="radio" name="quiz-4" value="false" data-correct="true"/> False</label></p></blockquote></summary><p>Answer: False. While <span class="stt">helper</span> is tail-recursive, the result is incorrect &#8212;<wbr></wbr> the elements are reversed. Since each new element is consed onto the front of the accumulator, the output list is in reverse order compared to the input.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="SubFlow"><p>Quiz: Implement a tail-recursive version of <span class="stt">map</span>.</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* map has type (&#39;a -&gt; &#39;b) -&gt; &#39;a list -&gt; &#39;b list *)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">(* Examples:</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">   map (fun x -&gt; x + 1) [1;2;3] = [2;3;4]</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co">   map string_of_int [1;2;3] = [&quot;1&quot;;&quot;2&quot;;&quot;3&quot;]</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co">*)</span></span></code></pre></div>
</div></p></blockquote></summary><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> map f l =</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> helper l a =</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>      [] -&gt; a</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    | h::t -&gt; helper t ((f h)::a)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span> rev (helper l [])</span></code></pre></div>
</div></p><p>The key insight is that a tail-recursive helper builds the list in reverse order (since we cons onto the accumulator). To fix this, we reverse the result at the end with <span class="stt">rev</span>.</p></details></section><section class="SsectionLevel4" id="section 2.23.3"><h4 class="heading">2.23.3<span class="stt">&nbsp;</span><a name="(part._.Optional_.Reading__.Continuation-.Passing_.Style__.C.P.S_)"></a>Optional Reading: Continuation-Passing Style (CPS)<span class="button-group"><a href="#(part._.Optional_.Reading__.Continuation-.Passing_.Style__.C.P.S_)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Sometimes, rewriting a non-tail-recursive function as a tail-recursive
one is not straightforward. In such cases, we can transform the
non-tail-recursive function into Continuation-Passing Style (CPS),
so that every recursive call becomes a tail call.</p><p>CPS is a way of writing functions in which, instead of returning a
value directly, they take an extra argument called a continuation&#8212;a
function that represents <span style="font-weight: bold">what to do next with the result</span>.</p><p><div class="SIntrapara">Here is the factorial function implemented in CPS style:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> fact_cps n k = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">if</span> n = <span class="dv">0</span> <span class="kw">then</span> k <span class="dv">1</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">else</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    fact_cps (n - <span class="dv">1</span>) (<span class="kw">fun</span> r -&gt; k (n * r));; </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> fact_cps <span class="dv">5</span> (<span class="kw">fun</span> x-&gt;x);;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> fact_cps : <span class="dt">int</span> -&gt; (<span class="dt">int</span> -&gt; &#39;a) -&gt; &#39;a = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">120</span></span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">The key idea is that <span style="font-weight: bold">k</span> always represents <span style="font-weight: bold">what to do
with the final result</span>.
Instead of performing the multiplication after the recursive
call returns, we construct a new continuation: <span style="font-weight: bold">fun r -&gt; k (n * r)</span>.</div></p><p><div class="SIntrapara">One more example: sum of a list
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* Non tail-recursive style *)</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> <span class="kw">rec</span> sum lst = </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> lst <span class="kw">with</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    | [] -&gt; <span class="dv">0</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    | x :: xs -&gt; x + sum xs;; </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a> <span class="co">(* CPS style *)</span> </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> <span class="kw">rec</span> sum_cps lst k = </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> lst <span class="kw">with</span> </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    | [] -&gt; k <span class="dv">0</span> </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    | x :: xs -&gt; </span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>        sum_cps xs (<span class="kw">fun</span> r -&gt; k (x + r));; </span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a> sum_cps [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>;<span class="dv">4</span>;<span class="dv">5</span>] (<span class="kw">fun</span> x -&gt; x) ;;</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> sum : <span class="dt">int</span> <span class="dt">list</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> sum_cps : <span class="dt">int</span> <span class="dt">list</span> -&gt; (<span class="dt">int</span> -&gt; &#39;a) -&gt; &#39;a = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">15</span></span></code></pre></div>
</div></p></blockquote></blockquote></div></p></section></section><section class="SsectionLevel3" id="section 2.24"><h3 class="heading">2.24<span class="stt">&nbsp;</span><a name="(part._.O.Caml_.Data_.Types__.Variants_)"></a>OCaml Data Types (Variants)<span class="button-group"><a href="#(part._.O.Caml_.Data_.Types__.Variants_)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h3><p><div class="SIntrapara">So far, we have encountered these forms of data:
</div><div class="SIntrapara"><ul><li><p>Basic types: <span class="RktSym">int</span><span class="RktMeta"></span>, <span class="RktSym">float</span><span class="RktMeta"></span>, <span class="RktSym">char</span><span class="RktMeta"></span>, <span class="RktSym">string</span><span class="RktMeta"></span></p></li><li><p>Lists: A recursive data structure. A list is either <span class="RktPn">[</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">]</span><span class="RktMeta"></span> or <span class="RktSym">h::t</span><span class="RktMeta"></span>,
and is typically processed using pattern matching</p></li><li><p>Tuples and Records: Group values together into fixed-size collections</p></li><li><p>Functions</p></li></ul></div></p><p>However, working only with lists and tuples can sometimes be limiting or
inconvenient. In this section, we will see how to define new kinds of data
structures in a more natural and expressive way.</p></section><section class="SsectionLevel3" id="section 2.25"><h3 class="heading">2.25<span class="stt">&nbsp;</span><a name="(part._.User_.Defined_.Types)"></a>User Defined Types<span class="button-group"><a href="#(part._.User_.Defined_.Types)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>We can introduce new types using the <span style="font-weight: bold">type</span> keyword. In simplest form,
it is like a C <span style="font-weight: bold">enum</span>. They let you represent data that may take on multiple
different forms, where each form is marked by an explicit tag. User defined
types are also called <span style="font-weight: bold">variants</span> or <span style="font-weight: bold">algebraic data types</span>. It is similar to an enumeration
in other languages, but more powerful because each constructor can also carry associated data.</p><p><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> color = Red | Green | Blue | Yellow;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> c = Red;; </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> ;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> color = Red | Green | Blue | Yellow</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> c : color = Red</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">The different constructors can also carry other values with them. For example,
suppose we want a type <span style="font-weight: bold">gen</span> that can either be an integers, a string, or
a float. It can be declared as follows:</div></p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> gen = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    | Int <span class="kw">of</span> <span class="dt">int</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    | Str <span class="kw">of</span> <span class="dt">string</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    | Float <span class="kw">of</span> <span class="dt">float</span>;; </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> ls = [Int <span class="dv">10</span>; Str <span class="st">&quot;alice&quot;</span>; Int <span class="dv">20</span>; Float <span class="fl">1.5</span>];; </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> ;; </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a> <span class="co">(* print a gen type value *)</span> </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> print_gen x = </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> x <span class="kw">with</span> </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>     | Int i -&gt; <span class="dt">Printf</span>.printf <span class="st">&quot;%d</span><span class="ch">\n</span><span class="st">&quot;</span> i </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>     | Str s -&gt; <span class="dt">Printf</span>.printf <span class="st">&quot;%s</span><span class="ch">\n</span><span class="st">&quot;</span> s </span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>     | Float n -&gt; <span class="dt">Printf</span>.printf <span class="st">&quot;%f</span><span class="ch">\n</span><span class="st">&quot;</span> n </span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a> ;; </span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a> <span class="co">(* print a gen list *)</span> </span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a> <span class="dt">List</span>.iter print_gen ls;;</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> gen = Int <span class="kw">of</span> <span class="dt">int</span> | Str <span class="kw">of</span> <span class="dt">string</span> | Float <span class="kw">of</span> <span class="dt">float</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> ls : gen <span class="dt">list</span> = [Int <span class="dv">10</span>; Str <span class="st">&quot;alice&quot;</span>; Int <span class="dv">20</span>; Float <span class="fl">1.5</span>]</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> print_gen : gen -&gt; <span class="dt">unit</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="dv">10</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>alice</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a><span class="dv">20</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a><span class="fl">1.500000</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">unit</span> = ()</span></code></pre></div>
</div></p></blockquote></blockquote><p><div class="SIntrapara">Here is another example:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> suit = Club | Diamond | Heart | Spade;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">type</span> value = Jack | Queen | King | Ace | Num <span class="kw">of</span> <span class="dt">int</span>;; </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">type</span> card = Card <span class="kw">of</span> value * suit;; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> <span class="kw">type</span> hand = card <span class="dt">list</span>;; </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> ([Card(Ace, Spade); Card(Num <span class="dv">7</span>, Heart)]:hand);;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> suit = Club | Diamond | Heart | Spade</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> value = Jack | Queen | King | Ace | Num <span class="kw">of</span> <span class="dt">int</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> card = Card <span class="kw">of</span> value * suit</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> hand = card <span class="dt">list</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>- : hand = [Card (Ace, Spade); Card (Num <span class="dv">7</span>, Heart)]</span></code></pre></div>
</div></p></blockquote></blockquote></div></p><p><div class="SIntrapara">Yet another example:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> coin = Heads | Tails </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> flip x = </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> x <span class="kw">with</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>      Heads -&gt; Tails </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    | Tails -&gt; Heads;; </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> <span class="kw">rec</span> count_heads x = </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> x <span class="kw">with</span> </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>      [] -&gt; <span class="dv">0</span> </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    | (Heads::x&#39;) -&gt; <span class="dv">1</span> + count_heads x&#39; </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    | (_::x&#39;) -&gt; count_heads x&#39;;;</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> coin = Heads | Tails</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> flip : coin -&gt; coin = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> count_heads : coin <span class="dt">list</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></div></p><p>The syntax of the variants is as follows:</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> t = C1 [<span class="kw">of</span> t1] |... | Cn [<span class="kw">of</span> tn]</span></code></pre></div>
</div></p><p>the <span style="font-weight: bold">Ci</span> are called constructors</p><p>When we evaluate a variant, a constructor <span style="font-weight: bold">Ci</span> is a value if it has
no associated data. <span style="font-weight: bold">Ci vi</span> is a value if it carries a data. We can destruct
a value of type <span style="font-weight: bold">t</span> by pattern matching. Patterns are constructors <span style="font-weight: bold">Ci</span>
with data components, if any.</p><p>In OCaml, a variant type is a sum type. The type system enforces rules to ensure
constructors are used consistently. Here are the main typechecking rules for variants:</p><ul><li><p><div class="SIntrapara">Constructor Type Uniqueness: Each constructor belongs to exactly one variant type.
Its name determines its type. If a constructor is defined more than once, the later definition
overrides the earlier one.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> color = Red | Green;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">type</span> traffic = Red | Yellow | Green;; </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> Red;; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> ;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> color = Red | Green</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> traffic = Red | Yellow | Green</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>- : traffic = Red</span></code></pre></div>
</div></p></blockquote></blockquote></div></p></li><li><p><div class="SIntrapara">Constructor Arity: A constructor may carry no data or one tuple of data.
The types of the carried values must match the declaration.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> shape = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    | Circle <span class="kw">of</span> <span class="dt">float</span> <span class="co">(* radius *)</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    | Rectangle <span class="kw">of</span> <span class="dt">float</span> * <span class="dt">float</span>;; <span class="co">(* width*length *)</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>   <span class="co">(* Rectangle and Circle are constructors, so a shape is either </span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co">    Rectangle(w,l) for any floats w and l, or Circle r for any </span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co">    float r *)</span> </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> c = Circle <span class="fl">3.0</span>;;          <span class="co">(* correct *)</span> </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> r = Rectangle (<span class="fl">3.0</span>, <span class="fl">4.0</span>);; <span class="co">(* correct *)</span> </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a> <span class="co">(* let bad = Circle &quot;hi&quot;;; type error: expected float *)</span> </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a> <span class="co">(* We can also creates a list of shapes *)</span> </span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> lst = [Rectangle (<span class="fl">3.0</span>, <span class="fl">4.0</span>) ; Circle <span class="fl">3.0</span>];; </span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> area s = </span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> s <span class="kw">with</span> </span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>      Rectangle (w, l) -&gt; w *. l </span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    | Circle r -&gt; r  *. r *. <span class="fl">3.14</span>;; </span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a> area (Rectangle (<span class="fl">3.0</span>, <span class="fl">4.0</span>));; <span class="co">(* 12.0  *)</span> </span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a> area (Circle <span class="fl">3.0</span>);;      <span class="co">(* 28.26 *)</span> </span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a> ;;</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> shape = Circle <span class="kw">of</span> <span class="dt">float</span> | Rectangle <span class="kw">of</span> <span class="dt">float</span> * <span class="dt">float</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> c : shape = Circle <span class="dv">3</span>.</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> r : shape = Rectangle (<span class="dv">3</span>., <span class="dv">4</span>.)</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> lst : shape <span class="dt">list</span> = [Rectangle (<span class="dv">3</span>., <span class="dv">4</span>.); Circle <span class="dv">3</span>.]</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> area : shape -&gt; <span class="dt">float</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">float</span> = <span class="dv">12</span>.</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">float</span> = <span class="fl">28.26</span></span></code></pre></div>
</div></p></blockquote></blockquote></div></p></li><li><p>When pattern matching on user-defined data types, the set of patterns
must cover every constructor of the variant type. If a new constructor is added later,
the compiler will issue a warning indicating that the pattern match is no longer exhaustive.</p></li></ul><section class="SsectionLevel4" id="section 2.25.1"><h4 class="heading">2.25.1<span class="stt">&nbsp;</span><a name="(part._.Option_.Type)"></a>Option Type<span class="button-group"><a href="#(part._.Option_.Type)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p><div class="SIntrapara">Option values explicitly indicate the presence or absence of a value. Comparing to
 Java, <span style="font-weight: bold">None</span> is like <span style="font-weight: bold">null</span>, while <span style="font-weight: bold">Some i</span> is like an <span style="font-weight: bold">Integer(i)</span> object.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> optional_int = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>   | <span class="dt">None</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>   | <span class="dt">Some</span> <span class="kw">of</span> <span class="dt">int</span> ;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> optional_int = <span class="dt">None</span> | <span class="dt">Some</span> <span class="kw">of</span> <span class="dt">int</span></span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara"><span style="font-weight: bold">Some v</span> represents the presence of a value <span style="font-weight: bold">v</span>, and <span style="font-weight: bold">None</span> represents the absence of a value.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> divide x y = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> y != <span class="dv">0</span> <span class="kw">then</span> <span class="dt">Some</span> (x/y) </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> <span class="dt">None</span>;; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> string_of_opt o = </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> o <span class="kw">with</span> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Some</span> i -&gt; <span class="dt">string_of_int</span> i </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">None</span> -&gt; <span class="st">&quot;nothing&quot;</span>;; </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> p = divide <span class="dv">1</span> <span class="dv">0</span>;; </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a> <span class="dt">print_string</span> (string_of_opt p);;</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> divide : <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> <span class="dt">option</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> string_of_opt : <span class="dt">int</span> <span class="dt">option</span> -&gt; <span class="dt">string</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> p : <span class="dt">int</span> <span class="dt">option</span> = <span class="dt">None</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>nothing</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">unit</span> = ()</span></code></pre></div>
</div></p></blockquote></blockquote></div></p><p><div class="SIntrapara">The Option type can be polymorphic. We can define an option type that can
hold a value of any data type as follows.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a <span class="dt">option</span> = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Some</span> <span class="kw">of</span> &#39;a </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> | <span class="dt">None</span>;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a <span class="dt">option</span> = <span class="dt">Some</span> <span class="kw">of</span> &#39;a | <span class="dt">None</span></span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">Previously, we implemented the <span style="font-weight: bold">hd</span> function as:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> hd l = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> l <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    | h::_ -&gt;h;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>Lines <span class="dv">2-3</span>, characters <span class="dv">4-14</span>:</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span> | ....<span class="kw">match</span> l <span class="kw">with</span> </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="dv">3</span> |     | h::_ -&gt;h..</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>Warning <span class="dv">8</span> [partial-<span class="kw">match</span>]: this pattern-matching is <span class="dt">not</span> exhaustive.</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  Here is an example <span class="kw">of</span> a case that is <span class="dt">not</span> matched: []</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> hd : &#39;a <span class="dt">list</span> -&gt; &#39;a = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">This implementation throws a <span style="font-weight: bold">Match_failure</span> exception when the input is an empty list.
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>hd [];;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>Exception: <span class="dt">Match_failure</span></span></code></pre></div>
</div>
Now, we can reimplement the <span style="font-weight: bold">hd</span> function for the list using an option type.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a <span class="dt">option</span> =   <span class="dt">Some</span> <span class="kw">of</span> &#39;a | <span class="dt">None</span>;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> hd l = </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> l <span class="kw">with</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    [] -&gt; <span class="dt">None</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    | x::_ -&gt; <span class="dt">Some</span> x;; </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> p = hd [];; </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> q = hd [<span class="dv">1</span>;<span class="dv">2</span>];; </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> r = hd [<span class="st">&quot;a&quot;</span>];;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a <span class="dt">option</span> = <span class="dt">Some</span> <span class="kw">of</span> &#39;a | <span class="dt">None</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> hd : &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">option</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> p : &#39;a <span class="dt">option</span> = <span class="dt">None</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> q : <span class="dt">int</span> <span class="dt">option</span> = <span class="dt">Some</span> <span class="dv">1</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> r : <span class="dt">string</span> <span class="dt">option</span> = <span class="dt">Some</span> <span class="st">&quot;a&quot;</span></span></code></pre></div>
</div></p></blockquote></blockquote></div></p></section><section class="SsectionLevel4" id="section 2.25.2"><h4 class="heading">2.25.2<span class="stt">&nbsp;</span><a name="(part._.Recursive_.Data_.Types)"></a>Recursive Data Types<span class="button-group"><a href="#(part._.Recursive_.Data_.Types)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>A type is recursive if in its implementation it refers to its own
definition. Functions over a recursive type are often defined by recursion.</p><p><div class="SIntrapara">We can write our own version of lists using variant types. Suppose we want
to define values that act like linked lists of integers. A linked list is
 either empty, or it has an integer followed by another list containing the
 rest of the list elements. This leads to a the following type declaration:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> intlist = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    | Nil </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    | Cons <span class="kw">of</span> (<span class="dt">int</span> * intlist);; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> ;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> intlist = Nil | Cons <span class="kw">of</span> (<span class="dt">int</span> * intlist)</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">This type has two constructors, <span style="font-weight: bold">Nil</span> and <span style="font-weight: bold">Cons</span>. It is a recursive type
because it mentions itself in its own definition in the Cons constructor.</div></p><p><div class="SIntrapara">Any list of integers can be represented by using this type. For example, the
empty list is just the constructor <span style="font-weight: bold">Nil</span>, and <span style="font-weight: bold">Cons</span> corresponds to the operator
<span style="font-weight: bold">::</span>. Here are some examples of lists:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> intlist =  | Nil  | Cons <span class="kw">of</span> (<span class="dt">int</span> * intlist);; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> Nil;;   <span class="co">(* empty list *)</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> Cons(<span class="dv">1</span>,Nil);;  <span class="co">(* 1â†’Nil *)</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> Cons(<span class="dv">1</span>, Cons(<span class="dv">2</span>,Cons(<span class="dv">3</span>,Nil)));; <span class="co">(* 1â†’2â†’3â†’Nil *)</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> intlist = Nil | Cons <span class="kw">of</span> (<span class="dt">int</span> * intlist)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>- : intlist = Nil</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>- : intlist = Cons (<span class="dv">1</span>, Nil)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>- : intlist = Cons (<span class="dv">1</span>, Cons (<span class="dv">2</span>, Cons (<span class="dv">3</span>, Nil)))</span></code></pre></div>
</div></p></blockquote></blockquote></div></p></section><section class="SsectionLevel4" id="section 2.25.3"><h4 class="heading">2.25.3<span class="stt">&nbsp;</span><a name="(part._.Polymorphic_.List)"></a>Polymorphic List<span class="button-group"><a href="#(part._.Polymorphic_.List)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>You can define your own list type as a custom version of
OCaml&#8217;s built-in list. The following definition introduces
a polymorphic linked list in which each value is either
empty (Nil) or a node (Cons) containing an element of
type &rsquo;a and the remainder of the list.</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a mylist = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>     Nil </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    | Cons <span class="kw">of</span> (&#39;a * &#39;a mylist);; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> <span class="co">(* length of the list *)</span> </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> <span class="kw">rec</span> len = <span class="kw">function</span> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>     Nil -&gt; <span class="dv">0</span> </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>   | Cons (_, t) -&gt; <span class="dv">1</span> + (len t);; </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a> len (Cons (<span class="dv">10</span>, Cons (<span class="dv">20</span>, Cons (<span class="dv">30</span>, Nil))));; </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a> <span class="co">(* Remove repeated elements from the list *)</span> </span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> <span class="kw">rec</span> uniq lst = </span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> lst <span class="kw">with</span> </span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    |Nil -&gt; Nil </span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    | Cons(x, Nil) -&gt; Cons(x, Nil) </span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    | Cons(x, Cons(y, t)) -&gt; </span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>       <span class="kw">if</span> x = y <span class="kw">then</span> uniq (Cons (y , t)) </span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>       <span class="kw">else</span> Cons(x , uniq (Cons(y , t)));; </span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> l = Cons(<span class="dv">1</span>, Cons(<span class="dv">2</span>, Cons(<span class="dv">2</span>, Cons(<span class="dv">3</span>,Nil))));; </span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a> uniq l;; </span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a> <span class="co">(* Create an mylist from an OCaml list *)</span> </span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> <span class="kw">rec</span> mylist_of_list (ls : &#39;a <span class="dt">list</span>) : &#39;a mylist = </span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> ls <span class="kw">with</span> </span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>          [] -&gt; Nil </span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>          | h::t -&gt; Cons(h, (mylist_of_list t));; </span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> ol = mylist_of_list [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>;<span class="dv">4</span>];; </span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a> <span class="co">(* sum of a mylist *)</span> </span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> <span class="kw">rec</span> list_sum l = </span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> l <span class="kw">with</span> </span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>          |Nil-&gt;<span class="dv">0</span> </span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>          |Cons(h,t) -&gt; h + (list_sum t);; </span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> m = list_sum ol;; </span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> c = Cons(<span class="dv">10</span>,Cons(<span class="dv">20</span>,Cons(<span class="dv">30</span>,Nil)));; </span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a> <span class="dt">print_int</span> (list_sum c);; <span class="co">(* 60 *)</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a mylist = Nil | Cons <span class="kw">of</span> (&#39;a * &#39;a mylist)</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> len : &#39;a mylist -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">3</span></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> uniq : &#39;a mylist -&gt; &#39;a mylist = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> l : <span class="dt">int</span> mylist = Cons (<span class="dv">1</span>, Cons (<span class="dv">2</span>, Cons (<span class="dv">2</span>, Cons (<span class="dv">3</span>, Nil))))</span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> mylist = Cons (<span class="dv">1</span>, Cons (<span class="dv">2</span>, Cons (<span class="dv">3</span>, Nil)))</span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> mylist_of_list : &#39;a <span class="dt">list</span> -&gt; &#39;a mylist = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> ol : <span class="dt">int</span> mylist = Cons (<span class="dv">1</span>, Cons (<span class="dv">2</span>, Cons (<span class="dv">3</span>, Cons (<span class="dv">4</span>, Nil))))</span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> list_sum : <span class="dt">int</span> mylist -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> m : <span class="dt">int</span> = <span class="dv">10</span></span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> c : <span class="dt">int</span> mylist = Cons (<span class="dv">10</span>, Cons (<span class="dv">20</span>, Cons (<span class="dv">30</span>, Nil)))</span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a><span class="dv">60</span></span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">unit</span> = ()</span></code></pre></div>
</div></p></blockquote></blockquote></section><section class="SsectionLevel4" id="section 2.25.4"><h4 class="heading">2.25.4<span class="stt">&nbsp;</span><a name="(part._.Binary_.Trees)"></a>Binary Trees<span class="button-group"><a href="#(part._.Binary_.Trees)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p><div class="SIntrapara">We can use variants to represent tree data structures as
well. Here is the definition of a binary tree.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a tree = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> | Leaf </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> | Node <span class="kw">of</span> &#39;a tree * &#39;a * &#39;a tree;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a tree = Leaf | Node <span class="kw">of</span> &#39;a tree * &#39;a * &#39;a tree</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">The type <span style="font-weight: bold">tree</span> has two constructors
</div><div class="SIntrapara"><ul><li><p><span style="font-weight: bold">Leaf : &rsquo;a tree</span>: represents an empty tree.</p></li><li><p><div class="SIntrapara"><span style="font-weight: bold">Node of &rsquo;a tree * &rsquo;a * &rsquo;a tree</span>: represents a non-empty tree node.
It contains three things:
</div><div class="SIntrapara"><ul><li><p>a left subtree (&rsquo;a tree)</p></li><li><p>a value stored at the node (&rsquo;a)</p></li><li><p>a right subtree (&rsquo;a tree)</p></li></ul></div></p></li></ul></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a tree =</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>   | Leaf</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>   | Node <span class="kw">of</span> &#39;a tree * &#39;a * &#39;a tree;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> empty = Leaf;;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> t = Node(Leaf, <span class="dv">100</span>, Node(Leaf,<span class="dv">200</span>,Leaf));;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a tree = Leaf | Node <span class="kw">of</span> &#39;a tree * &#39;a * &#39;a tree</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> empty : &#39;a tree = Leaf</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> t : <span class="dt">int</span> tree = Node (Leaf, <span class="dv">100</span>, Node (Leaf, <span class="dv">200</span>, Leaf))</span></code></pre></div>
</div></p></blockquote></blockquote></div></p><p><img src="binary_tree2.png" alt="" width="269" height="221"/></p><p>For the following examples, we use the binary
tree <span style="font-weight: bold">t2</span> as illustrated below:
<img src="binary_tree1.png" alt="" width="170" height="256"/></p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a tree =</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>   | Leaf</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>   | Node <span class="kw">of</span> &#39;a tree * &#39;a * &#39;a tree;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> t2 = Node(Node(Node(Leaf, <span class="ch">&#39;d&#39;</span>, Leaf),<span class="ch">&#39;b&#39;</span>, </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>        Node(Leaf,<span class="ch">&#39;e&#39;</span>, Leaf)), <span class="ch">&#39;a&#39;</span>, </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>         Node(Leaf,<span class="ch">&#39;c&#39;</span>, </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>           Node(Node(Leaf, <span class="ch">&#39;g&#39;</span>, Leaf),<span class="ch">&#39;f&#39;</span>, Leaf)));;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="co">(* sum of an int tree *)</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> sum t = </span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> t <span class="kw">with</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>  Leaf -&gt; <span class="dv">0</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>  | Node(l,v,r)-&gt; (sum l) + v + (sum r)</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="co">(* Count the number of nodes *)</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> count tree = </span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> tree <span class="kw">with</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    Leaf-&gt;<span class="dv">0</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    |Node(l,v,r)-&gt;<span class="dv">1</span> + count(l) + count(r);;</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a><span class="co">(* Count the number of leaves *)</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> count_leaves = <span class="kw">function</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>  | Leaf -&gt; <span class="dv">0</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    | Node(Leaf,_, Leaf) -&gt; <span class="dv">1</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>    | Node(l,_, r) -&gt; count_leaves l + count_leaves r;;</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a><span class="co">(* Collect values of leaf nodes in a list *)</span> </span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> leaves = <span class="kw">function</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>    | Leaf -&gt; []</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>    | Node(Leaf, c, Leaf) -&gt; [c]</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>    | Node(l, _, r) -&gt; leaves l @ leaves r;;</span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a><span class="co">(* Collect the internal nodes of a binary tree in a list *)</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> internals = <span class="kw">function</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>    | Leaf | Node(Leaf,_, Leaf) -&gt; []</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>    | Node(l, v, r) -&gt; internals l @ (v :: internals r);;</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a><span class="co">(* Collect the nodes at a given level in a list *)</span></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> at_level t n = <span class="kw">match</span> t <span class="kw">with</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>    | Leaf -&gt; []</span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>    | Node(left, c, right) -&gt;</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> n = <span class="dv">1</span> <span class="kw">then</span> [c]</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span> at_level left (n - <span class="dv">1</span>) @ at_level right (n - <span class="dv">1</span>);;</span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a> at_level t2 <span class="dv">2</span>;;</span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a><span class="co">(* insert an item to a binary search tree *)</span></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> insert t n =</span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> t <span class="kw">with</span> </span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a>    |Leaf-&gt;Node(Leaf, n,Leaf)</span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>    |Node(left,value,right)-&gt; </span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> n &lt; value <span class="kw">then</span> Node((insert left n), value,right) </span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> </span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> n &gt; value <span class="kw">then</span> Node(left, value,(insert right n))</span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>      <span class="kw">else</span> Node(left,value,right);;</span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a><span class="co">(* Height of a tree *)</span></span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> height t=</span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> t <span class="kw">with</span> </span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>    |Leaf -&gt; <span class="dv">0</span></span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a>    |Node(l,v,r)-&gt;<span class="dv">1</span> + <span class="dt">max</span> (height l) (height r);;</span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a><span class="co">(* Inorder traversal *)</span></span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> inorder t = </span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> t <span class="kw">with</span> </span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a>    |Leaf-&gt;[]</span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a>    |Node(l,v,r)-&gt; (inorder l)@[v]@(inorder r);;</span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a>inorder t2;;</span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a><span class="co">(* Preorder traversal *)</span></span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> preorder t = </span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> t <span class="kw">with</span> </span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a>    |Leaf-&gt;[]</span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true" tabindex="-1"></a>    |Node(l,v,r)-&gt;</span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true" tabindex="-1"></a>             v::(preorder l) @ (preorder r);;</span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-81"><a href="#cb1-81" aria-hidden="true" tabindex="-1"></a>preorder t2;;</span>
<span id="cb1-82"><a href="#cb1-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-83"><a href="#cb1-83" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> postorder t = </span>
<span id="cb1-84"><a href="#cb1-84" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> t <span class="kw">with</span> </span>
<span id="cb1-85"><a href="#cb1-85" aria-hidden="true" tabindex="-1"></a>    |Leaf-&gt;[]</span>
<span id="cb1-86"><a href="#cb1-86" aria-hidden="true" tabindex="-1"></a>    |Node(l,v,r)-&gt;</span>
<span id="cb1-87"><a href="#cb1-87" aria-hidden="true" tabindex="-1"></a>            (postorder l)@</span>
<span id="cb1-88"><a href="#cb1-88" aria-hidden="true" tabindex="-1"></a>            (postorder r)@</span>
<span id="cb1-89"><a href="#cb1-89" aria-hidden="true" tabindex="-1"></a>        [v];;</span>
<span id="cb1-90"><a href="#cb1-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-91"><a href="#cb1-91" aria-hidden="true" tabindex="-1"></a>postorder t2;;</span>
<span id="cb1-92"><a href="#cb1-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-93"><a href="#cb1-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-94"><a href="#cb1-94" aria-hidden="true" tabindex="-1"></a><span class="co">(* Level order traversal *)</span></span>
<span id="cb1-95"><a href="#cb1-95" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> levelOrder t = </span>
<span id="cb1-96"><a href="#cb1-96" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> q=<span class="dt">Queue</span>.create () <span class="kw">in</span> </span>
<span id="cb1-97"><a href="#cb1-97" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> _ = <span class="dt">Queue</span>.push t q <span class="kw">in</span> </span>
<span id="cb1-98"><a href="#cb1-98" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> aux queue =</span>
<span id="cb1-99"><a href="#cb1-99" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> <span class="dt">Queue</span>.is_empty queue <span class="kw">then</span> () <span class="kw">else</span></span>
<span id="cb1-100"><a href="#cb1-100" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> c = <span class="dt">Queue</span>.pop queue <span class="kw">in</span></span>
<span id="cb1-101"><a href="#cb1-101" aria-hidden="true" tabindex="-1"></a>            <span class="kw">match</span> c <span class="kw">with</span> </span>
<span id="cb1-102"><a href="#cb1-102" aria-hidden="true" tabindex="-1"></a>            |Leaf -&gt;aux queue</span>
<span id="cb1-103"><a href="#cb1-103" aria-hidden="true" tabindex="-1"></a>            |Node(l,v,r)-&gt;<span class="dt">Printf</span>.printf <span class="st">&quot;%c,&quot;</span> v;</span>
<span id="cb1-104"><a href="#cb1-104" aria-hidden="true" tabindex="-1"></a>                <span class="kw">let</span> _= <span class="dt">Queue</span>.push l queue <span class="kw">in</span></span>
<span id="cb1-105"><a href="#cb1-105" aria-hidden="true" tabindex="-1"></a>                <span class="kw">let</span> _ = <span class="dt">Queue</span>.push r queue <span class="kw">in</span></span>
<span id="cb1-106"><a href="#cb1-106" aria-hidden="true" tabindex="-1"></a>        aux queue</span>
<span id="cb1-107"><a href="#cb1-107" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span> aux q;;</span>
<span id="cb1-108"><a href="#cb1-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-109"><a href="#cb1-109" aria-hidden="true" tabindex="-1"></a>levelOrder t2;;</span>
<span id="cb1-110"><a href="#cb1-110" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-111"><a href="#cb1-111" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-112"><a href="#cb1-112" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-113"><a href="#cb1-113" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a tree = Leaf | Node <span class="kw">of</span> &#39;a tree * &#39;a * &#39;a tree</span>
<span id="cb1-114"><a href="#cb1-114" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> t2 : <span class="dt">char</span> tree =</span>
<span id="cb1-115"><a href="#cb1-115" aria-hidden="true" tabindex="-1"></a>  Node (Node (Node (Leaf, <span class="ch">&#39;d&#39;</span>, Leaf), <span class="ch">&#39;b&#39;</span>, Node (Leaf, <span class="ch">&#39;e&#39;</span>, Leaf)), <span class="ch">&#39;a&#39;</span>,</span>
<span id="cb1-116"><a href="#cb1-116" aria-hidden="true" tabindex="-1"></a>   Node (Leaf, <span class="ch">&#39;c&#39;</span>, Node (Node (Leaf, <span class="ch">&#39;g&#39;</span>, Leaf), <span class="ch">&#39;f&#39;</span>, Leaf)))</span>
<span id="cb1-117"><a href="#cb1-117" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> sum : <span class="dt">int</span> tree -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-118"><a href="#cb1-118" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> count : &#39;a tree -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-119"><a href="#cb1-119" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> count_leaves : &#39;a tree -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-120"><a href="#cb1-120" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> leaves : &#39;a tree -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-121"><a href="#cb1-121" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> internals : &#39;a tree -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-122"><a href="#cb1-122" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> at_level : &#39;a tree -&gt; <span class="dt">int</span> -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-123"><a href="#cb1-123" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">char</span> <span class="dt">list</span> = [<span class="ch">&#39;b&#39;</span>; <span class="ch">&#39;c&#39;</span>]</span>
<span id="cb1-124"><a href="#cb1-124" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> insert : &#39;a tree -&gt; &#39;a -&gt; &#39;a tree = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-125"><a href="#cb1-125" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> height : &#39;a tree -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-126"><a href="#cb1-126" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> inorder : &#39;a tree -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-127"><a href="#cb1-127" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">char</span> <span class="dt">list</span> = [<span class="ch">&#39;d&#39;</span>; <span class="ch">&#39;b&#39;</span>; <span class="ch">&#39;e&#39;</span>; <span class="ch">&#39;a&#39;</span>; <span class="ch">&#39;c&#39;</span>; <span class="ch">&#39;g&#39;</span>; <span class="ch">&#39;f&#39;</span>]</span>
<span id="cb1-128"><a href="#cb1-128" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> preorder : &#39;a tree -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-129"><a href="#cb1-129" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">char</span> <span class="dt">list</span> = [<span class="ch">&#39;a&#39;</span>; <span class="ch">&#39;b&#39;</span>; <span class="ch">&#39;d&#39;</span>; <span class="ch">&#39;e&#39;</span>; <span class="ch">&#39;c&#39;</span>; <span class="ch">&#39;f&#39;</span>; <span class="ch">&#39;g&#39;</span>]</span>
<span id="cb1-130"><a href="#cb1-130" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> postorder : &#39;a tree -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-131"><a href="#cb1-131" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">char</span> <span class="dt">list</span> = [<span class="ch">&#39;d&#39;</span>; <span class="ch">&#39;e&#39;</span>; <span class="ch">&#39;b&#39;</span>; <span class="ch">&#39;g&#39;</span>; <span class="ch">&#39;f&#39;</span>; <span class="ch">&#39;c&#39;</span>; <span class="ch">&#39;a&#39;</span>]</span>
<span id="cb1-132"><a href="#cb1-132" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> levelOrder : <span class="dt">char</span> tree -&gt; <span class="dt">unit</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-133"><a href="#cb1-133" aria-hidden="true" tabindex="-1"></a>a,b,c,d,e,f,g,- : <span class="dt">unit</span> = ()</span></code></pre></div>
</div></p></blockquote></blockquote><p>We can construct a binary search tree from a list using <span style="font-weight: bold">fold</span>,
which progressively inserts the elements of the list into the accumulator.
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> root = <span class="dt">List</span>.fold_left insert Leaf [<span class="dv">100</span>;<span class="dv">50</span>;<span class="dv">200</span>;<span class="dv">10</span>;<span class="dv">60</span>;<span class="dv">250</span>;<span class="dv">300</span>];;</span></code></pre></div>
</div></p></section><section class="SsectionLevel4" id="section 2.25.5"><h4 class="heading">2.25.5<span class="stt">&nbsp;</span><a name="(part._.N-ary_.Trees)"></a>N-ary Trees<span class="button-group"><a href="#(part._.N-ary_.Trees)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p><div class="SIntrapara">N-ary tree is a collection of nodes where each node stores a data of type &lsquo;&rsquo;a&lsquo; and its children, a list of &lsquo;&rsquo;a trees&lsquo;. When this list is empty, then the Node is implicitly a leaf node. Note that leaf and inner nodes all contain data in this representation of a tree. Type:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a n_tree = Node <span class="kw">of</span> &#39;a * &#39;a n_tree <span class="dt">list</span>;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> ;;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a n_tree = Node <span class="kw">of</span> &#39;a * &#39;a n_tree <span class="dt">list</span></span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">Here is a tree that you can use for simple tests of your functions.</div></p><p><img src="nary_tree.png" alt="" width="216" height="217"/></p><p><div class="SIntrapara">Count the nodes in an n-ary tree
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a n_tree = Node <span class="kw">of</span> &#39;a * &#39;a n_tree <span class="dt">list</span>;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> <span class="kw">rec</span> nodes t = </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> t <span class="kw">with</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    | Node (x, children) -&gt; <span class="dv">1</span> + <span class="dt">List</span>.fold_left ( + ) <span class="dv">0</span> (<span class="dt">List</span>.map nodes children);; </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> t = </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    Node </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>      ( <span class="dv">1</span>, </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>        [ </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>          Node </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>            ( <span class="dv">2</span>, </span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>              [ </span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>                Node (<span class="dv">3</span>, []); </span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>                Node (<span class="dv">4</span>, [ Node (<span class="dv">6</span>, []) ]); </span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>                Node (<span class="dv">5</span>, []) </span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>              ] </span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>            ); </span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>          Node (<span class="dv">7</span>, [ Node (<span class="dv">8</span>, []) ]); </span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>        ] );; </span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a> nodes t;; </span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a> <span class="co">(* Calculate the sum an int n-ary tree *)</span> </span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> <span class="kw">rec</span> sum t = </span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> t <span class="kw">with</span> </span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    | Node (x, children) -&gt; x + <span class="dt">List</span>.fold_left ( + ) <span class="dv">0</span> (<span class="dt">List</span>.map sum children);; </span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a> sum t;; </span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a> <span class="co">(* Print an n-ary tree *)</span> </span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> <span class="kw">rec</span> print t = </span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> t <span class="kw">with</span> </span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>    | Node (x, children) -&gt; </span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Printf</span>.printf <span class="st">&quot;%d,&quot;</span> x; </span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>        <span class="dt">List</span>.iter print children;; </span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a> print t;;</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a n_tree = Node <span class="kw">of</span> &#39;a * &#39;a n_tree <span class="dt">list</span></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> nodes : &#39;a n_tree -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> t : <span class="dt">int</span> n_tree =</span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>  Node (<span class="dv">1</span>,</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>   [Node (<span class="dv">2</span>, [Node (<span class="dv">3</span>, []); Node (<span class="dv">4</span>, [Node (<span class="dv">6</span>, [])]); Node (<span class="dv">5</span>, [])]);</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>    Node (<span class="dv">7</span>, [Node (<span class="dv">8</span>, [])])])</span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">8</span></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> sum : <span class="dt">int</span> n_tree -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">36</span></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> print : <span class="dt">int</span> n_tree -&gt; <span class="dt">unit</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">6</span>,<span class="dv">5</span>,<span class="dv">7</span>,<span class="dv">8</span>,</span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">unit</span> = ()</span></code></pre></div>
</div></p></blockquote></blockquote></div></p></section></section><section class="SsectionLevel3" id="section 2.26"><h3 class="heading">2.26<span class="stt">&nbsp;</span><a name="(part._.Exceptions)"></a>Exceptions<span class="button-group"><a href="#(part._.Exceptions)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>In OCaml, exceptions are used to handle errors or unusual
conditions in a controlled way. They are similar in spirit
to exceptions in other languages (like Java or Python), but
they integrate neatly into OCaml&#8217;s functional style.</p><p>Exceptions are introduced using the exception keyword. They
can also be listed in a module&#8217;s signature. Like type
constructors, exceptions may carry arguments, but they
can also be defined without any arguments.
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">exception</span> <span class="dt">Not_found</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">exception</span> Invalid_input <span class="kw">of</span> <span class="dt">string</span></span></code></pre></div>
</div></p><p>You use raise to throw an exception:
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="dt">raise</span> <span class="dt">Not_found</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="dt">raise</span> (Invalid_input <span class="st">&quot;negative number&quot;</span>)</span></code></pre></div>
</div></p><p><div class="SIntrapara">Exceptions are caught using <span style="font-weight: bold">try ... with</span>, where
the <span style="font-weight: bold">with</span> clause supports pattern matching.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">exception</span> Invalid_input <span class="kw">of</span> <span class="dt">string</span>;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> safe_div a b = </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">try</span> a / b <span class="kw">with</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">Division_by_zero</span> -&gt; <span class="dv">0</span>;; </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> parse_positive s = </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">try</span> </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> n = <span class="dt">int_of_string</span> s <span class="kw">in</span> </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> n &lt; <span class="dv">0</span> <span class="kw">then</span> <span class="dt">raise</span> (Invalid_input <span class="st">&quot;negative number&quot;</span>); </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>      n </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">with</span> </span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">Failure</span> _ -&gt; <span class="dt">raise</span> (Invalid_input <span class="st">&quot;not an integer&quot;</span>) </span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    | Invalid_input msg -&gt; </span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Printf</span>.printf <span class="st">&quot;Invalid: %s</span><span class="ch">\n</span><span class="st">&quot;</span> msg; </span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0</span> </span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>      ;;</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="kw">exception</span> Invalid_input <span class="kw">of</span> <span class="dt">string</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> safe_div : <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> parse_positive : <span class="dt">string</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">If an exception is not caught:
</div><div class="SIntrapara"><ul><li><p>The current function terminates immediately.</p></li><li><p>Control is passed up the call stack.</p></li><li><p>This continues until the exception is handled, or it propagates to the top level.</p></li></ul></div></p><p><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">exception</span> My_exception <span class="kw">of</span> <span class="dt">int</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> f n = </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> n &gt; <span class="dv">0</span> <span class="kw">then</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>      <span class="dt">raise</span> (My_exception n) </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>      <span class="dt">raise</span> (<span class="dt">Failure</span> <span class="st">&quot;foo&quot;</span>) </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a> <span class="co">(* Handle the exception with try-with *)</span> </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> bar n = </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">try</span> </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>      f n </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">with</span> My_exception n -&gt; </span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Printf</span>.printf <span class="st">&quot;Caught %d</span><span class="ch">\n</span><span class="st">&quot;</span> n </span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>      | <span class="dt">Failure</span> s -&gt; </span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Printf</span>.printf <span class="st">&quot;Caught %s</span><span class="ch">\n</span><span class="st">&quot;</span> s;;</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="kw">exception</span> My_exception <span class="kw">of</span> <span class="dt">int</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> f : <span class="dt">int</span> -&gt; &#39;a = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> bar : <span class="dt">int</span> -&gt; <span class="dt">unit</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara"><ul><li><p><span style="font-weight: bold">failwith s</span>:Raises exception Failure s (s is a string).</p></li><li><p><span style="font-weight: bold">Not_found</span>:Exception raised by library functions if the object does not exist</p></li><li><p><span style="font-weight: bold">invalid_arg s</span>:Raises exception Invalid_argument s.</p></li></ul></div></p><p><div class="SIntrapara"><span style="font-weight: bold">List.assoc</span> throws <span style="font-weight: bold">Not_found</span> exception if the key is not found in the associative list.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> lst =[(<span class="dv">1</span>,<span class="st">&quot;alice&quot;</span>);(<span class="dv">2</span>,<span class="st">&quot;bob&quot;</span>);(<span class="dv">3</span>,<span class="st">&quot;cat&quot;</span>)];; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> lookup key lst = </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">try</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>      <span class="dt">List</span>.assoc key lst </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">with</span> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Not_found</span> -&gt; <span class="st">&quot;key does not exist&quot;</span>;; </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a> ;;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> lst : (<span class="dt">int</span> * <span class="dt">string</span>) <span class="dt">list</span> = [(<span class="dv">1</span>, <span class="st">&quot;alice&quot;</span>); (<span class="dv">2</span>, <span class="st">&quot;bob&quot;</span>); (<span class="dv">3</span>, <span class="st">&quot;cat&quot;</span>)]</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> lookup : &#39;a -&gt; (&#39;a * <span class="dt">string</span>) <span class="dt">list</span> -&gt; <span class="dt">string</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></div></p></section><section class="SsectionLevel3" id="section 2.27"><h3 class="heading">2.27<span class="stt">&nbsp;</span><a name="(part._.Closures)"></a>Closures<span class="button-group"><a href="#(part._.Closures)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>n OCaml, a closure is a function paired with the environment
in which it was defined. This allows the function to remember
the values of variables that were in scope at the time of its
creation. Closures are closely connected to higher-order
functions. In this section, we explore how to implement higher-order
functions.
In OCaml, functions can be passed as arguments to operations
like <span style="font-weight: bold">map</span>
or <span style="font-weight: bold">fold</span>. For instance, you can supply an anonymous
function such as <span style="font-weight: bold">fun x -&gt; x * 2</span> directly to <span style="font-weight: bold">map</span>.</p><p><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">List</span>.map (<span class="kw">fun</span> x-&gt; x * <span class="dv">2</span>) [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>;<span class="dv">4</span>;<span class="dv">5</span>];;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">2</span>; <span class="dv">4</span>; <span class="dv">6</span>; <span class="dv">8</span>; <span class="dv">10</span>]</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">You can return functions as results as well.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> pick_fn n = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> plus3 x = x + <span class="dv">3</span> <span class="kw">in</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> plus4 x = x + <span class="dv">4</span> <span class="kw">in</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> n &gt; <span class="dv">0</span> <span class="kw">then</span> plus3 <span class="kw">else</span> plus4 </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    ;;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> pick_fn : <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">Here, <span style="font-weight: bold">pick_fn</span> takes an <span style="font-weight: bold">int</span> argument, and returns a function.
The type of <span style="font-weight: bold">pick_fn</span> is <span style="font-weight: bold">int&#8594;(int&#8594;int)</span></div></p><section class="SsectionLevel4" id="section 2.27.1"><h4 class="heading">2.27.1<span class="stt">&nbsp;</span><a name="(part._.Multi-argument_.Functions)"></a>Multi-argument Functions<span class="button-group"><a href="#(part._.Multi-argument_.Functions)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p><div class="SIntrapara">Consider a rewriting of the function <span style="font-weight: bold">pick_fn</span>
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> pick_fn n = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> n &gt; <span class="dv">0</span> <span class="kw">then</span> (<span class="kw">fun</span> x-&gt;x+<span class="dv">3</span>) <span class="kw">else</span> (<span class="kw">fun</span> x-&gt;x+<span class="dv">4</span>);;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> pick_fn : <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">Here&#8217;s another version
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> pick_fn n = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">fun</span> x -&gt; <span class="kw">if</span> n &gt; <span class="dv">0</span> <span class="kw">then</span> x+<span class="dv">3</span> <span class="kw">else</span> x+<span class="dv">4</span>);;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> pick_fn : <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">The shorthand for which is just
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> pick_fn n x = <span class="kw">if</span> n &gt; <span class="dv">0</span> <span class="kw">then</span> x+<span class="dv">3</span> <span class="kw">else</span> x+<span class="dv">4</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> pick_fn : <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">All the above implementation of <span style="font-weight: bold">pick_fn</span> are the same: take one <span style="font-weight: bold">int</span> argument,
and returns a function that takes another <span style="font-weight: bold">int</span> argument.</div></p></section><section class="SsectionLevel4" id="section 2.27.2"><h4 class="heading">2.27.2<span class="stt">&nbsp;</span><a name="(part._.Currying)"></a>Currying<span class="button-group"><a href="#(part._.Currying)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Functions in OCaml do not have a special notion of &#8220;multiple
arguments.&#8221; Instead, a multi-argument function is encoded as a
function that takes one argument and returns another function
for the remaining arguments.</p><p>This transformation is known as currying, named after the
logician Haskell B. Curry. In fact, three programming
languages&#8212;Haskell, Brook, and Curry&#8212;are named after him.
Currying is the process of converting a function of several
arguments into a sequence of single-argument functions.</p><p><div class="SIntrapara">OCaml syntax defaults to currying. All of the following
definitions of add are equivalent:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> add x y = x + y;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> add = (<span class="kw">fun</span> x -&gt; (<span class="kw">fun</span> y -&gt; x + y));; </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> add = (<span class="kw">fun</span> x y -&gt; x + y);; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> add x = (<span class="kw">fun</span> y -&gt; x + y);;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> add : <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> add : <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> add : <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> add : <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></div></p><p><div class="SIntrapara">Each definition expresses the same function in a different syntactic form:
</div><div class="SIntrapara"><ul><li><p><span style="font-weight: bold">let add x y = x + y</span></p><p>add is a function that takes two integer arguments and returns their sum.</p></li><li><p><span style="font-weight: bold">let add = (fun x -&gt; (fun y -&gt; x + y))</span></p><p>add is a function that takes an argument x and returns another function, which takes y and computes x + y.</p></li><li><p><span style="font-weight: bold">fun x y -&gt; x + y</span>
This is shorthand for <span style="font-weight: bold">fun x -&gt; fun y -&gt; x + y</span>. It is equivalent to (fun x -&gt; (fun y -&gt; x + y)), but more concise.</p></li><li><p>bold{let add x = (fun y -&gt; x + y)}</p><p>This form mixes styles: x is introduced as a named parameter, while y is introduced using an explicit anonymous function.</p></li></ul></div><div class="SIntrapara">From these equivalent definitions, we learn an important principle about functions in OCaml:
a function that appears to take multiple arguments is actually a sequence of functions, each taking one argument and returning another function to handle the remaining arguments. This technique is known as currying.</div></p><p><div class="SIntrapara">Thus <span style="font-weight: bold">add</span> has type <span style="font-weight: bold">int &#8594; (int &#8594; int)</span>. <span style="font-weight: bold">add 3</span> has type
<span style="font-weight: bold">int &#8594; int</span>, and <span style="font-weight: bold">add 3</span> is a function that
<span style="font-weight: bold">adds 3</span> to its argument. For example: <span style="font-weight: bold">(add 3) 4 = 7</span>.
This works for any number of arguments. Here is another example a
curried add function with three arguments:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> add x y z = x + y + z;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> add : <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">is same as
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> add x = (<span class="kw">fun</span> y -&gt; (<span class="kw">fun</span> z -&gt; x+y+z));;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> add : <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">Then
</div><div class="SIntrapara"><ul><li><p><span style="font-weight: bold">add</span> has type <span style="font-weight: bold">int &#8594; (int &#8594; (int &#8594; int))</span></p></li><li><p><span style="font-weight: bold">add 4</span> has type <span style="font-weight: bold">int &#8594; (int &#8594; int)</span></p></li><li><p><span style="font-weight: bold">add 4 5</span> has type <span style="font-weight: bold">int &#8594; int</span></p></li><li><p><span style="font-weight: bold">add 4 5 6</span> is <span style="font-weight: bold">15</span></p></li></ul></div></p><p><div class="SIntrapara">Because currying is so common, OCaml uses the following conventions:
</div><div class="SIntrapara"><ul><li><p><span style="font-weight: bold">&#8594;</span> associates from the right. Thus <span style="font-weight: bold">int &#8594; int &#8594; int</span> is the same as <span style="font-weight: bold">int &#8594; (int &#8594; int)</span>. </p></li><li><p>function application associates from the left. Thus &lsquo;add 3 4&lsquo; is the same as &lsquo;(add 3) 4&lsquo;.</p></li></ul></div></p><p><div class="SIntrapara">Syntax note: function vs. fun
</div><div class="SIntrapara"><ul><li><p><span style="font-weight: bold">fun x y &#8230; z &#8594; e</span> defines a curried function.</p></li><li><p><span style="font-weight: bold">function p1 &#8594; e1 | &#8230; | pn &#8594; en</span> defines a single-argument function with multiple
pattern-matching cases, making it more expressive.</p></li></ul></div></p><p><div class="SIntrapara">For example, you can write: &#8230;
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> sum l = <span class="kw">match</span> l <span class="kw">with</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    [] -&gt; <span class="dv">0</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> | (h::t) -&gt; h + (sum t) </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> ;; </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> <span class="co">(* as  *)</span> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> <span class="kw">rec</span> sum = <span class="kw">function</span> </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>     [] -&gt; <span class="dv">0</span> </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>   | (h::t) -&gt; h + (sum t);; </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>   ;;</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> sum : <span class="dt">int</span> <span class="dt">list</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> sum : <span class="dt">int</span> <span class="dt">list</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">Another way you could encode support for multiple arguments is using tuples.
In the following example, function <span style="font-weight: bold">foo</span> takes a single argument, a tuple with
two elements. Function <span style="font-weight: bold">bar</span> takes two arguments. As the result, <span style="font-weight: bold">bar</span>
 supports
partial application. It is useful when you want to provide some arguments
now, the rest later.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> foo (a,b) = a / b;; <span class="co">(* int*int â†’ int *)</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> bar a b = a / b;; <span class="co">(* intâ†’ intâ†’ int *)</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> v = foo(<span class="dv">10</span>,<span class="dv">2</span>);; <span class="co">(* single argument *)</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> div10 = bar <span class="dv">10</span>;; </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> div10 <span class="dv">2</span>;; <span class="co">(* evaluates to 5 *)</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> foo : <span class="dt">int</span> * <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> bar : <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> v : <span class="dt">int</span> = <span class="dv">5</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> div10 : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">5</span></span></code></pre></div>
</div></p></blockquote></blockquote></div></p><p>Currying is standard in OCaml. Pretty much all functions are
curried, such as standard library <span style="font-weight: bold">map</span>, <span style="font-weight: bold">fold</span>, etc.
In particular, look at the file
<span style="font-weight: bold"><a href="https://github.com/ocaml/ocaml/blob/trunk/stdlib/list.ml">list.ml</a></span>
for standard list functions.</p></section><section class="SsectionLevel4" id="section 2.27.3"><h4 class="heading">2.27.3<span class="stt">&nbsp;</span><a name="(part._.How_.Do_.We_.Implement_.Currying_)"></a>How Do We Implement Currying?<span class="button-group"><a href="#(part._.How_.Do_.We_.Implement_.Currying_)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>OCaml makes currying efficient because otherwise it would do a
lot of useless allocation and destruction of closures.
 But implementing currying is tricky. Consider:</p><p><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> addN n l = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> add x = n + x <span class="kw">in</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="dt">List</span>.map add l;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> addN : <span class="dt">int</span> -&gt; <span class="dt">int</span> <span class="dt">list</span> -&gt; <span class="dt">int</span> <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">The inner function <span style="font-weight: bold">add</span> accesses the variable <span style="font-weight: bold">n</span>
from the outer scope. <span style="font-weight: bold">addN</span> is equivalent to
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> addN n = (<span class="kw">fun</span> l -&gt; <span class="dt">List</span>.map (<span class="kw">fun</span> x -&gt; n + x) l);;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> addN : <span class="dt">int</span> -&gt; <span class="dt">int</span> <span class="dt">list</span> -&gt; <span class="dt">int</span> <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">When the anonymous function is called by <span style="font-weight: bold">map</span>, <span style="font-weight: bold">n</span>
 may not be on the stack any more because the function
 <span style="font-weight: bold">addN</span> terminates before <span style="font-weight: bold">map</span> is called.
 We need some way to keep <span style="font-weight: bold">n</span> around after <span style="font-weight: bold">addN</span> returns.</div></p><p><div class="SIntrapara">Another Example
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> foo x = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> bar = <span class="kw">fun</span> y -&gt; x + y <span class="kw">in</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>   bar;; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> foo <span class="dv">10</span>;;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> foo : <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></div></p><p><span style="font-weight: bold">foo 10</span> returns a function of type <span style="font-weight: bold">int -&gt; int</span>:
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">fun</span> y -&gt; <span class="dv">10</span> + y)</span></code></pre></div>
</div></p><p>But where is <span style="font-weight: bold">x</span> when <span style="font-weight: bold">(fun y -&gt; x + y)</span> is executed later?</p></section><section class="SsectionLevel4" id="section 2.27.4"><h4 class="heading">2.27.4<span class="stt">&nbsp;</span><a name="(part._.Environment)"></a>Environment<span class="button-group"><a href="#(part._.Environment)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>When a function is defined, OCaml creates an environment for the function.
It is a mapping from variable names to values, just like a stack frame. We
call function and its environment together a closure. A closure is a
pair <span style="font-weight: bold">(f, e)</span> consisting of
function code <span style="font-weight: bold">f</span> and an environment <span style="font-weight: bold">e</span>. When you invoke a closure,
<span style="font-weight: bold">f</span> is evaluated using <span style="font-weight: bold">e</span> to look up variable bindings.</p><p><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> add x = (<span class="kw">fun</span> y -&gt; x + y);; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> add <span class="dv">3</span>;; <span class="co">(* returns a closure *)</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> add : <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara"><span style="font-weight: bold">add 3</span> returns a closure where the function body
is <span style="font-weight: bold">fun y &#8594; x + y</span> and
the environment contains <span style="font-weight: bold">x=3</span>. When we apply this closure
to another
argument <span style="font-weight: bold">4</span>, it calculates <span style="font-weight: bold">x+y</span> by binding <span style="font-weight: bold">y</span> to <span style="font-weight: bold">4</span>,
and evaluating <span style="font-weight: bold">x</span>
from its environment to <span style="font-weight: bold">3</span> as shown in the image below.</div></p><p><img src="closure1.png" alt="" width="615" height="250"/></p><p><div class="SIntrapara">Here is another example:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> mult_sum (x, y) = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> z = x + y <span class="kw">in</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">fun</span> w -&gt; w * z;; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> mult_sum (<span class="dv">3</span>,<span class="dv">4</span>);;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> mult_sum : <span class="dt">int</span> * <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara"><img src="closure2.png" alt="" width="610" height="218"/></div></p><p><span style="font-weight: bold">mult_sum (3,4)</span> returns a closure where the function is
<span style="font-weight: bold">fun w -&gt; w * z</span> and its environment contains the bindings
for <span style="font-weight: bold">x,y</span>, and <span style="font-weight: bold">z</span>.</p></section><section class="SsectionLevel4" id="section 2.27.5"><h4 class="heading">2.27.5<span class="stt">&nbsp;</span><a name="(part._.Scope)"></a>Scope<span class="button-group"><a href="#(part._.Scope)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p><div class="SIntrapara">Scope refers to the places in a program where a variable is visible and
 can be referenced. Scoping rules are all about how to evaluate free
 variables in a function. It is generally divided into two classes:
 dynamic scope and static scope (also called lexical scope).
</div><div class="SIntrapara"><ul><li><p>Dynamic scope</p><p>The body of a function is evaluated in the current dynamic environment at the time the function is called, not the old dynamic environment that existed at the time the function was defined.</p></li><li><p>Lexical scope</p><p>The body of a function is evaluated in the old dynamic environment that existed at the time the function was defined, not the current environment when the function is called.</p></li></ul></div><div class="SIntrapara">What should this expression evaluate to?
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = <span class="dv">1</span> <span class="kw">in</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> f = <span class="kw">fun</span> y -&gt; x <span class="kw">in</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> x = <span class="dv">2</span> <span class="kw">in</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> f <span class="dv">0</span>;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>Line <span class="dv">3</span>, characters <span class="dv">5-6</span>:</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="dv">3</span> |  <span class="kw">let</span> x = <span class="dv">2</span> <span class="kw">in</span> </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>         ^</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>Warning <span class="dv">26</span> [unused-var]: unused variable x.</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">1</span></span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara"><ul><li><p>With lexical scoping, when <span style="font-weight: bold">f 0</span> is evaluated, <span style="font-weight: bold">x</span>
   refers to <span style="font-weight: bold">1</span>, the value when
the function <span style="font-weight: bold">f</span> is
defined. Therefore, this expression evaluates to 1. </p></li><li><p>with dynamic scoping, <span style="font-weight: bold">x</span>
refers to <span style="font-weight: bold">2</span>, the value in the environment when the function is called. Therefore,
this expression evaluates to <span style="font-weight: bold">2</span>.</p></li></ul></div><div class="SIntrapara">OCaml and most modern languages use lexical scoping.
If you try the above example in &lsquo;Utop&lsquo;, it should evaluate to <span style="font-weight: bold">1</span>.</div></p></section><section class="SsectionLevel4" id="section 2.27.6"><h4 class="heading">2.27.6<span class="stt">&nbsp;</span><a name="(part._.Higher-.Order_.Functions_in_.C)"></a>Higher-Order Functions in C<span class="button-group"><a href="#(part._.Higher-.Order_.Functions_in_.C)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p><div class="SIntrapara">C supports function pointers. The function <span style="font-weight: bold">app</span> takes a function
pointer as an argument, and applies that function to each member of
the array. Therefore, <span style="font-weight: bold">app</span> is basically a higher order function.
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">int</span> <span class="op">(*</span>int_func<span class="op">)(</span><span class="dt">int</span><span class="op">);</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> app<span class="op">(</span>int_func f<span class="op">,</span> <span class="dt">int</span> <span class="op">*</span>a<span class="op">,</span> <span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    a<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> f<span class="op">(</span>a<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> add_one<span class="op">(</span><span class="dt">int</span> x<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> x <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> a<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">5</span><span class="op">,</span> <span class="dv">6</span><span class="op">,</span> <span class="dv">7</span><span class="op">};</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  app<span class="op">(</span>add_one<span class="op">,</span> a<span class="op">,</span> <span class="dv">3</span><span class="op">);</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
But C does not support closures.  Since no nested functions are
allowed, unbound symbols (free variable) always in global scope
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> y <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> app<span class="op">(</span><span class="dt">int</span><span class="op">(*</span>f<span class="op">)(</span><span class="dt">int</span><span class="op">),</span> <span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> f<span class="op">(</span>n<span class="op">);</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> add_y<span class="op">(</span><span class="dt">int</span> x<span class="op">)</span> <span class="op">{</span> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> x <span class="op">+</span> y<span class="op">;</span>  <span class="co">//takes y from the global scope</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  app<span class="op">(</span>add_y<span class="op">,</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
In C, we cannot access non-local variables. For example,
given the following OCaml code:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> add x y = x + y;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>[Output]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> add : <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span></code></pre></div>
</div></p></blockquote></blockquote></div><div class="SIntrapara">Equivalent code in C is illegal
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">(*</span> add<span class="op">(</span><span class="dt">int</span> x<span class="op">))(</span><span class="dt">int</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> add_y<span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> add_y<span class="op">(</span><span class="dt">int</span> y<span class="op">)</span> <span class="op">{</span> </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> x <span class="op">+</span> y<span class="op">;</span> <span class="co">/* error: x undefined */</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div></div></p><p>Java 8 and many other languages now supports lambda
expressions and closures.
OCaml&rsquo;s
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> (a, b) -&gt; a + b</span></code></pre></div>
</div>
Is like the following in Java 8
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>(a, b) -&gt; a + b</span></code></pre></div>
</div></p></section></section><section class="SsectionLevel3" id="section 2.28"><h3 class="heading">2.28<span class="stt">&nbsp;</span><a name="(part._.O.Caml_.Quick_.Reference)"></a>OCaml Quick Reference<span class="button-group"><a href="#(part._.O.Caml_.Quick_.Reference)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>The following is a summary of key OCaml syntax forms covered in this chapter.</p><p><span style="font-weight: bold">Bindings and Expressions</span>
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = e                     <span class="co">(* top-level definition *)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = e1 <span class="kw">in</span> e2               <span class="co">(* local binding; x is visible only in e2 *)</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f x y = e                  <span class="co">(* function definition *)</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> f x = e                <span class="co">(* recursive function *)</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> f x = ... <span class="kw">and</span> g y = ...  <span class="co">(* mutually recursive functions *)</span></span></code></pre></div>
</div></p><p><span style="font-weight: bold">Functions</span>
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> x -&gt; e                     <span class="co">(* anonymous function *)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> x y -&gt; e                   <span class="co">(* multi-argument (curried) anonymous function *)</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f x = e                    <span class="co">(* named function (shorthand for let f = fun x -&gt; e) *)</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>f e1 e2                        <span class="co">(* function application; left-associative *)</span></span></code></pre></div>
</div></p><p><span style="font-weight: bold">Control Flow</span>
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span> e1 <span class="kw">then</span> e2 <span class="kw">else</span> e3          <span class="co">(* conditional; both branches must have same type *)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">match</span> e <span class="kw">with</span>                   <span class="co">(* pattern matching *)</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>| p1 -&gt; e1</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>| p2 -&gt; e2</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>| _  -&gt; en                     <span class="co">(* wildcard; matches anything *)</span></span></code></pre></div>
</div></p><p><span style="font-weight: bold">Type Definitions</span>
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> t = C1 | C2 <span class="kw">of</span> t1 | C3 <span class="kw">of</span> t2 * t3   <span class="co">(* variant / algebraic data type *)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> t = { f1: t1; f2: t2 }               <span class="co">(* record type *)</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a t = ...                            <span class="co">(* polymorphic type *)</span></span></code></pre></div>
</div></p><p><span style="font-weight: bold">Lists</span>
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>[]                              <span class="co">(* empty list *)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>[e1; e2; e3]                   <span class="co">(* list literal *)</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>e :: lst                       <span class="co">(* cons: prepend element to list *)</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="dt">List</span>.map f lst                 <span class="co">(* apply f to each element *)</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="dt">List</span>.filter f lst              <span class="co">(* keep elements where f returns true *)</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="dt">List</span>.fold_left f acc lst       <span class="co">(* fold from left (tail-recursive) *)</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="dt">List</span>.fold_right f lst acc      <span class="co">(* fold from right *)</span></span></code></pre></div>
</div></p><p><span style="font-weight: bold">Tuples and Records</span>
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>(e1, e2, e3)                   <span class="co">(* tuple *)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (a, b) = tup               <span class="co">(* destructure a tuple *)</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>{ f1 = e1; f2 = e2 }          <span class="co">(* record value *)</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>r.f1                           <span class="co">(* access field f1 *)</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> { f1; f2 } = r             <span class="co">(* destructure a record *)</span></span></code></pre></div>
</div></p><p><span style="font-weight: bold">Exceptions</span>
<div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">exception</span> E                    <span class="co">(* declare exception without data *)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">exception</span> E <span class="kw">of</span> t               <span class="co">(* declare exception with data *)</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="dt">raise</span> E                        <span class="co">(* raise an exception *)</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">try</span> e <span class="kw">with</span>                     <span class="co">(* catch exceptions *)</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>| E -&gt; e1</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>| E x -&gt; e2</span></code></pre></div>
</div></p><p><div class="SIntrapara"><span style="font-weight: bold">Common Operators</span>
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="boxed" style="border-collapse: collapse;"><tr><td align="left" style="border: 1px solid black;"><p><span style="font-weight: bold">Operation</span></p></td><td align="left" style="border: 1px solid black;"><p><span style="font-weight: bold">int</span></p></td><td align="left" style="border: 1px solid black;"><p><span style="font-weight: bold">float</span></p></td></tr><tr><td align="left" style="border: 1px solid black;"><p>Addition</p></td><td align="left" style="border: 1px solid black;"><p><span class="stt">+</span></p></td><td align="left" style="border: 1px solid black;"><p><span class="stt">+.</span></p></td></tr><tr><td align="left" style="border: 1px solid black;"><p>Subtraction</p></td><td align="left" style="border: 1px solid black;"><p><span class="stt">-</span></p></td><td align="left" style="border: 1px solid black;"><p><span class="stt">-.</span></p></td></tr><tr><td align="left" style="border: 1px solid black;"><p>Multiplication</p></td><td align="left" style="border: 1px solid black;"><p><span class="stt">*</span></p></td><td align="left" style="border: 1px solid black;"><p><span class="stt">*.</span></p></td></tr><tr><td align="left" style="border: 1px solid black;"><p>Division</p></td><td align="left" style="border: 1px solid black;"><p><span class="stt">/</span></p></td><td align="left" style="border: 1px solid black;"><p><span class="stt">/.</span></p></td></tr><tr><td align="left" style="border: 1px solid black;"><p>Modulo</p></td><td align="left" style="border: 1px solid black;"><p><span class="stt">mod</span></p></td><td align="left" style="border: 1px solid black;"><p>&#8212;</p></td></tr><tr><td align="left" style="border: 1px solid black;"><p>Equality</p></td><td align="left" style="border: 1px solid black;"><p><span class="stt">=</span></p></td><td align="left" style="border: 1px solid black;"><p><span class="stt">=</span></p></td></tr><tr><td align="left" style="border: 1px solid black;"><p>Inequality</p></td><td align="left" style="border: 1px solid black;"><p><span class="stt">&lt;&gt;</span></p></td><td align="left" style="border: 1px solid black;"><p><span class="stt">&lt;&gt;</span></p></td></tr><tr><td align="left" style="border: 1px solid black;"><p>String concat</p></td><td align="left" style="border: 1px solid black;"><p><span class="stt">^</span></p></td><td align="left" style="border: 1px solid black;"><p>&#8212;</p></td></tr><tr><td align="left" style="border: 1px solid black;"><p>List cons</p></td><td align="left" style="border: 1px solid black;"><p><span class="stt">::</span></p></td><td align="left" style="border: 1px solid black;"><p>&#8212;</p></td></tr><tr><td align="left" style="border: 1px solid black;"><p>List append</p></td><td align="left" style="border: 1px solid black;"><p><span class="stt">@</span></p></td><td align="left" style="border: 1px solid black;"><p>&#8212;</p></td></tr></table></div></p></section></section><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="intro.html" title="backward to &quot;1 Introduction&quot;" data-pltdoc="x" rel="prev">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;CMSC 330 Lecture Notes&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="imperative-ocaml.html" title="forward to &quot;3 Imperative Programming with OCaml&quot;" data-pltdoc="x" rel="next">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>