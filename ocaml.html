<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>1&nbsp;Functional Programming with OCaml</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><link rel="stylesheet" type="text/css" href="extra.css" title="default"/><link rel="stylesheet" type="text/css" href="fancyverb.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript">
(function() {document.write('<scr' + 'ipt type="text/javascript" src="MathJax/MathJax.js?config=default"></scr' + 'ipt>');})();
</script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">CMSC 330 Lecture Notes</a></td></tr></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Functional Programming with OCaml</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="Imperative_OCaml.html" class="tocviewlink" data-pltdoc="x">Imperative Programming with OCaml</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="pbt.html" class="tocviewlink" data-pltdoc="x">Property-<wbr></wbr>Based Randomized Testing</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="regexp.html" class="tocviewlink" data-pltdoc="x">OCaml Regular Expressions</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="Finite_Automata.html" class="tocviewlink" data-pltdoc="x">Finite Automata</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td>1&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Functional Programming with OCaml</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">1.1&nbsp;</td><td><a href="#%28part._.Books%29" class="tocviewlink" data-pltdoc="x">Books</a></td></tr><tr><td align="right">1.2&nbsp;</td><td><a href="#%28part._.Installing_.O.Caml%29" class="tocviewlink" data-pltdoc="x">Installing OCaml</a></td></tr><tr><td align="right">1.3&nbsp;</td><td><a href="#%28part.__.O.P.A.M__.O.Caml_.Package_.Manager%29" class="tocviewlink" data-pltdoc="x"> OPAM:<span class="mywbr"> &nbsp;</span> OCaml Package Manager</a></td></tr><tr><td align="right">1.4&nbsp;</td><td><a href="#%28part.__.Working_with_.O.Caml%29" class="tocviewlink" data-pltdoc="x"> Working with OCaml</a></td></tr><tr><td align="right">1.5&nbsp;</td><td><a href="#%28part._.Project_.Builds_with_dune%29" class="tocviewlink" data-pltdoc="x">Project Builds with dune</a></td></tr><tr><td align="right">1.6&nbsp;</td><td><a href="#%28part.__.O.Caml_.Basics%29" class="tocviewlink" data-pltdoc="x"> OCaml Basics</a></td></tr><tr><td align="right">1.7&nbsp;</td><td><a href="#%28part._.O.Caml_toplevel__a_.R.E.P.L_for_.O.Caml%29" class="tocviewlink" data-pltdoc="x">OCaml toplevel, a REPL for OCaml</a></td></tr><tr><td align="right">1.8&nbsp;</td><td><a href="#%28part._.First_.O.Caml_.Example%29" class="tocviewlink" data-pltdoc="x">First OCaml Example</a></td></tr><tr><td align="right">1.9&nbsp;</td><td><a href="#%28part._.Expressions%29" class="tocviewlink" data-pltdoc="x">Expressions</a></td></tr><tr><td align="right">1.10&nbsp;</td><td><a href="#%28part._.Values%29" class="tocviewlink" data-pltdoc="x">Values</a></td></tr><tr><td align="right">1.11&nbsp;</td><td><a href="#%28part._.Types%29" class="tocviewlink" data-pltdoc="x">Types</a></td></tr><tr><td align="right">1.12&nbsp;</td><td><a href="#%28part._if_expression%29" class="tocviewlink" data-pltdoc="x">if expression</a></td></tr><tr><td align="right">1.13&nbsp;</td><td><a href="#%28part._.Functions%29" class="tocviewlink" data-pltdoc="x">Functions</a></td></tr><tr><td align="right">1.14&nbsp;</td><td><a href="#%28part._.Lists%29" class="tocviewlink" data-pltdoc="x">Lists</a></td></tr><tr><td align="right">1.15&nbsp;</td><td><a href="#%28part._.Pattern_.Matching%29" class="tocviewlink" data-pltdoc="x">Pattern Matching</a></td></tr><tr><td align="right">1.16&nbsp;</td><td><a href="#%28part._.Lists_and_.Recursion%29" class="tocviewlink" data-pltdoc="x">Lists and Recursion</a></td></tr><tr><td align="right">1.17&nbsp;</td><td><a href="#%28part.__.Let_.Expressions%29" class="tocviewlink" data-pltdoc="x"> Let Expressions</a></td></tr><tr><td align="right">1.18&nbsp;</td><td><a href="#%28part._.Tuples%29" class="tocviewlink" data-pltdoc="x">Tuples</a></td></tr><tr><td align="right">1.19&nbsp;</td><td><a href="#%28part._.Records%29" class="tocviewlink" data-pltdoc="x">Records</a></td></tr><tr><td align="right">1.20&nbsp;</td><td><a href="#%28part._.Anonymous_.Functions%29" class="tocviewlink" data-pltdoc="x">Anonymous Functions</a></td></tr><tr><td align="right">1.21&nbsp;</td><td><a href="#%28part._.Higher_.Order_.Functions%29" class="tocviewlink" data-pltdoc="x">Higher Order Functions</a></td></tr><tr><td align="right">1.22&nbsp;</td><td><a href="#%28part._.Map%29" class="tocviewlink" data-pltdoc="x">Map</a></td></tr><tr><td align="right">1.23&nbsp;</td><td><a href="#%28part._.Tail_.Recursion%29" class="tocviewlink" data-pltdoc="x">Tail Recursion</a></td></tr><tr><td align="right">1.24&nbsp;</td><td><a href="#%28part._.O.Caml_.Data_.Types__.Variants_%29" class="tocviewlink" data-pltdoc="x">OCaml Data Types (Variants)</a></td></tr><tr><td align="right">1.25&nbsp;</td><td><a href="#%28part._.User_.Defined_.Types%29" class="tocviewlink" data-pltdoc="x">User Defined Types</a></td></tr><tr><td align="right">1.26&nbsp;</td><td><a href="#%28part._.Exceptions%29" class="tocviewlink" data-pltdoc="x">Exceptions</a></td></tr><tr><td align="right">1.27&nbsp;</td><td><a href="#%28part._.Closures%29" class="tocviewlink" data-pltdoc="x">Closures</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">1.1<tt>&nbsp;</tt></span><a href="#%28part._.Books%29" class="tocsubseclink" data-pltdoc="x">Books</a></td></tr><tr><td><span class="tocsublinknumber">1.1.1<tt>&nbsp;</tt></span><a href="#%28part._.Similar_.Courses%29" class="tocsubseclink" data-pltdoc="x">Similar Courses</a></td></tr><tr><td><span class="tocsublinknumber">1.2<tt>&nbsp;</tt></span><a href="#%28part._.Installing_.O.Caml%29" class="tocsubseclink" data-pltdoc="x">Installing OCaml</a></td></tr><tr><td><span class="tocsublinknumber">1.3<tt>&nbsp;</tt></span><a href="#%28part.__.O.P.A.M__.O.Caml_.Package_.Manager%29" class="tocsubseclink" data-pltdoc="x"> OPAM:<span class="mywbr"> &nbsp;</span> OCaml Package Manager</a></td></tr><tr><td><span class="tocsublinknumber">1.4<tt>&nbsp;</tt></span><a href="#%28part.__.Working_with_.O.Caml%29" class="tocsubseclink" data-pltdoc="x"> Working with OCaml</a></td></tr><tr><td><span class="tocsublinknumber">1.5<tt>&nbsp;</tt></span><a href="#%28part._.Project_.Builds_with_dune%29" class="tocsubseclink" data-pltdoc="x">Project Builds with dune</a></td></tr><tr><td><span class="tocsublinknumber">1.6<tt>&nbsp;</tt></span><a href="#%28part.__.O.Caml_.Basics%29" class="tocsubseclink" data-pltdoc="x"> OCaml Basics</a></td></tr><tr><td><span class="tocsublinknumber">1.7<tt>&nbsp;</tt></span><a href="#%28part._.O.Caml_toplevel__a_.R.E.P.L_for_.O.Caml%29" class="tocsubseclink" data-pltdoc="x">OCaml toplevel, a REPL for OCaml</a></td></tr><tr><td><span class="tocsublinknumber">1.8<tt>&nbsp;</tt></span><a href="#%28part._.First_.O.Caml_.Example%29" class="tocsubseclink" data-pltdoc="x">First OCaml Example</a></td></tr><tr><td><span class="tocsublinknumber">1.9<tt>&nbsp;</tt></span><a href="#%28part._.Expressions%29" class="tocsubseclink" data-pltdoc="x">Expressions</a></td></tr><tr><td><span class="tocsublinknumber">1.10<tt>&nbsp;</tt></span><a href="#%28part._.Values%29" class="tocsubseclink" data-pltdoc="x">Values</a></td></tr><tr><td><span class="tocsublinknumber">1.11<tt>&nbsp;</tt></span><a href="#%28part._.Types%29" class="tocsubseclink" data-pltdoc="x">Types</a></td></tr><tr><td><span class="tocsublinknumber">1.12<tt>&nbsp;</tt></span><a href="#%28part._if_expression%29" class="tocsubseclink" data-pltdoc="x">if expression</a></td></tr><tr><td><span class="tocsublinknumber">1.13<tt>&nbsp;</tt></span><a href="#%28part._.Functions%29" class="tocsubseclink" data-pltdoc="x">Functions</a></td></tr><tr><td><span class="tocsublinknumber">1.13.1<tt>&nbsp;</tt></span><a href="#%28part._.Calling_.Functions__.Function_.Application_%29" class="tocsubseclink" data-pltdoc="x">Calling Functions (Function Application)</a></td></tr><tr><td><span class="tocsublinknumber">1.13.2<tt>&nbsp;</tt></span><a href="#%28part._.Function_.Types%29" class="tocsubseclink" data-pltdoc="x">Function Types</a></td></tr><tr><td><span class="tocsublinknumber">1.13.3<tt>&nbsp;</tt></span><a href="#%28part._.Type_.Checking_of_.Function_application%29" class="tocsubseclink" data-pltdoc="x">Type Checking of Function application</a></td></tr><tr><td><span class="tocsublinknumber">1.13.4<tt>&nbsp;</tt></span><a href="#%28part._.More_.Examples_on_.Function_.Type_.Checking%29" class="tocsubseclink" data-pltdoc="x">More Examples on Function Type Checking</a></td></tr><tr><td><span class="tocsublinknumber">1.13.5<tt>&nbsp;</tt></span><a href="#%28part._.Mutually_.Recusrive_.Functions%29" class="tocsubseclink" data-pltdoc="x">Mutually Recusrive Functions</a></td></tr><tr><td><span class="tocsublinknumber">1.13.6<tt>&nbsp;</tt></span><a href="#%28part._.Polymorphic_.Types%29" class="tocsubseclink" data-pltdoc="x">Polymorphic Types</a></td></tr><tr><td><span class="tocsublinknumber">1.13.7<tt>&nbsp;</tt></span><a href="#%28part._.Type_annotations%29" class="tocsubseclink" data-pltdoc="x">Type annotations</a></td></tr><tr><td><span class="tocsublinknumber">1.14<tt>&nbsp;</tt></span><a href="#%28part._.Lists%29" class="tocsubseclink" data-pltdoc="x">Lists</a></td></tr><tr><td><span class="tocsublinknumber">1.14.1<tt>&nbsp;</tt></span><a href="#%28part._.Typing_.Lists%29" class="tocsubseclink" data-pltdoc="x">Typing Lists</a></td></tr><tr><td><span class="tocsublinknumber">1.14.2<tt>&nbsp;</tt></span><a href="#%28part.____.Operator%29" class="tocsubseclink" data-pltdoc="x">:<span class="mywbr"> &nbsp;</span>:<span class="mywbr"> &nbsp;</span> Operator</a></td></tr><tr><td><span class="tocsublinknumber">1.14.3<tt>&nbsp;</tt></span><a href="#%28part._.Lists_of_.Lists%29" class="tocsubseclink" data-pltdoc="x">Lists of Lists</a></td></tr><tr><td><span class="tocsublinknumber">1.15<tt>&nbsp;</tt></span><a href="#%28part._.Pattern_.Matching%29" class="tocsubseclink" data-pltdoc="x">Pattern Matching</a></td></tr><tr><td><span class="tocsublinknumber">1.15.1<tt>&nbsp;</tt></span><a href="#%28part._.Pattern_.Matching_.Lists%29" class="tocsubseclink" data-pltdoc="x">Pattern Matching Lists</a></td></tr><tr><td><span class="tocsublinknumber">1.15.2<tt>&nbsp;</tt></span><a href="#%28part._.Pattern_.Matching_~e2~80~93_.An_.Abbreviation%29" class="tocsubseclink" data-pltdoc="x">Pattern Matching &#8211; An Abbreviation</a></td></tr><tr><td><span class="tocsublinknumber">1.16<tt>&nbsp;</tt></span><a href="#%28part._.Lists_and_.Recursion%29" class="tocsubseclink" data-pltdoc="x">Lists and Recursion</a></td></tr><tr><td><span class="tocsublinknumber">1.17<tt>&nbsp;</tt></span><a href="#%28part.__.Let_.Expressions%29" class="tocsubseclink" data-pltdoc="x"> Let Expressions</a></td></tr><tr><td><span class="tocsublinknumber">1.17.1<tt>&nbsp;</tt></span><a href="#%28part._.Let_.Definitions_vs__.Let_.Expressions_%29" class="tocsubseclink" data-pltdoc="x">Let Definitions vs. Let Expressions </a></td></tr><tr><td><span class="tocsublinknumber">1.17.2<tt>&nbsp;</tt></span><a href="#%28part._.Let_.Expressions__.Scope%29" class="tocsubseclink" data-pltdoc="x">Let Expressions:<span class="mywbr"> &nbsp;</span> Scope</a></td></tr><tr><td><span class="tocsublinknumber">1.17.3<tt>&nbsp;</tt></span><a href="#%28part._.Nested_.Let_.Expressions%29" class="tocsubseclink" data-pltdoc="x">Nested Let Expressions</a></td></tr><tr><td><span class="tocsublinknumber">1.17.4<tt>&nbsp;</tt></span><a href="#%28part._.Let_.Expressions_in_.Functions%29" class="tocsubseclink" data-pltdoc="x">Let Expressions in Functions</a></td></tr><tr><td><span class="tocsublinknumber">1.17.5<tt>&nbsp;</tt></span><a href="#%28part._.Shadowing_.Names%29" class="tocsubseclink" data-pltdoc="x">Shadowing Names</a></td></tr><tr><td><span class="tocsublinknumber">1.18<tt>&nbsp;</tt></span><a href="#%28part._.Tuples%29" class="tocsubseclink" data-pltdoc="x">Tuples</a></td></tr><tr><td><span class="tocsublinknumber">1.18.1<tt>&nbsp;</tt></span><a href="#%28part._.Pattern_.Matching_.Tuples%29" class="tocsubseclink" data-pltdoc="x">Pattern Matching Tuples</a></td></tr><tr><td><span class="tocsublinknumber">1.19<tt>&nbsp;</tt></span><a href="#%28part._.Records%29" class="tocsubseclink" data-pltdoc="x">Records</a></td></tr><tr><td><span class="tocsublinknumber">1.20<tt>&nbsp;</tt></span><a href="#%28part._.Anonymous_.Functions%29" class="tocsubseclink" data-pltdoc="x">Anonymous Functions</a></td></tr><tr><td><span class="tocsublinknumber">1.20.1<tt>&nbsp;</tt></span><a href="#%28part._.Functions_and_.Binding%29" class="tocsubseclink" data-pltdoc="x">Functions and Binding</a></td></tr><tr><td><span class="tocsublinknumber">1.21<tt>&nbsp;</tt></span><a href="#%28part._.Higher_.Order_.Functions%29" class="tocsubseclink" data-pltdoc="x">Higher Order Functions</a></td></tr><tr><td><span class="tocsublinknumber">1.22<tt>&nbsp;</tt></span><a href="#%28part._.Map%29" class="tocsubseclink" data-pltdoc="x">Map</a></td></tr><tr><td><span class="tocsublinknumber">1.22.1<tt>&nbsp;</tt></span><a href="#%28part._.Implementing_map%29" class="tocsubseclink" data-pltdoc="x">Implementing map</a></td></tr><tr><td><span class="tocsublinknumber">1.22.2<tt>&nbsp;</tt></span><a href="#%28part._.Fold%29" class="tocsubseclink" data-pltdoc="x">Fold</a></td></tr><tr><td><span class="tocsublinknumber">1.23<tt>&nbsp;</tt></span><a href="#%28part._.Tail_.Recursion%29" class="tocsubseclink" data-pltdoc="x">Tail Recursion</a></td></tr><tr><td><span class="tocsublinknumber">1.23.1<tt>&nbsp;</tt></span><a href="#%28part._fold_left_vs_fold_right%29" class="tocsubseclink" data-pltdoc="x">fold_<span class="mywbr"> &nbsp;</span>left vs fold_<span class="mywbr"> &nbsp;</span>right</a></td></tr><tr><td><span class="tocsublinknumber">1.23.2<tt>&nbsp;</tt></span><a href="#%28part._.Tail_.Recursion_.Pattern%29" class="tocsubseclink" data-pltdoc="x">Tail Recursion Pattern</a></td></tr><tr><td><span class="tocsublinknumber">1.24<tt>&nbsp;</tt></span><a href="#%28part._.O.Caml_.Data_.Types__.Variants_%29" class="tocsubseclink" data-pltdoc="x">OCaml Data Types (Variants)</a></td></tr><tr><td><span class="tocsublinknumber">1.25<tt>&nbsp;</tt></span><a href="#%28part._.User_.Defined_.Types%29" class="tocsubseclink" data-pltdoc="x">User Defined Types</a></td></tr><tr><td><span class="tocsublinknumber">1.25.1<tt>&nbsp;</tt></span><a href="#%28part._.Option_.Type%29" class="tocsubseclink" data-pltdoc="x">Option Type</a></td></tr><tr><td><span class="tocsublinknumber">1.25.2<tt>&nbsp;</tt></span><a href="#%28part._.Recursive_.Data_.Types%29" class="tocsubseclink" data-pltdoc="x">Recursive Data Types</a></td></tr><tr><td><span class="tocsublinknumber">1.25.3<tt>&nbsp;</tt></span><a href="#%28part._.Polymorphic_.List%29" class="tocsubseclink" data-pltdoc="x">Polymorphic List</a></td></tr><tr><td><span class="tocsublinknumber">1.25.4<tt>&nbsp;</tt></span><a href="#%28part._.Binary_.Trees%29" class="tocsubseclink" data-pltdoc="x">Binary Trees</a></td></tr><tr><td><span class="tocsublinknumber">1.25.5<tt>&nbsp;</tt></span><a href="#%28part._.N-ary_.Trees%29" class="tocsubseclink" data-pltdoc="x">N-<wbr></wbr>ary Trees</a></td></tr><tr><td><span class="tocsublinknumber">1.26<tt>&nbsp;</tt></span><a href="#%28part._.Exceptions%29" class="tocsubseclink" data-pltdoc="x">Exceptions</a></td></tr><tr><td><span class="tocsublinknumber">1.27<tt>&nbsp;</tt></span><a href="#%28part._.Closures%29" class="tocsubseclink" data-pltdoc="x">Closures</a></td></tr><tr><td><span class="tocsublinknumber">1.27.1<tt>&nbsp;</tt></span><a href="#%28part._.Multi-argument_.Functions%29" class="tocsubseclink" data-pltdoc="x">Multi-<wbr></wbr>argument Functions</a></td></tr><tr><td><span class="tocsublinknumber">1.27.2<tt>&nbsp;</tt></span><a href="#%28part._.Currying%29" class="tocsubseclink" data-pltdoc="x">Currying</a></td></tr><tr><td><span class="tocsublinknumber">1.27.3<tt>&nbsp;</tt></span><a href="#%28part._.How_.Do_.We_.Implement_.Currying_%29" class="tocsubseclink" data-pltdoc="x">How Do We Implement Currying?</a></td></tr><tr><td><span class="tocsublinknumber">1.27.4<tt>&nbsp;</tt></span><a href="#%28part._.Environment%29" class="tocsubseclink" data-pltdoc="x">Environment</a></td></tr><tr><td><span class="tocsublinknumber">1.27.5<tt>&nbsp;</tt></span><a href="#%28part._.Scope%29" class="tocsubseclink" data-pltdoc="x">Scope</a></td></tr><tr><td><span class="tocsublinknumber">1.27.6<tt>&nbsp;</tt></span><a href="#%28part._.Higher-.Order_.Functions_in_.C%29" class="tocsubseclink" data-pltdoc="x">Higher-<wbr></wbr>Order Functions in C</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">8.17</span></div><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="index.html" title="backward to &quot;CMSC 330 Lecture Notes&quot;" data-pltdoc="x" rel="prev">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;CMSC 330 Lecture Notes&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="Imperative_OCaml.html" title="forward to &quot;2 Imperative Programming with OCaml&quot;" data-pltdoc="x" rel="next">next &rarr;</a></span>&nbsp;</div><h3 class="heading">1<tt>&nbsp;</tt><a name="(part._ocaml)"></a>Functional Programming with OCaml<span class="button-group"><a href="#(part._ocaml)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h3><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Books%29" class="toclink" data-pltdoc="x">1.1<span class="hspace">&nbsp;</span>Books</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Installing_.O.Caml%29" class="toclink" data-pltdoc="x">1.2<span class="hspace">&nbsp;</span>Installing OCaml</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part.__.O.P.A.M__.O.Caml_.Package_.Manager%29" class="toclink" data-pltdoc="x">1.3<span class="hspace">&nbsp;</span> OPAM: OCaml Package Manager</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part.__.Working_with_.O.Caml%29" class="toclink" data-pltdoc="x">1.4<span class="hspace">&nbsp;</span> Working with OCaml</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Project_.Builds_with_dune%29" class="toclink" data-pltdoc="x">1.5<span class="hspace">&nbsp;</span>Project Builds with dune</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part.__.O.Caml_.Basics%29" class="toclink" data-pltdoc="x">1.6<span class="hspace">&nbsp;</span> OCaml Basics</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.O.Caml_toplevel__a_.R.E.P.L_for_.O.Caml%29" class="toclink" data-pltdoc="x">1.7<span class="hspace">&nbsp;</span>OCaml toplevel, a REPL for OCaml</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.First_.O.Caml_.Example%29" class="toclink" data-pltdoc="x">1.8<span class="hspace">&nbsp;</span>First OCaml Example</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Expressions%29" class="toclink" data-pltdoc="x">1.9<span class="hspace">&nbsp;</span>Expressions</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Values%29" class="toclink" data-pltdoc="x">1.10<span class="hspace">&nbsp;</span>Values</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Types%29" class="toclink" data-pltdoc="x">1.11<span class="hspace">&nbsp;</span>Types</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._if_expression%29" class="toclink" data-pltdoc="x">1.12<span class="hspace">&nbsp;</span>if expression</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Functions%29" class="toclink" data-pltdoc="x">1.13<span class="hspace">&nbsp;</span>Functions</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Lists%29" class="toclink" data-pltdoc="x">1.14<span class="hspace">&nbsp;</span>Lists</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Pattern_.Matching%29" class="toclink" data-pltdoc="x">1.15<span class="hspace">&nbsp;</span>Pattern Matching</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Lists_and_.Recursion%29" class="toclink" data-pltdoc="x">1.16<span class="hspace">&nbsp;</span>Lists and Recursion</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part.__.Let_.Expressions%29" class="toclink" data-pltdoc="x">1.17<span class="hspace">&nbsp;</span> Let Expressions</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Tuples%29" class="toclink" data-pltdoc="x">1.18<span class="hspace">&nbsp;</span>Tuples</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Records%29" class="toclink" data-pltdoc="x">1.19<span class="hspace">&nbsp;</span>Records</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Anonymous_.Functions%29" class="toclink" data-pltdoc="x">1.20<span class="hspace">&nbsp;</span>Anonymous Functions</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Higher_.Order_.Functions%29" class="toclink" data-pltdoc="x">1.21<span class="hspace">&nbsp;</span>Higher Order Functions</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Map%29" class="toclink" data-pltdoc="x">1.22<span class="hspace">&nbsp;</span>Map</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Tail_.Recursion%29" class="toclink" data-pltdoc="x">1.23<span class="hspace">&nbsp;</span>Tail Recursion</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.O.Caml_.Data_.Types__.Variants_%29" class="toclink" data-pltdoc="x">1.24<span class="hspace">&nbsp;</span>OCaml Data Types (Variants)</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.User_.Defined_.Types%29" class="toclink" data-pltdoc="x">1.25<span class="hspace">&nbsp;</span>User Defined Types</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Exceptions%29" class="toclink" data-pltdoc="x">1.26<span class="hspace">&nbsp;</span>Exceptions</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Closures%29" class="toclink" data-pltdoc="x">1.27<span class="hspace">&nbsp;</span>Closures</a></p></td></tr></table><p><div class="SIntrapara">OCaml is a dialect of the ML programming language family, developed in France at INRIA. OCaml is the main implementation of the programming language Caml. The features of ML include:
</div><div class="SIntrapara"><ul><li><p>First-class functions</p></li><li><ul><li><p> Functions can be data. We can send functions as  parameters to other functions and return functions as return values.</p></li></ul></li><li><p>Favor immutability (assign once)</p></li><li><p>Data types and pattern matching</p></li><li><ul><li><p>Convenient for certain kinds of data structures</p></li></ul></li><li><p>Type inference</p></li><li><ul><li><p>OCaml is statically typed, but there is no need to write types in the source language</p></li><li><p>Supports parametric polymorphism, similar to Generics in Java, templates in C++</p></li></ul></li><li><p>Exceptions</p></li><li><p>Garbage collection</p></li></ul></div><div class="SIntrapara">Modern programming languages have borrowed many ideas from functional programming, including first-class functions, anonymous functions, and garbage collection.</div></p><h4 class="heading">1.1<tt>&nbsp;</tt><a name="(part._.Books)"></a>Books<span class="button-group"><a href="#(part._.Books)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p><div class="SIntrapara">Below is a list of free online books available on OCaml.
</div><div class="SIntrapara"><ul><li><p>Developing Applications with Objective Caml <a href="https://caml.inria.fr/pub/docs/oreilly-book/ocaml-ora-book.pdf">https://caml.inria.fr/pub/docs/oreilly-book/ocaml-ora-book.pdf</a></p></li><li><p>Introduction to the Objective Caml Programming Language <a href="http://courses.cms.caltech.edu/cs134/cs134b/book.pdf">http://courses.cms.caltech.edu/cs134/cs134b/book.pdf</a></p></li><li><p>Real World OCaml 2nd Edition <a href="https://dev.realworldocaml.org/">https://dev.realworldocaml.org/</a></p></li><li><p>OCaml from the Very Beginning <a href="https://johnwhitington.net/ocamlfromtheverybeginning/mlbook.pdf">https://johnwhitington.net/ocamlfromtheverybeginning/mlbook.pdf</a></p></li><li><p>Cornell cs3110 book <a href="https://cs3110.github.io/textbook/cover.html">https://cs3110.github.io/textbook/cover.html</a> is another course which uses OCaml; it is more focused on programming and less on PL theory than this class is.</p></li><li><p><a href="ocaml.org">ocaml.org</a> is the home of OCaml for finding downloads, documentation, etc. The tutorials are also very good and there is a page of books.</p></li></ul></div></p><h5 class="heading">1.1.1<tt>&nbsp;</tt><a name="(part._.Similar_.Courses)"></a>Similar Courses<span class="button-group"><a href="#(part._.Similar_.Courses)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>If you&rsquo;re interested, I&#8217;ve listed several similar courses from other universities. For example, Cornell offers a comparable course&#8212;CS 3110&#8212;and there are also similar offerings from the University of Washington, Princeton, Harvard, and UIUC. You can check out their websites; Cornell&#8217;s, in particular, provides an online textbook along with videos and other helpful resources.</p><p>You might find it helpful to watch their lectures, go through their examples, or even try out their projects or exams. They all use OCaml, and the course structure is quite similar.</p><p>So, it&#8217;s more than just a textbook&#8212;you have access to notes, slides, exams, and other useful materials.</p><ul><li><p>CS3110 (Cornell)</p></li><li><p>CSE341 (Washington)</p></li><li><p>601.426 (Johns Hopkins)</p></li><li><p>COS326 (Princeton)</p></li><li><p>CS152 (Harvard)</p></li><li><p>CS421 (UIUC)</p></li></ul><h4 class="heading">1.2<tt>&nbsp;</tt><a name="(part._.Installing_.O.Caml)"></a>Installing OCaml<span class="button-group"><a href="#(part._.Installing_.O.Caml)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Install the latest version of OCaml from https://ocaml.org/</p><h4 class="heading">1.3<tt>&nbsp;</tt><a name="(part.__.O.P.A.M__.O.Caml_.Package_.Manager)"></a> OPAM: OCaml Package Manager<span class="button-group"><a href="#(part.__.O.P.A.M__.O.Caml_.Package_.Manager)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p><div class="SIntrapara">Opam is the package manager for OCaml. It manages libraries and different compiler installations. For the class projects, you should install the following packages with <span style="font-weight: bold">opam</span>.
</div><div class="SIntrapara"><ul><li><p>ounit, a testing framework similar to minitest</p></li><li><p>utop, a top-level interface</p></li><li><p>dune, a build system for larger projects</p></li></ul></div></p><h4 class="heading">1.4<tt>&nbsp;</tt><a name="(part.__.Working_with_.O.Caml)"></a> Working with OCaml<span class="button-group"><a href="#(part.__.Working_with_.O.Caml)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>OCaml programs can be compiled using <span style="font-weight: bold">ocamlc</span>. It produces <span style="font-weight: bold"></span>.cmo (compiled object) and {.cmi} (compiled interface) files. You can use <span style="font-weight: bold">-o</span> to set output file name, and use <span style="font-weight: bold">-c</span> to compile only to <span style="font-weight: bold">.cmo/.cmi</span> and not to link. You can also compile with <span style="font-weight: bold">ocamlopt</span>. It produces <span style="font-weight: bold">cmx</span> files, which contain native code: faster, but not platform-independent (or as easily debugged)</p><h4 class="heading">1.5<tt>&nbsp;</tt><a name="(part._.Project_.Builds_with_dune)"></a>Project Builds with dune<span class="button-group"><a href="#(part._.Project_.Builds_with_dune)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>You use <span style="font-weight: bold">dune</span> to compile projects. It automatically finds dependencies, invokes compiler and linker. Let us create a new project with <span style="font-weight: bold">dune</span>:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">shell</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode fish"><code class="sourceCode fish"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="er">&gt;</span> dune init project HelloWorld</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">Entering</span> directory &#39;<span class="st">/Users/anwar/git/2025Fall/CMSC330/cmsc330-notes/notes/code/HelloWorld&#39;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">Success:</span> initialized project component named HelloWorld</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="fu">Leaving</span> directory &#39;<span class="st">/Users/anwar/git/2025Fall/CMSC330/cmsc330-notes/notes/code/HelloWorld&#39;</span></span></code></pre></div>
</p></blockquote></blockquote><p><div class="SIntrapara">It creates a &lsquo;HelloWorld&lsquo; project with the following files:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">shell</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode fish"><code class="sourceCode fish"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="er">&gt;</span> tree HelloWorld</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">HelloWorld</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>â”œâ”€â”€ <span class="fu">HelloWorld.opam</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>â”œâ”€â”€ <span class="fu">_build</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>â”‚Â Â  â””â”€â”€ <span class="fu">log</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>â”œâ”€â”€ <span class="fu">bin</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>â”‚Â Â  â”œâ”€â”€ <span class="fu">dune</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>â”‚Â Â  â””â”€â”€ <span class="fu">main.ml</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>â”œâ”€â”€ <span class="fu">dune-project</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>â”œâ”€â”€ <span class="fu">lib</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>â”‚Â Â  â””â”€â”€ <span class="fu">dune</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>â””â”€â”€ <span class="bu">test</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    â”œâ”€â”€ <span class="fu">dune</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    â””â”€â”€ <span class="fu">test_HelloWorld.ml</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>5 <span class="fu">directories,</span> 8 files</span></code></pre></div>
</p></blockquote></blockquote></div></p><p>Build the project:
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>dune build</span></code></pre></div>
</p><p>Run it:
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>dune exec bin/main.exe</span></code></pre></div>

or
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>_build/default/main.exe</span></code></pre></div>

Run the tests
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>dune runtest</span></code></pre></div>
</p><h4 class="heading">1.6<tt>&nbsp;</tt><a name="(part.__.O.Caml_.Basics)"></a> OCaml Basics<span class="button-group"><a href="#(part.__.O.Caml_.Basics)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p><div class="SIntrapara">OCaml files are written with a &ldquo;.ml&ldquo; extension. An OCaml file is similar to a Python file: when run, it evaluates the file directly. There is no special main function. An OCaml file consists of
</div><div class="SIntrapara"><ul><li><p>A series of open statements for including other modules</p></li><li><p>A series of declarations for defining datatypes, functions, and constants</p></li><li><p>A series of (though often just one) toplevel expressions to evaluate.</p></li></ul></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* A small OCaml program *)</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="dt">print_string</span> <span class="st">&quot;Hello world!</span><span class="ch">\n</span><span class="st">&quot;</span>;;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>Hello world!</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">unit</span> = ()</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">Or
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">open</span> <span class="dt">Printf</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> message = <span class="st">&quot;Hello world&quot;</span>;; </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> (printf <span class="st">&quot;%s</span><span class="ch">\n</span><span class="st">&quot;</span> message);;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> message : <span class="dt">string</span> = <span class="st">&quot;Hello world&quot;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>Hello world</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">unit</span> = ()</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">The first line includes the built-in library for printing, which provides functions similar to <span style="font-weight: bold">fprintf</span> and <span style="font-weight: bold">printf</span>
 from <span style="font-weight: bold">stdlib</span> in <span style="font-weight: bold">C</span>. The next two lines define a constant named message, and then call the <span style="font-weight: bold">&lsquo;printf</span> function with a format string (where &lsquo;%s&lsquo; means "format as string"), and the constant message we defined on the line before.</div></p><p><div class="SIntrapara">To compile and run
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">shell</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode fish"><code class="sourceCode fish"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="er">&gt;</span> ocamlc hello.ml -o hello</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="er">&gt;</span> ./hello</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">Hello</span> world!</span></code></pre></div>
</p></blockquote></blockquote></div></p><p><div class="SIntrapara">We can also compile multiple files to generate a single executable.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><a href="code/main.ml"><span class="stt">main.ml</span></a></span></p><blockquote class="Rfilecontent"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">*</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">main.ml</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">*</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym">let</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">main</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">=</span><span class="RktMeta"></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym">print_int</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">Util.add</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">10</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">20</span><span class="RktPn">)</span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">print_string</span><span class="hspace">&nbsp;</span><span class="RktCmt">"\n"</span><span class="RktMeta"></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym">let</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">main</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta">&#160;</span></td></tr></table></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><a href="code/util.ml"><span class="stt">util.ml</span></a></span></p><blockquote class="Rfilecontent"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">*</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">util.ml</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">*</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym">let</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">add</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">x</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">y</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">x</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">+</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">y</span><span class="RktMeta"></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta">&#160;</span></td></tr></table></blockquote></blockquote></div></p><p>Compile and run:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">shell</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode fish"><code class="sourceCode fish"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="er">&gt;</span> ocamlc util.ml main.ml -o main</span></code></pre></div>
</p></blockquote></blockquote><p>Or compile separately</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">shell</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode fish"><code class="sourceCode fish"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="er">&gt;</span> ocamlc -c util.ml</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="er">&gt;</span> ocamlc util.cmo main.ml</span></code></pre></div>
</p></blockquote></blockquote><p><div class="SIntrapara">It generates an executable <span style="font-weight: bold">main</span>. We can execute it by
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">shell</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode fish"><code class="sourceCode fish"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="er">&gt;</span> ./main</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>30</span></code></pre></div>
</p></blockquote></blockquote></div></p><h4 class="heading">1.7<tt>&nbsp;</tt><a name="(part._.O.Caml_toplevel__a_.R.E.P.L_for_.O.Caml)"></a>OCaml toplevel, a REPL for OCaml<span class="button-group"><a href="#(part._.O.Caml_toplevel__a_.R.E.P.L_for_.O.Caml)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>We will begin exploration of OCaml in the interactive top level. A top level is also called a read-eval-print loop (REPL) and it works like a terminal shell. To run the ocaml topleve, simply run &lsquo;ocaml&lsquo;
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> % ocaml</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> OCaml version <span class="fl">5.2</span>.<span class="dv">0</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> # <span class="dt">print_string</span> <span class="st">&quot;Hello world!</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;</span>;;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    Hello world!</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a> - : <span class="dt">unit</span> = ()</span></code></pre></div>

There is an alternative toplevel called <span style="font-weight: bold">utop</span>. It is more user friendly, and we will be using &lsquo;utop&lsquo; in the class. You can install <span style="font-weight: bold">utop</span> by runnung <span style="font-weight: bold">opam install utop</span>&lsquo;. Follow the instructions in the project 0 for installing opam and ocaml.</p><p>To load a &lsquo;.ml&lsquo; file into top level:
<pre class="&quot;ocaml&quot;"><code>
&quot;#use &quot;hello.ml&quot;

Hello world!
- : unit = ()</code></pre>
</p><p><div class="SIntrapara">To exit the top-level, type <span style="font-weight: bold">^D</span> (Control D) or call the exit 0
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt"># exit 0;;</span></p></td></tr></table></div></p><h4 class="heading">1.8<tt>&nbsp;</tt><a name="(part._.First_.O.Caml_.Example)"></a>First OCaml Example<span class="button-group"><a href="#(part._.First_.O.Caml_.Example)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* A small OCaml program (* with nested comments *) *)</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> x = <span class="dv">37</span>;; </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> y = x + <span class="dv">5</span>;; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> <span class="dt">print_int</span> y;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> x : <span class="dt">int</span> = <span class="dv">37</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> y : <span class="dt">int</span> = <span class="dv">42</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="dv">42</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">unit</span> = ()</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote><p><div class="SIntrapara">OCaml is strictly typed. It does not implicitly cast types. For example, <span style="font-weight: bold">print_int</span> only prints <span style="font-weight: bold">int</span>s.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">print_int</span> <span class="dv">10</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="dv">10</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">unit</span> = ()</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara"><span style="font-weight: bold">( )</span> is called unit. It is similar to &lsquo;void&lsquo; in other languages. Following expressions do not type check
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">print_int</span> <span class="fl">10.5</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>Line <span class="dv">1</span>, characters <span class="dv">10-14</span>:</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> | <span class="dt">print_int</span> <span class="fl">10.5</span>;;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>              ^^^^</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>Error: The constant <span class="st">&quot;10.5&quot;</span> has <span class="kw">type</span> <span class="st">&quot;float&quot;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>       but an expression was expected <span class="kw">of</span> <span class="kw">type</span> <span class="st">&quot;int&quot;</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">becase <span style="font-weight: bold">print_int</span> does not take <span style="font-weight: bold">float</span> as an argument. The following code does not typecheck because <span style="font-weight: bold">+</span> operator requires both operands are integers. Adding a float to an integer results in a type error.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> + <span class="fl">0.5</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>Line <span class="dv">1</span>, characters <span class="dv">4-7</span>:</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> | <span class="dv">1</span> + <span class="fl">0.5</span>;;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>        ^^^</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>Error: The constant <span class="st">&quot;0.5&quot;</span> has <span class="kw">type</span> <span class="st">&quot;float&quot;</span> but an expression was expected <span class="kw">of</span> <span class="kw">type</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>         <span class="st">&quot;int&quot;</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">Adding a boolean to an integer results in a type error too.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> + <span class="kw">true</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>Line <span class="dv">1</span>, characters <span class="dv">4-8</span>:</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> | <span class="dv">1</span> + <span class="kw">true</span>;;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>        ^^^^</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>Error: The constructor <span class="st">&quot;true&quot;</span> has <span class="kw">type</span> <span class="st">&quot;bool&quot;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>       but an expression was expected <span class="kw">of</span> <span class="kw">type</span> <span class="st">&quot;int&quot;</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><p><div class="SIntrapara">As expected, <span style="font-weight: bold">print_int</span> does not a string as an argument.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">print_int</span> <span class="st">&quot;This function expected an int&quot;</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>Line <span class="dv">1</span>, characters <span class="dv">10-41</span>:</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> | <span class="dt">print_int</span> <span class="st">&quot;This function expected an int&quot;</span>;;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>Error: This constant has <span class="kw">type</span> <span class="st">&quot;string&quot;</span> but an expression was expected <span class="kw">of</span> <span class="kw">type</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>         <span class="st">&quot;int&quot;</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><h4 class="heading">1.9<tt>&nbsp;</tt><a name="(part._.Expressions)"></a>Expressions<span class="button-group"><a href="#(part._.Expressions)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>In OCaml, expressions are the fundamental building blocks of programs, and evaluating an expression always produces a value. Unlike many imperative languages, which distinguish between statements (actions) and expressions (values), OCaml is expression-oriented&#8212;almost everything in the language is an expression that yields a result.</p><p><div class="SIntrapara">Every kind of expression has syntax and semantics. Semantics include:
 </div><div class="SIntrapara"><ul><li><p>Type checking rules (static semantics): produce a type or fail with an error message</p></li><li><p>Evaluation rules (dynamic semantics): produce a value or an exception or infinite loop. Evaluation rules are used only on expressions that type-check</p></li></ul></div></p><p>We use metavariable <span style="font-weight: bold">e</span> to designate an arbitrary expression.</p><h4 class="heading">1.10<tt>&nbsp;</tt><a name="(part._.Values)"></a>Values<span class="button-group"><a href="#(part._.Values)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>A value is an expression that is final. For example, <span style="font-weight: bold">34</span> and <span style="font-weight: bold">true</span> are values because we cannot evaluate them any further. On the contrary, <span style="font-weight: bold">34+17</span> is an expression, but not a value because we can further evaluate it. Evaluating an expression means running it until it is a value. For example <span style="font-weight: bold">34+17</span> evaluates to 51, which is a value. We use metavariable <span style="font-weight: bold">v</span> to designate an arbitrary value</p><h4 class="heading">1.11<tt>&nbsp;</tt><a name="(part._.Types)"></a>Types<span class="button-group"><a href="#(part._.Types)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Types classify expressions. It is the set of values an expression could evaluate to. Examples include &lsquo;int&lsquo;, &lsquo;bool&lsquo;, &lsquo;string&lsquo;, and more. We use metavariable <span style="font-weight: bold">t</span> to designate an arbitrary type. Expression <span style="font-weight: bold">e</span> has type <span style="font-weight: bold">t</span> if <span style="font-weight: bold">e</span> will (always) evaluate to a value of type <span style="font-weight: bold">t</span>. For example <span style="font-weight: bold">0</span>, <span style="font-weight: bold">1</span>, and <span style="font-weight: bold">-1</span> are values of type <span style="font-weight: bold">int</span> while <span style="font-weight: bold">true</span> has type <span style="font-weight: bold">bool</span>. <span style="font-weight: bold">34+17</span> is an expression of type <span style="font-weight: bold">int</span>, since it evaluates to <span style="font-weight: bold">51</span>, which has type <span style="font-weight: bold">int</span>. We usually write <span style="font-weight: bold">e : t</span> to say <span style="font-weight: bold">e</span> has type <span style="font-weight: bold">t</span>.  The process of determining <span style="font-weight: bold">e</span> has type <span style="font-weight: bold">t</span> is called <span style="font-weight: bold">type checking</span> simply, <span style="font-weight: bold">typing</span>.</p><h4 class="heading">1.12<tt>&nbsp;</tt><a name="(part._if_expression)"></a>if expression<span class="button-group"><a href="#(part._if_expression)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>The syntax of the if expression is
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span> e1 <span class="kw">then</span> e2 <span class="kw">else</span> e3</span></code></pre></div>
</p><p>We type check the if expression using the following type checking rules:
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span> e1 : <span class="dt">bool</span> <span class="kw">and</span> e2 : t <span class="kw">and</span> e3 : t <span class="kw">then</span>  <span class="kw">if</span> e1 <span class="kw">then</span> e2 <span class="kw">else</span> e3 : t</span></code></pre></div>
</p><ul><li><p>Condition must be a bool: The expression e1 (the condition) must have type bool. For example, writing if 1 then ... causes a type error, since 1 has type int, not bool.</p></li><li><p>Then- and Else-branches must have the same type: Both e2 and e3 must evaluate to values of the same type.</p></li></ul><p><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span> <span class="dv">7</span> &gt; <span class="dv">42</span> <span class="kw">then</span> <span class="st">&quot;hello&quot;</span> <span class="kw">else</span> <span class="st">&quot;goodbye&quot;</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">string</span> = <span class="st">&quot;goodbye&quot;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">The follwing expression does not type check because the two branches of the &lsquo;if&lsquo; expressin do not return the same type. The &lsquo;true&lsquo; branch returns &lsquo;string&lsquo;, while the &lsquo;false&lsquo; branch returns &lsquo;int&lsquo;
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span> <span class="dv">7</span> &gt; <span class="dv">42</span> <span class="kw">then</span> <span class="st">&quot;hello&quot;</span> <span class="kw">else</span> <span class="dv">10</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>Line <span class="dv">1</span>, characters <span class="dv">28-30</span>:</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> | <span class="kw">if</span> <span class="dv">7</span> &gt; <span class="dv">42</span> <span class="kw">then</span> <span class="st">&quot;hello&quot;</span> <span class="kw">else</span> <span class="dv">10</span>;;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>                                ^^</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>Error: The constant <span class="st">&quot;10&quot;</span> has <span class="kw">type</span> <span class="st">&quot;int&quot;</span> but an expression was expected <span class="kw">of</span> <span class="kw">type</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>         <span class="st">&quot;string&quot;</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><p>Display fraction: <div class="math">\frac{a}{b}</div></p><p><div class="SIntrapara">Evaluating an <span style="font-weight: bold">if</span> expression returns a value. For example, evaluaing <div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">if</span> <span class="dv">10</span> &gt; <span class="dv">5</span> <span class="kw">then</span> <span class="dv">100</span> <span class="kw">else</span> <span class="dv">200</span>)</span></code></pre></div>
 retuens <span style="font-weight: bold">100</span>.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">print_int</span> (<span class="kw">if</span> <span class="dv">10</span>&gt;<span class="dv">5</span> <span class="kw">then</span> <span class="dv">100</span> <span class="kw">else</span> <span class="dv">200</span>);;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="dv">100</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">unit</span> = ()</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><h4 class="heading">1.13<tt>&nbsp;</tt><a name="(part._.Functions)"></a>Functions<span class="button-group"><a href="#(part._.Functions)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>OCaml functions are like mathematical functions. They compute a result from provided arguments. We use &lsquo;let&lsquo; to define a function:</p><p>We now define the function <span style="font-weight: bold">next</span>, which accepts an integer <span style="font-weight: bold">n</span> and produces its successor.</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> next n = n + <span class="dv">1</span>;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> next <span class="dv">10</span>;;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> next : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">11</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote><p><div class="SIntrapara">Here is another function Factorial:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> fact n = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> n = <span class="dv">0</span> <span class="kw">then</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>       <span class="dv">1</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>       n * fact (n<span class="dv">-1</span>);; </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a> fact <span class="dv">5</span>;;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> fact : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">120</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara"><span style="font-weight: bold">rec</span> keyword is used to define <span style="font-weight: bold">recursive</span> functions. <span style="font-weight: bold">;;</span> ends an expression in the top-level of OCaml. We use it to say:  &#8220;Give me the value of this expression&#8221;. It is not used in the body of a function and it is not needed in the real OCaml development.</div></p><h5 class="heading">1.13.1<tt>&nbsp;</tt><a name="(part._.Calling_.Functions__.Function_.Application_)"></a>Calling Functions (Function Application)<span class="button-group"><a href="#(part._.Calling_.Functions__.Function_.Application_)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>In OCaml, calling a function is very straightforward &#8212; you just write the function name followed by its arguments, separated by spaces (not commas, and no parentheses are required unless for grouping). The calling syntax is:</p><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>f e1 e2 â€¦ en</span></code></pre></div>

Here is an example where we call the function <span style="font-weight: bold">square</span> with the argument <span style="font-weight: bold">5</span>.</p><p><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> square x = x * x;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> square <span class="dv">5</span>;;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> square : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">25</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">Nullary functions (Functions with no arguments) are a little special compared to languages like C or Python.</div></p><p>OCaml does not truly have &#8220;argumentless&#8221; functions. Instead, a nullary function is defined as one that takes the special value <span style="font-weight: bold">( )</span> of type <span style="font-weight: bold">unit</span>.</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> greet () = <span class="st">&quot;Hello&quot;</span>;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> greet ();;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> greet : <span class="dt">unit</span> -&gt; <span class="dt">string</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">string</span> = <span class="st">&quot;Hello&quot;</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote><p><div class="SIntrapara">We evaluate a function call expression according to these steps:
</div><div class="SIntrapara"><ul><li><p>Locate the definition of <span style="font-weight: bold">f</span>, i.e., <span style="font-weight: bold">let rec f x1 &#8230; xn = e</span>.</p></li><li><p>Evaluate the arguments <span style="font-weight: bold">e1 &#8230; en</span> to obtain values <span style="font-weight: bold">v1 &#8230; vn</span>.</p></li><li><p>Substitute the values <span style="font-weight: bold">v1 &#8230; vn</span> for the parameters <span style="font-weight: bold">x1 &#8230; xn</span> in the function body <span style="font-weight: bold">e</span>, yielding a new expression <span style="font-weight: bold">e&#8217;</span>.</p></li><li><p>Evaluate <span style="font-weight: bold">e&#8217;</span> to value <span style="font-weight: bold">v</span>, which is the final result</p></li></ul></div></p><p><div class="SIntrapara">Follwoing is an example of evaluating <span style="font-weight: bold">fact 2</span>
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> fact n = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> n = <span class="dv">0</span> <span class="kw">then</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>         <span class="dv">1</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>      <span class="kw">else</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>         n * fact (n<span class="dv">-1</span>);;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> fact : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td><p><span style="font-weight: bold">expression</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span style="font-weight: bold">semantics</span></p></td></tr><tr><td><p><span class="emph">fact 2</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p>substitute every occurence of n inside the body of fact with 2 </p></td></tr><tr><td><p><span class="emph">if 2=0 then 1 else 2*fact(2-1)</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p>evaluate the if expression</p></td></tr><tr><td><p><span class="emph">2 * fact 1</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p>result of the else branch</p></td></tr><tr><td><p><span class="emph">2 * (if 1=0 then 1 else 1*fact(1-1))</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p>substitute n with 1</p></td></tr><tr><td><p><span class="emph">2 * 1 * fact 0</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p>evaluate fact 0</p></td></tr><tr><td><p><span class="emph">2 * 1 * (if 0=0 then 1 else 0*fact(0-1))</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p>base case</p></td></tr><tr><td><p><span class="emph">2 * 1 * 1</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p></p></td></tr><tr><td><p><span class="emph">2</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p></p></td></tr></table></div></p><h5 class="heading">1.13.2<tt>&nbsp;</tt><a name="(part._.Function_.Types)"></a>Function Types<span class="button-group"><a href="#(part._.Function_.Types)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>In OCaml, <span style="font-weight: bold">&#8594;</span> is the function type constructor. Type <span style="font-weight: bold">t1 &#8594; t</span> is a function
with argument or domain type <span style="font-weight: bold">t1</span> and return or range type <span style="font-weight: bold">t</span>. Type
<span style="font-weight: bold">t1 &#8594; t2 &#8594; t</span> is a function that takes two inputs, of types <span style="font-weight: bold">t1</span> and <span style="font-weight: bold">t2</span>,
and returns a value of type <span style="font-weight: bold">t</span>.</p><h5 class="heading">1.13.3<tt>&nbsp;</tt><a name="(part._.Type_.Checking_of_.Function_application)"></a>Type Checking of Function application<span class="button-group"><a href="#(part._.Type_.Checking_of_.Function_application)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>As we have seen before, the syntax of a function application is
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>f e1 â€¦ en</span></code></pre></div>
</p><p>We use the following type checking rule for the function application:
If <span style="font-weight: bold">f : t1 &#8594; &#8230; &#8594; tn &#8594; u</span> and   <span style="font-weight: bold">e1 : t1,  &#8230;, en : tn</span> then
the type of <span style="font-weight: bold">f e1 &#8230; en</span> is <span style="font-weight: bold">u</span>.</p><p>For example: the type of <span style="font-weight: bold">not true</span> is <span style="font-weight: bold">bool</span> because <span style="font-weight: bold">not : bool &#8594; bool</span> and <span style="font-weight: bold">true : bool</span>.</p><h5 class="heading">1.13.4<tt>&nbsp;</tt><a name="(part._.More_.Examples_on_.Function_.Type_.Checking)"></a>More Examples on Function Type Checking<span class="button-group"><a href="#(part._.More_.Examples_on_.Function_.Type_.Checking)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p><div class="SIntrapara">The function <span style="font-weight: bold">next</span> calculates the next integer.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> next x = x + <span class="dv">1</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> next : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><p><div class="SIntrapara">Here is how &lsquo;ocaml&lsquo; inferred the type of <span style="font-weight: bold">next</span> as <span style="font-weight: bold">int&#8594;int</span>: <span style="font-weight: bold">+</span> is an integer addition operator. Both operands of <span style="font-weight: bold">+</span> must be integer. It means <span style="font-weight: bold">x</span> must be an integer. There the argument type and return type are <span style="font-weight: bold">int</span>. <span style="font-weight: bold">next</span> is a function, which takes an <span style="font-weight: bold">int</span> as n argument, and returns an <span style="font-weight: bold">int</span> value.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> next x = x + <span class="dv">1</span>;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> next <span class="dv">10</span>;;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> next : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">11</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">Calling next with an argument of a different type results in a type-checking error.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> next x = x + <span class="dv">1</span>;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> next <span class="fl">10.5</span>;;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> next : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>Line <span class="dv">1</span>, characters <span class="dv">6-10</span>:</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> |  next <span class="fl">10.5</span>;;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>          ^^^^</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>Error: The constant <span class="st">&quot;10.5&quot;</span> has <span class="kw">type</span> <span class="st">&quot;float&quot;</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>       but an expression was expected <span class="kw">of</span> <span class="kw">type</span> <span class="st">&quot;int&quot;</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><p><div class="SIntrapara">The following functions <span style="font-weight: bold">swap</span> and <span style="font-weight: bold">eq</span> are polymorphic function. The types <span style="font-weight: bold">&rsquo;a</span> and <span style="font-weight: bold">&rsquo;b</span> can be read as <span style="font-weight: bold">for all type a and b</span>
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* Swapping two values of a tuple (we will cover tuples later) *)</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> swap (x,y) = (y,x);;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> swap : &#39;a * &#39;b -&gt; &#39;b * &#39;a = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* Comparing other types *)</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> eq x y = x = y;; </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> eq <span class="dv">1</span> <span class="dv">2</span>;; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> eq <span class="st">&quot;hello&quot;</span> <span class="st">&quot;hello&quot;</span>;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> eq : &#39;a -&gt; &#39;a -&gt; <span class="dt">bool</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a># - : <span class="dt">bool</span> = <span class="kw">false</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">bool</span> = <span class="kw">true</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">The function <span style="font-weight: bold">eq</span>, take the arguments of any type as long as the two arguments have the same type.</div></p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* Adding two integers *)</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> add x y = x + y;;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> add : <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote><p><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> fn x = (<span class="dt">int_of_float</span> x) * <span class="dv">3</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> fn : <span class="dt">float</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* factorial function *)</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> <span class="kw">rec</span> fact n = </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> n = <span class="dv">0</span> <span class="kw">then</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>       <span class="dv">1</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>       n * fact (n<span class="dv">-1</span>);;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> fact : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* Sum of the first n natural numbers *)</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> <span class="kw">rec</span> sum n = </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> n == <span class="dv">0</span> <span class="kw">then</span> <span class="dv">0</span> <span class="kw">else</span> n + sum (n<span class="dv">-1</span>);;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> sum : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><h5 class="heading">1.13.5<tt>&nbsp;</tt><a name="(part._.Mutually_.Recusrive_.Functions)"></a>Mutually Recusrive Functions<span class="button-group"><a href="#(part._.Mutually_.Recusrive_.Functions)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Mutually recursive functions are functions that call each other (directly or indirectly). You define them using the <span style="font-weight: bold">and</span> keyword along with <span style="font-weight: bold">let rec</span>.</p><p><div class="SIntrapara">Suppose we want two functions, <span style="font-weight: bold">even</span> and <span style="font-weight: bold">odd</span>, to determine whether a number is even or odd, with <span style="font-weight: bold">even</span> calling <span style="font-weight: bold">odd</span> and <span style="font-weight: bold">odd</span> calling <span style="font-weight: bold">even</span>. We define them together using <span style="font-weight: bold">let rec ... and</span>
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> odd n = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> n == <span class="dv">0</span> <span class="kw">then</span> <span class="kw">false</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> even(n<span class="dv">-1</span>) </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> <span class="kw">and</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    even n = </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> n == <span class="dv">0</span> <span class="kw">then</span> <span class="kw">true</span> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>      <span class="kw">else</span> odd(n<span class="dv">-1</span>);;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> odd : <span class="dt">int</span> -&gt; <span class="dt">bool</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> even : <span class="dt">int</span> -&gt; <span class="dt">bool</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><h5 class="heading">1.13.6<tt>&nbsp;</tt><a name="(part._.Polymorphic_.Types)"></a>Polymorphic Types<span class="button-group"><a href="#(part._.Polymorphic_.Types)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>This says the function takes a list of any element type &lsquo;&rsquo;a&lsquo;, and returns something of that same type.
These are basically generic types in Java. &lsquo;&rsquo;a list&lsquo; is like &lsquo;List&lt;T&gt;&lsquo;.</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="dt">fst</span> x y = x;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="dt">fst</span> <span class="dv">1</span> <span class="st">&quot;hello&quot;</span>;; </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="dt">fst</span> [<span class="dv">1</span>; <span class="dv">2</span>] <span class="dv">1</span>;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> <span class="dt">fst</span> : &#39;a -&gt; &#39;b -&gt; &#39;a = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a># - : <span class="dt">int</span> = <span class="dv">1</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">1</span>; <span class="dv">2</span>]</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> eq x y = x = y;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> eq <span class="dv">1</span> <span class="dv">2</span>;; </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> eq <span class="st">&quot;hello&quot;</span> <span class="st">&quot;there&quot;</span>;; </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> eq <span class="st">&quot;hello&quot;</span> <span class="dv">1</span>;;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> eq : &#39;a -&gt; &#39;a -&gt; <span class="dt">bool</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a># - : <span class="dt">bool</span> = <span class="kw">false</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a># - : <span class="dt">bool</span> = <span class="kw">false</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>Line <span class="dv">1</span>, characters <span class="dv">12-13</span>:</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> |  eq <span class="st">&quot;hello&quot;</span> <span class="dv">1</span>;;</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>                ^</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>Error: The constant <span class="st">&quot;1&quot;</span> has <span class="kw">type</span> <span class="st">&quot;int&quot;</span> but an expression was expected <span class="kw">of</span> <span class="kw">type</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>         <span class="st">&quot;string&quot;</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote><h5 class="heading">1.13.7<tt>&nbsp;</tt><a name="(part._.Type_annotations)"></a>Type annotations<span class="button-group"><a href="#(part._.Type_annotations)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p><div class="SIntrapara">The OCaml compiler can infer types automatically, but type inference can be tricky and sometimes produces vague error messages. To avoid this, we can provide type annotations manually.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (x : <span class="dt">int</span>) = <span class="dv">3</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> x : <span class="dt">int</span> = <span class="dv">3</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> fn (x:<span class="dt">int</span>):<span class="dt">float</span> = (<span class="dt">float_of_int</span> x) *. <span class="fl">3.14</span>;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> add (x:<span class="dt">int</span>) (y:<span class="dt">int</span>):<span class="dt">int</span> = x + y;;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> fn : <span class="dt">int</span> -&gt; <span class="dt">float</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> add : <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> id x = x;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> id : &#39;a -&gt; &#39;a = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> id (x:<span class="dt">int</span>) = x;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> id : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><h4 class="heading">1.14<tt>&nbsp;</tt><a name="(part._.Lists)"></a>Lists<span class="button-group"><a href="#(part._.Lists)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p><div class="SIntrapara">The list is a fundamental data structure in OCaml. Lists can have arbitrary length and are implemented as linked structures. All elements in a list must be of the same type (i.e., lists are homogeneous). We will learn how to construct lists and deconstruct them using pattern matching.
In OCaml, <span style="font-weight: bold">[ ]</span> is a value, represents an empty list. Elements are separated by semicolons.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>[];; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">4</span>];; </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> [<span class="st">&quot;apple&quot;</span>; <span class="st">&quot;banana&quot;</span>; <span class="st">&quot;cherry&quot;</span>];;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a># - : &#39;a <span class="dt">list</span> = []</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a># - : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">4</span>]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">string</span> <span class="dt">list</span> = [<span class="st">&quot;apple&quot;</span>; <span class="st">&quot;banana&quot;</span>; <span class="st">&quot;cherry&quot;</span>]</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><p>To evaluate <span style="font-weight: bold">[e1; e1;...;en]</span>, we evaluate <span style="font-weight: bold">e1</span> to a value <span style="font-weight: bold">v1</span>, <span style="font-weight: bold">e2</span> to a value <span style="font-weight: bold">v2</span>, and <span style="font-weight: bold">en</span> to a value <span style="font-weight: bold">vn</span>, and return <span style="font-weight: bold">[v1;&#8230;;vn]</span>.</p><p>In OCaml, the list notation [e1; e2] is syntactic sugar for using the cons operator ::(pronounced &#8220;cons&#8221;). <span style="font-weight: bold">::</span> constructs a list by prepending an element to an existing list. Specifically:
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>[e1; e2];;  <span class="co">(* sugar syntax *)</span></span></code></pre></div>

is equivalent to:
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>e1 :: e2 :: [];;  <span class="co">(* desugared form *)</span></span></code></pre></div>
</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> y = [<span class="dv">1</span>; <span class="dv">1</span>+<span class="dv">1</span>; <span class="dv">1</span>+<span class="dv">1</span>+<span class="dv">1</span>] ;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> x = <span class="dv">4</span>::y ;; </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> z = <span class="dv">5</span>::y ;; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> m = <span class="st">&quot;hello&quot;</span> :: <span class="st">&quot;bob&quot;</span> ::[];;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> y : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> x : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">4</span>; <span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>]</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> z : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">5</span>; <span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>]</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> m : <span class="dt">string</span> <span class="dt">list</span> = [<span class="st">&quot;hello&quot;</span>; <span class="st">&quot;bob&quot;</span>]</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote><h5 class="heading">1.14.1<tt>&nbsp;</tt><a name="(part._.Typing_.Lists)"></a>Typing Lists<span class="button-group"><a href="#(part._.Typing_.Lists)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>The type of an empty list <span class="emph">[ ]</span> is <span style="font-weight: bold">&rsquo;a list</span>. The type of <span style="font-weight: bold">Cons</span> is
<span style="font-weight: bold">if e1 : t and e2 : t list then e1::e2 : t list</span>. If we add parentheses for clarity: <span style="font-weight: bold">if e1 : t</span> and <span style="font-weight: bold">e2 : (t list)</span> then <span style="font-weight: bold">(e1::e2) : (t list)</span>.</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> m = [[<span class="dv">1</span>];[<span class="dv">2</span>;<span class="dv">3</span>]];;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> m : <span class="dt">int</span> <span class="dt">list</span> <span class="dt">list</span> = [[<span class="dv">1</span>]; [<span class="dv">2</span>; <span class="dv">3</span>]]</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote><p><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> y = <span class="dv">0</span>::[<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>] ;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> y : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">0</span>; <span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>]</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = [<span class="dv">1</span>;<span class="st">&quot;world&quot;</span>] ;; <span class="co">(* all elements must have same type *)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>Line <span class="dv">1</span>, characters <span class="dv">11-18</span>:</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> | <span class="kw">let</span> x = [<span class="dv">1</span>;<span class="st">&quot;world&quot;</span>] ;; <span class="co">(* all elements must have same type *)</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>               ^^^^^^^</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>Error: This constant has <span class="kw">type</span> <span class="st">&quot;string&quot;</span> but an expression was expected <span class="kw">of</span> <span class="kw">type</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>         <span class="st">&quot;int&quot;</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><h5 class="heading">1.14.2<tt>&nbsp;</tt><a name="(part.____.Operator)"></a>:: Operator<span class="button-group"><a href="#(part.____.Operator)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p><div class="SIntrapara">&lsquo;::&lsquo; operator appends a single item, not a list, to the front of another list. The left argument of &lsquo;::&lsquo; is an element, the right is a list
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> y = <span class="dv">0</span>::[<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>] ;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> w = [<span class="dv">1</span>;<span class="dv">2</span>]::y ;; <span class="co">(* error *)</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> y : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">0</span>; <span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>]</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>Line <span class="dv">1</span>, characters <span class="dv">16-17</span>:</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> |  <span class="kw">let</span> w = [<span class="dv">1</span>;<span class="dv">2</span>]::y ;; <span class="co">(* error *)</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>                    ^</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>Error: The value <span class="st">&quot;y&quot;</span> has <span class="kw">type</span> <span class="st">&quot;int list&quot;</span> but an expression was expected <span class="kw">of</span> <span class="kw">type</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>         <span class="st">&quot;int list list&quot;</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>       Type <span class="st">&quot;int&quot;</span> is <span class="dt">not</span> compatible <span class="kw">with</span> <span class="kw">type</span> <span class="st">&quot;int list&quot;</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">Quiz: Can you construct a list y such that <span style="font-weight: bold">[1;2]::y</span> makes sense?</div></p><p>Yes. If the type of &lsquo;y&lsquo; is <span style="font-weight: bold">int list list</span>,i.e., <span style="font-weight: bold">[1;2]::[[3;4]]</span>. Each element of this list is an &lsquo;int list&lsquo;.</p><p>Lists in Ocaml are Linked. <span style="font-weight: bold">[1;2;3]</span> is represented as:
<img src="lists.png" alt="" width="536" height="211"/></p><p><div class="SIntrapara">A nonempty list is a <span style="font-weight: bold">pair (element, rest of list)</span>. The <span style="font-weight: bold">element</span> is the head of the list, and <span style="font-weight: bold">rest of the list</span>
 is itself a list. Thus in math (i.e., inductively) a list is either
</div><div class="SIntrapara"><ul><li><p>The empty list [ ]</p></li><li><p>Or a pair consisting of an element and a list</p></li></ul></div></p><p>This recursive structure will come in handy shortly</p><h5 class="heading">1.14.3<tt>&nbsp;</tt><a name="(part._.Lists_of_.Lists)"></a>Lists of Lists<span class="button-group"><a href="#(part._.Lists_of_.Lists)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p><div class="SIntrapara">Lists can be nested arbitrarily. For exmaple:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>[ [<span class="dv">9</span>; <span class="dv">10</span>; <span class="dv">11</span>]; [<span class="dv">5</span>; <span class="dv">4</span>; <span class="dv">3</span>; <span class="dv">2</span>] ];;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> <span class="dt">list</span> = [[<span class="dv">9</span>; <span class="dv">10</span>; <span class="dv">11</span>]; [<span class="dv">5</span>; <span class="dv">4</span>; <span class="dv">3</span>; <span class="dv">2</span>]]</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><p>The ype &lsquo;int list list&lsquo; can also be written as &lsquo;(int list) list&lsquo;.</p><p>Lists are immutable in OCaml; you cannot change an element of a list. Instead, you create new lists from existing ones, for example using the :: operator.</p><h4 class="heading">1.15<tt>&nbsp;</tt><a name="(part._.Pattern_.Matching)"></a>Pattern Matching<span class="button-group"><a href="#(part._.Pattern_.Matching)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>To pull lists apart, we use the &lsquo;match&lsquo; construct. The pattern-matching part of the
&lsquo;match&lsquo; is a sequence of clauses, each one of the form: <span style="font-weight: bold">pattern &#8594; expr</span>, separated by
vertical bars (|). The clauses are processed in order, and only the &lsquo;expr&lsquo; of first matching
 clause is evaluated. The value of the entire match expression is the value of the &lsquo;expr&lsquo;
 of the matching clause; If no &lsquo;pattern&lsquo; matches &lsquo;expr&lsquo;, your match is said to be
 &lsquo;non-exhaustive&lsquo; and when a match fails it raise the exception &lsquo;Match_failure&lsquo;.</p><p><div class="SIntrapara">The syntax of the match expressin is:
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">match</span> e <span class="kw">with</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>| p1 -&gt; e1 </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>| â€¦ </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>| pn -&gt; en</span></code></pre></div>

The type checking rules for the match expression:
Let t be the type of e.
</div><div class="SIntrapara"><ul><li><p>Each pattern pi must be a pattern of type t. (i.e., e and the patterns have same type)</p></li><li><p>Each branch expression ei must have the same type &#963;. So the whole match expression has type &#963;.</p></li></ul></div><div class="SIntrapara">For example: the function neg negates the boolean argument.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> neg x= </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> x <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    | <span class="kw">true</span> -&gt; <span class="kw">false</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    | <span class="kw">false</span> -&gt; <span class="kw">true</span>;; </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> neg <span class="kw">true</span>;; </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a> neg (<span class="dv">10</span> &gt; <span class="dv">20</span>);;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> neg : <span class="dt">bool</span> -&gt; <span class="dt">bool</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a># - : <span class="dt">bool</span> = <span class="kw">false</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">bool</span> = <span class="kw">true</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">The function is_zero checks if the argument is zero.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> is_zero n = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> n <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    | <span class="dv">0</span> -&gt; <span class="kw">true</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    | _ -&gt; <span class="kw">false</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> ;; </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> is_zero <span class="dv">1</span>;;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> is_zero : <span class="dt">int</span> -&gt; <span class="dt">bool</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">bool</span> = <span class="kw">false</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><p><div class="SIntrapara">The function <span style="font-weight: bold">is_odd</span> checks if a value is odd:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> is_odd x = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>          <span class="kw">match</span> x <span class="kw">mod</span> <span class="dv">2</span> <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>          <span class="dv">0</span> -&gt; <span class="kw">false</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>          | <span class="dv">1</span> -&gt; <span class="kw">true</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>          | _ -&gt; <span class="dt">raise</span> (<span class="dt">Invalid_argument</span> <span class="st">&quot;is_odd&quot;</span>);;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> is_odd : <span class="dt">int</span> -&gt; <span class="dt">bool</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">In <span style="font-weight: bold">is_odd</span>, why do we need the thrid match case <span style="font-weight: bold">| _ -&gt;</span>? Try -1 mod 2.</div></p><p><div class="SIntrapara">Logical implication
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> imply v = <span class="kw">match</span> v <span class="kw">with</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>                   (<span class="kw">true</span>,<span class="kw">true</span>)   -&gt; <span class="kw">true</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>             | (<span class="kw">true</span>,<span class="kw">false</span>)  -&gt; <span class="kw">false</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>             | (<span class="kw">false</span>,<span class="kw">true</span>)  -&gt; <span class="kw">true</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>             | (<span class="kw">false</span>,<span class="kw">false</span>) -&gt; <span class="kw">true</span>;;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> imply : <span class="dt">bool</span> * <span class="dt">bool</span> -&gt; <span class="dt">bool</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">Or, we can make it even simpler:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> imply v = <span class="kw">match</span> v <span class="kw">with</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">true</span>,x)  -&gt; x </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    | (<span class="kw">false</span>,x) -&gt; <span class="kw">true</span>;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> imply : <span class="dt">bool</span> * <span class="dt">bool</span> -&gt; <span class="dt">bool</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><p><div class="SIntrapara">For characters, OCaml also recognizes the range patterns in the form of &rsquo;c1&rsquo; .. &rsquo;cn&rsquo; as shorthand for any ASCII character in the range.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> is_vowel c = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>          <span class="kw">match</span> c <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>          (<span class="ch">&#39;a&#39;</span> | <span class="ch">&#39;e&#39;</span> | <span class="ch">&#39;i&#39;</span> | <span class="ch">&#39;o&#39;</span> | <span class="ch">&#39;u&#39;</span>) -&gt; <span class="kw">true</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>          | _ -&gt; <span class="kw">false</span>;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> is_vowel : <span class="dt">char</span> -&gt; <span class="dt">bool</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">Determine whether a character is uppercase:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> is_upper x = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> x <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="ch">&#39;A&#39;</span> .. <span class="ch">&#39;Z&#39;</span> -&gt; <span class="kw">true</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    | _ -&gt; <span class="kw">false</span>;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> is_upper : <span class="dt">char</span> -&gt; <span class="dt">bool</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><p>In OCaml, the underscore <span style="font-weight: bold">_</span> in a match is a wildcard pattern. It is like the default in the switch statement.
It matches anything, but doesn&#8217;t bind a variable to the value.</p><h5 class="heading">1.15.1<tt>&nbsp;</tt><a name="(part._.Pattern_.Matching_.Lists)"></a>Pattern Matching Lists<span class="button-group"><a href="#(part._.Pattern_.Matching_.Lists)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p><div class="SIntrapara">In OCaml, you can destruct lists using pattern matching by matching against the list constructors:
</div><div class="SIntrapara"><ul><li><p>[ ] represents the empty list.</p></li><li><p>h :: t (pronounced "head cons tail") represents a list with head element h and tail list t.</p></li></ul></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> is_empty l = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> l <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    | [] -&gt; <span class="kw">true</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    | h::t -&gt; <span class="kw">false</span>;; </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> is_empty [];; </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a> is_empty [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>];;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> is_empty : &#39;a <span class="dt">list</span> -&gt; <span class="dt">bool</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a># - : <span class="dt">bool</span> = <span class="kw">true</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">bool</span> = <span class="kw">false</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><p><div class="SIntrapara">Here are the primary techniques for destructuring lists with examples. Patterns can also be nested for more precise matches.
</div><div class="SIntrapara"><ul><li><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>a::b</span></code></pre></div>
 matches lists with <span style="font-weight: bold">at least one element</span>. For example:
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">match</span> [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>] <span class="kw">with</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> |a::b</span></code></pre></div>

matches and binds &lsquo;a&lsquo; to &lsquo;1&lsquo; and &lsquo;b&lsquo; to &lsquo;[2;3]&lsquo;</p></li><li><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>a::[]</span></code></pre></div>
 matches lists with <span style="font-weight: bold">exactly one element</span>. For example:
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">match</span> [<span class="dv">1</span>] <span class="kw">with</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>| a::[]</span></code></pre></div>

 binds &lsquo;a&lsquo; to &lsquo;1&lsquo;. we could also write pattern <span style="font-weight: bold">a::[]</span> as <span style="font-weight: bold">[a]</span></p></li><li><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>a::b::[]</span></code></pre></div>
 matches lists with <span style="font-weight: bold">exactly two elements</span>. For example:
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">match</span> [<span class="dv">1</span>;<span class="dv">2</span>] <span class="kw">with</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>|a::b::[]</span></code></pre></div>

 binds &lsquo;a&lsquo; to 1 and &lsquo;b&lsquo; to 2. We could also write pattern <span style="font-weight: bold">a::b::[]</span> as <span style="font-weight: bold">[a;b]</span></p></li><li><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>a::b::c::d</span></code></pre></div>
 matches lists with <span style="font-weight: bold">at least three elements</span>. For example:
  <div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">match</span> [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>] <span class="kw">with</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>|a::b::c::d</span></code></pre></div>

binds &lsquo;a&lsquo; to &lsquo;1&lsquo;, &lsquo;b&lsquo; to &lsquo;2&lsquo;, &lsquo;c&lsquo; to &lsquo;3&lsquo;, and &lsquo;d&lsquo; to &lsquo;[]&lsquo;.</p></li></ul></div></p><p>OCaml can detect non-exhaustive patterns and warn you about them. For example:
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> hd l = <span class="kw">match</span> l <span class="kw">with</span> (h::_) -&gt; h;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>Warning: this pattern-matching is <span class="dt">not</span> exhaustive.</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>Here is an example <span class="kw">of</span> a value that is <span class="dt">not</span> matched: []</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a># hd [];;</span></code></pre></div>
</p><p>Therefore, You can&#8217;t forget a case because compiler issues inexhaustive
pattern-match warning. You can&#8217;t duplicate a case because compiler issues
unused match case warning. Pattern matching leads to elegant, concise, beautiful code .</p><p>Quiz: Can write pattern as [a;b;c]::d (why?)</p><p>An underscore <span style="font-weight: bold">_</span> is a wildcard pattern. It matches anything, but doesn&#8217;t add any bindings. It is useful to
hold a place but discard the value i.e., when the variable does not appear in the branch expression.</p><p>In the earlier examples, many values of h or t were unused. In such cases, we can replace them with the wildcard _.
 For example, in the <span style="font-weight: bold">is_empty</span>, the h and t bindings are unused. We can replace them with <span style="font-weight: bold">_</span>.</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* cehck if a list is empty *)</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> is_empty l = </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> l <span class="kw">with</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    | [] -&gt; <span class="kw">true</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    | _::_ -&gt; <span class="kw">false</span>;; </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a> is_empty [];; </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a> is_empty [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>];; </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a> is_empty [<span class="st">&quot;a&quot;</span>; <span class="st">&quot;b&quot;</span>; <span class="st">&quot;c&quot;</span>];;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> is_empty : &#39;a <span class="dt">list</span> -&gt; <span class="dt">bool</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a># - : <span class="dt">bool</span> = <span class="kw">true</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a># - : <span class="dt">bool</span> = <span class="kw">false</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">bool</span> = <span class="kw">false</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote><p><div class="SIntrapara">Let&#8217;s define a function that computes the sum of all elements in an <span style="font-weight: bold">int list</span>.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> sum l = <span class="kw">match</span> l <span class="kw">with</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>      [] -&gt; <span class="dv">0</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    | (h::t) -&gt; h + (sum t);; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    sum [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>;<span class="dv">4</span>];;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> sum : <span class="dt">int</span> <span class="dt">list</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">10</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><p>The <span style="font-weight: bold">sum</span> function works only for int lists, but the <span style="font-weight: bold">is_empty</span> function works for any type of list.
OCaml gives such functions polymorphic types. <pre class="ocml"><code>is_empty : &#39;a list -&gt; bool</code></pre>
</p><h5 class="heading">1.15.2<tt>&nbsp;</tt><a name="(part._.Pattern_.Matching_~e2~80~93_.An_.Abbreviation)"></a>Pattern Matching &#8211; An Abbreviation<span class="button-group"><a href="#(part._.Pattern_.Matching_~e2~80~93_.An_.Abbreviation)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p><div class="SIntrapara">If there&#8217;s only one acceptable input, the pattern matching <div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f x = <span class="kw">match</span> x <span class="kw">with</span> p -&gt; e</span></code></pre></div>

can be abbreviated to <div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f p = e</span></code></pre></div>

</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="dt">fst</span> pair = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> pair <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    | (x, _) -&gt; x;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="dt">fst</span> : &#39;a * &#39;b -&gt; &#39;a = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">You can abbreviate by putting the pattern directly in the function parameter:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="dt">fst</span> (x, _) = x;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="dt">fst</span> : &#39;a * &#39;b -&gt; &#39;a = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><p><div class="SIntrapara">With the <span style="font-weight: bold">function</span> keyword, you can abbreviate
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f x = <span class="kw">match</span> x <span class="kw">with</span> ...</span></code></pre></div>
 to
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f = <span class="kw">function</span></span></code></pre></div>
 We can abbreviate
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f x = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> x <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    | <span class="dv">0</span> -&gt; <span class="st">&quot;zero&quot;</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    | <span class="dv">1</span> -&gt; <span class="st">&quot;one&quot;</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    | _ -&gt; <span class="st">&quot;many&quot;</span>;;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> f : <span class="dt">int</span> -&gt; <span class="dt">string</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">to
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f = <span class="kw">function</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    | <span class="dv">0</span> -&gt; <span class="st">&quot;zero&quot;</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    | <span class="dv">1</span> -&gt; <span class="st">&quot;one&quot;</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    | _ -&gt; <span class="st">&quot;many&quot;</span>;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> f : <span class="dt">int</span> -&gt; <span class="dt">string</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><h4 class="heading">1.16<tt>&nbsp;</tt><a name="(part._.Lists_and_.Recursion)"></a>Lists and Recursion<span class="button-group"><a href="#(part._.Lists_and_.Recursion)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p><div class="SIntrapara">Lists have a recursive structure and so most functions over lists will be recursive.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> length l = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> l <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    |[] -&gt; <span class="dv">0</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    | (_::t) -&gt; <span class="dv">1</span> + (length t);; </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    length [<span class="dv">1</span>;<span class="dv">3</span>;<span class="dv">6</span>;<span class="dv">9</span>];;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> length : &#39;a <span class="dt">list</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">4</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">This is just like an inductive definition:
</div><div class="SIntrapara"><ul><li><p>The length of the empty list is zero</p></li><li><p>The length of a nonempty list is 1 plus the length of the tail.</p></li></ul></div></p><p><div class="SIntrapara">Negate elements in list
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> negate l = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>          <span class="kw">match</span> l <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>       [] -&gt; [] </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>       | (h::t) -&gt; (-h) :: (negate t);; </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> negate [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">-10</span>];;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> negate : <span class="dt">int</span> <span class="dt">list</span> -&gt; <span class="dt">int</span> <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">-1</span>; <span class="dv">-2</span>; <span class="dv">10</span>]</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><p><div class="SIntrapara">Get the last element of a list
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> last l = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> l <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    | []-&gt;[] </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    |  [x] -&gt; [x] </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    | (h::t) -&gt; last t;; </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    last [];; </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    last [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>;<span class="dv">4</span>];;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> last : &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a># - : &#39;a <span class="dt">list</span> = []</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">4</span>]</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><p><div class="SIntrapara">Append two lists, that is, produce a list containing all elements of l followed by all elements of m.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> append l m = <span class="kw">match</span> l <span class="kw">with</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>     [] -&gt; m </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>   | (h::t) -&gt; h::(append t m);; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>     append [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>] [<span class="dv">4</span>;<span class="dv">5</span>;<span class="dv">6</span>];; </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a> <span class="co">(* Reversing a list *)</span> </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> <span class="kw">rec</span> rev l = <span class="kw">match</span> l <span class="kw">with</span> </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>      [] -&gt; [] </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    | (h::t) -&gt; append (rev t) [h];; </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    rev [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>;<span class="dv">4</span>];;</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> append : &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a># - : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">4</span>; <span class="dv">5</span>; <span class="dv">6</span>]</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> rev : &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">4</span>; <span class="dv">3</span>; <span class="dv">2</span>; <span class="dv">1</span>]</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">&lsquo;rev&lsquo; takes O(n2) time.  Can you do better? Here is a  clever version of reverse
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> rev_helper l a = <span class="kw">match</span> l <span class="kw">with</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    [] -&gt; a </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    | (x::xs) -&gt; rev_helper xs (x::a);; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> rev l = rev_helper l [];; </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a> rev [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>;<span class="dv">4</span>];;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> rev_helper : &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> rev : &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">4</span>; <span class="dv">3</span>; <span class="dv">2</span>; <span class="dv">1</span>]</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">Let&#8217;s give it a try
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>rev [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>] â†’</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>rev_helper [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>] [] â†’</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>rev_helper [<span class="dv">2</span>;<span class="dv">3</span>] [<span class="dv">1</span>] â†’</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>rev_helper [<span class="dv">3</span>] [<span class="dv">2</span>;<span class="dv">1</span>] â†’</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>rev_helper [] [<span class="dv">3</span>;<span class="dv">2</span>;<span class="dv">1</span>] â†’</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>[<span class="dv">3</span>;<span class="dv">2</span>;<span class="dv">1</span>]</span></code></pre></div>
</div></p><p><div class="SIntrapara">Check if x is member of a list
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> member lst x= </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">match</span> lst <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>                  |[]-&gt;<span class="kw">false</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>                  |h::t-&gt;<span class="kw">if</span> h = x <span class="kw">then</span> <span class="kw">true</span> <span class="kw">else</span> member t x </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>          ;;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> member : &#39;a <span class="dt">list</span> -&gt; &#39;a -&gt; <span class="dt">bool</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><p><div class="SIntrapara">Merge two sorted lists into one sorted list
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> merge l1 l2 = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> l1,l2 <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>     [],l-&gt;l </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>     |l,[]-&gt;l </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>     |(h1::t1, h2::t2)-&gt; </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>          <span class="kw">if</span> h1 &lt; h2 <span class="kw">then</span> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>            h1::merge t1 l2 </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>          <span class="kw">else</span> </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>            h2::merge l1 t2;; </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a> merge [<span class="dv">1</span>;<span class="dv">3</span>;<span class="dv">7</span>;<span class="dv">9</span>] [<span class="dv">2</span>;<span class="dv">3</span>;<span class="dv">4</span>;<span class="dv">5</span>;<span class="dv">6</span>];;</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> merge : &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">3</span>; <span class="dv">4</span>; <span class="dv">5</span>; <span class="dv">6</span>; <span class="dv">7</span>; <span class="dv">9</span>]</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><p><div class="SIntrapara">Insert x into a sorted list l in sorted order
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> insert x l= </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>          <span class="kw">match</span> l <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>          |[]-&gt;[x] </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>          |h::t-&gt;<span class="kw">if</span> x &lt; h <span class="kw">then</span> x::h::t </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>                          <span class="kw">else</span> h::insert x t;; </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    insert <span class="dv">10</span> [<span class="dv">5</span>;<span class="dv">9</span>;<span class="dv">20</span>;<span class="dv">30</span>];;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> insert : &#39;a -&gt; &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">5</span>; <span class="dv">9</span>; <span class="dv">10</span>; <span class="dv">20</span>; <span class="dv">30</span>]</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><p><div class="SIntrapara">Insertion sort
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> insert x l= </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>          <span class="kw">match</span> l <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>          |[]-&gt;[x] </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>          |h::t-&gt;<span class="kw">if</span> x &lt; h <span class="kw">then</span> x::h::t </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>                          <span class="kw">else</span> h::insert x t;; </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> <span class="kw">rec</span> sort l = </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">match</span> l <span class="kw">with</span> </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>                  []-&gt;[] </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>                  |[x]-&gt;[x] </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>                  |h::t-&gt;insert h (sort t);; </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a> sort [<span class="dv">1</span>;<span class="dv">6</span>;<span class="dv">2</span>;<span class="dv">10</span>;<span class="dv">-5</span>];;</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> insert : &#39;a -&gt; &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> sort : &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">-5</span>; <span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">6</span>; <span class="dv">10</span>]</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><p><div class="SIntrapara">QuickSort
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> qsort = <span class="kw">function</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>        | [] -&gt; []</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        | pivot :: rest -&gt;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> left, right = <span class="dt">List</span>.partition (<span class="kw">fun</span> x-&gt; x &lt; pivot) rest <span class="kw">in</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    qsort left @ [pivot] @ qsort right;;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> qsort : &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">MergeSort
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(** split list a into two even parts *)</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> split a = </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">rec</span> aux lst b c = </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">match</span> lst <span class="kw">with</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>                    [] -&gt; (b, c) </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>                  | hd :: tail -&gt; aux tail c (hd :: b) </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>          <span class="kw">in</span> aux a [] [];; </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a> <span class="co">(* merge lists xs and ys *)</span> </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> <span class="kw">rec</span> merge cmp xs ys = </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">match</span> (xs, ys) <span class="kw">with</span> </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>                    ([], []) -&gt; [] </span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>                  | (_, []) -&gt; xs </span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>                  | ([], _) -&gt; ys </span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>                  | (xhd :: xtail, yhd :: ytail) -&gt; </span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">if</span> (cmp xhd yhd) <span class="kw">then</span> </span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>                          xhd :: (merge cmp xtail ys) </span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>            <span class="kw">else</span> </span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>                          yhd :: (merge cmp xs ytail);; </span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> <span class="kw">rec</span> mergesort cmp os  = </span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">match</span> os <span class="kw">with</span> </span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>                  [] -&gt; [] </span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>                  | [x] -&gt; [x] </span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>                  | _ -&gt; </span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">let</span> (ls, rs) = split os <span class="kw">in</span> </span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>          merge cmp (mergesort cmp ls) (mergesort cmp rs);; </span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> lt a b = a &lt; b;; </span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>    mergesort lt [<span class="dv">1</span>;<span class="dv">6</span>;<span class="dv">2</span>;<span class="dv">10</span>;<span class="dv">-5</span>];;</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> split : &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> * &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> merge : (&#39;a -&gt; &#39;a -&gt; <span class="dt">bool</span>) -&gt; &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> mergesort : (&#39;a -&gt; &#39;a -&gt; <span class="dt">bool</span>) -&gt; &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> lt : &#39;a -&gt; &#39;a -&gt; <span class="dt">bool</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">-5</span>; <span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">6</span>; <span class="dv">10</span>]</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><h4 class="heading">1.17<tt>&nbsp;</tt><a name="(part.__.Let_.Expressions)"></a> Let Expressions<span class="button-group"><a href="#(part.__.Let_.Expressions)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>In OCaml, a let expression binds a name to a value.
Its general form is:</p><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = e1 <span class="kw">in</span> e2</span></code></pre></div>
</p><p><div class="SIntrapara">In this construct:
</div><div class="SIntrapara"><ul><li><p>x is the bound variable</p></li><li><p>e1 is the binding expression</p></li><li><p>e2 is the body expression in which the binding is visible.</p></li></ul></div></p><p><div class="SIntrapara">To evaluate a let expression:
</div><div class="SIntrapara"><ul><li><p>Evaluate e1 to v1</p></li><li><p>Substitute <span style="font-weight: bold">v1</span> for <span style="font-weight: bold">x</span> in <span style="font-weight: bold">e2</span>, yielding new expression <span style="font-weight: bold">e2&rsquo;</span></p></li><li><p>Evaluate <span style="font-weight: bold">e2&#8217;</span> to <span style="font-weight: bold">v2</span>, the final result</p></li></ul></div><div class="SIntrapara">. For exmple:
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = <span class="dv">20</span> + <span class="dv">1</span> <span class="kw">in</span> x + x </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = <span class="dv">21</span> <span class="kw">in</span> x + x <span class="co">(* evaluate e1, 20+1 ==&gt; 21)</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co">21 + 21 (* Substitute 21 for x in e2 *) </span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co">42</span></span></code></pre></div>

Here is the type checking rules for the let expression:</div></p><p>If <span style="font-weight: bold">e1 : t1</span> and if assuming <span style="font-weight: bold">x : t1</span> implies <span style="font-weight: bold">e2 : t</span> then <span style="font-weight: bold">(let x = e1 in e2) : t</span></p><h5 class="heading">1.17.1<tt>&nbsp;</tt><a name="(part._.Let_.Definitions_vs__.Let_.Expressions_)"></a>Let Definitions vs. Let Expressions <span class="button-group"><a href="#(part._.Let_.Definitions_vs__.Let_.Expressions_)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p><div class="SIntrapara">At the top level (in utop), we write <span style="font-weight: bold">let x = e;;</span>. Notice that there
is no in e2 part, unlike with a <span style="font-weight: bold">let expression</span>.
This is called a <span style="font-weight: bold">let definition</span>. The difference is that a
let definition does not itself produce a value when evaluated;
instead, it installs a new name into the top-level environment.
In other words, by omitting <span style="font-weight: bold">in</span>, we are saying &#8220;<span style="font-weight: bold">from now on</span>,
 the name x refers to the result of evaluating e.&#8221;
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> pi = <span class="fl">3.14</span>;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="co">(* pi is now bound in the rest of the top-level scope *)</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> pi : <span class="dt">float</span> = <span class="fl">3.14</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">We can write any expression at top-level, too
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>e;;</span></code></pre></div>

This says to evaluate <span style="font-weight: bold">e</span> and then ignore the result. It is equivalent to
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> _ = e;;</span></code></pre></div>

Useful when &lsquo;e&lsquo; has a side effect, such as reading/writing a file, printing to the screen, etc.</div></p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = <span class="dv">37</span>;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> y = x + <span class="dv">5</span>;; </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="dt">print_int</span> y;; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> <span class="dt">print_string</span> <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> x : <span class="dt">int</span> = <span class="dv">37</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> y : <span class="dt">int</span> = <span class="dv">42</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a># <span class="dv">42</span>- : <span class="dt">unit</span> = ()</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">unit</span> = ()</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote><h5 class="heading">1.17.2<tt>&nbsp;</tt><a name="(part._.Let_.Expressions__.Scope)"></a>Let Expressions: Scope<span class="button-group"><a href="#(part._.Let_.Expressions__.Scope)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p><div class="SIntrapara">In <span style="font-weight: bold">let x = e1 in e2</span>, variable <span style="font-weight: bold">x</span> is not visible outside of <span style="font-weight: bold">e2</span>. For example:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> pi = <span class="fl">3.14</span> <span class="kw">in</span> pi *. <span class="fl">3.0</span> *. <span class="fl">3.0</span>;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="dt">print_float</span> pi;;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a># - : <span class="dt">float</span> = <span class="fl">28.259999999999998</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>Line <span class="dv">1</span>, characters <span class="dv">13-15</span>:</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> |  <span class="dt">print_float</span> pi;;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>                 ^^</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>Error: Unbound value <span class="st">&quot;pi&quot;</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">Here, it binds <span style="font-weight: bold">pi</span> (only) in body of let (which is <span style="font-weight: bold">pi *. 3.0 *. 3.0</span>). Outside <span style="font-weight: bold">e2</span>,
the var <span style="font-weight: bold">x</span> is not visible. After <span style="font-weight: bold">e2</span> <span style="font-weight: bold">(pi *. 3.0 *. 3.0)</span> is evalued, <span style="font-weight: bold">pi</span>
 is out of scope. Therefore, <span style="font-weight: bold">print_float pi;;</span> shows <span style="font-weight: bold">pi not bound error</span>.
 This is similar to the scoping in C/JAVA.
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">float</span> pi <span class="op">=</span> <span class="fl">3.14</span><span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  pi <span class="op">*</span> <span class="fl">3.0</span> <span class="op">*</span> <span class="fl">3.0</span><span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>pi<span class="op">;</span> <span class="co">/* pi unbound! */</span></span></code></pre></div>

After the curly bracket, <span style="font-weight: bold">pi</span> is not visible.</div></p><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>x;; <span class="co">(* Unbound value x *)</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = <span class="dv">1</span> <span class="kw">in</span> x + <span class="dv">1</span>;;  <span class="co">(* 2 *)</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = x <span class="kw">in</span> x + <span class="dv">1</span>;; <span class="co">(* Unbound value x *)</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = <span class="dv">1</span> <span class="kw">in</span>  x + <span class="dv">1</span> + x   ;;    <span class="co">(* 3 *)</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>(<span class="kw">let</span> x = <span class="dv">1</span> <span class="kw">in</span> x + <span class="dv">1</span>) ;;  x;;   <span class="co">(* Unbound value x *)</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = <span class="dv">4</span> <span class="kw">in</span> (<span class="kw">let</span> x = x + <span class="dv">1</span> <span class="kw">in</span> x) </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>             <span class="kw">let</span> x = <span class="dv">4</span> + <span class="dv">1</span> <span class="kw">in</span> x</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>             <span class="kw">let</span> x = <span class="dv">5</span> <span class="kw">in</span> x</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>             <span class="dv">5</span></span></code></pre></div>
</p><h5 class="heading">1.17.3<tt>&nbsp;</tt><a name="(part._.Nested_.Let_.Expressions)"></a>Nested Let Expressions<span class="button-group"><a href="#(part._.Nested_.Let_.Expressions)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p><div class="SIntrapara">Uses of let can be nested
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> res = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">let</span> area = </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">let</span> pi = <span class="fl">3.14</span> <span class="kw">in</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> r = <span class="fl">3.0</span> <span class="kw">in</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>      pi *. r *. r) <span class="kw">in</span> </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>      <span class="co">(* pi and r are not visble here *)</span> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    area /. <span class="fl">2.0</span>);; </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">(* area is not visible here *)</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> res : <span class="dt">float</span> = <span class="fl">14.129999999999999</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">Similar scoping possibilities C and Java
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> res<span class="op">;</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span> <span class="dt">float</span> area<span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span> <span class="dt">float</span> pi <span class="op">=</span> <span class="fl">3.14</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> r <span class="op">=</span> <span class="fl">3.0</span><span class="op">;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    area <span class="op">=</span> pi <span class="op">*</span> r <span class="op">*</span> r<span class="op">;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span>  <span class="co">// p and r are not visible here.</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  res <span class="op">=</span> area <span class="op">/</span> <span class="fl">2.0</span><span class="op">;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="co">// area is not visible here</span></span></code></pre></div>

You should generally avoid nested let Style. Sometimes a nested binding
can be rewritten in a more linear style to make the code easier to understand. For example:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> res = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">let</span> area = </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">let</span> pi = <span class="fl">3.14</span> <span class="kw">in</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> r = <span class="fl">3.0</span> <span class="kw">in</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>      pi *. r *. r) <span class="kw">in</span> </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    area /. <span class="fl">2.0</span>);;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> res : <span class="dt">float</span> = <span class="fl">14.129999999999999</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">can be written as
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> res = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> pi = <span class="fl">3.14</span> <span class="kw">in</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> r = <span class="fl">3.0</span> <span class="kw">in</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> area = pi *. r *. r <span class="kw">in</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    area /. <span class="fl">2.0</span>;;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> res : <span class="dt">float</span> = <span class="fl">14.129999999999999</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><h5 class="heading">1.17.4<tt>&nbsp;</tt><a name="(part._.Let_.Expressions_in_.Functions)"></a>Let Expressions in Functions<span class="button-group"><a href="#(part._.Let_.Expressions_in_.Functions)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p><div class="SIntrapara">You can use let inside of functions for local variables:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> area d = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> pi = <span class="fl">3.14</span> <span class="kw">in</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> r = d /. <span class="fl">2.0</span> <span class="kw">in</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> square x = x *. x <span class="kw">in</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    pi *. (square r);; </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> area <span class="fl">10.0</span>;;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> area : <span class="dt">float</span> -&gt; <span class="dt">float</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">float</span> = <span class="fl">78.5</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><h5 class="heading">1.17.5<tt>&nbsp;</tt><a name="(part._.Shadowing_.Names)"></a>Shadowing Names<span class="button-group"><a href="#(part._.Shadowing_.Names)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p><div class="SIntrapara">Shadowing is rebinding a name in an inner scope to have a different meaning.
Some lagnauges such as java does not allow it. For example:
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f<span class="op">(</span><span class="dt">float</span> i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="op">*</span>i <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span> <span class="co">// Here i refer to the inner character variable.</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span> <span class="co">// Here, i refers to the global integer variable</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>

Similarly, OCaml allows shadowing variables:
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = <span class="dv">3</span>+<span class="dv">4</span> <span class="kw">in</span> <span class="kw">let</span> x = <span class="dv">3</span>*x <span class="kw">in</span> x+<span class="dv">1</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = <span class="dv">7</span> <span class="kw">in</span> <span class="kw">let</span> x = <span class="dv">3</span>*x <span class="kw">in</span> x+<span class="dv">1</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = <span class="dv">3</span>*<span class="dv">7</span> <span class="kw">in</span> x+<span class="dv">1</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = <span class="dv">21</span> <span class="kw">in</span> x+<span class="dv">1</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="dv">21</span>+<span class="dv">1</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="dv">22</span></span></code></pre></div>

In this example, the <span style="font-weight: bold">x</span> in the inner <span style="font-weight: bold">let</span> expression <span style="font-weight: bold">let x = 3*x in x+1</span>
 shadows the <span style="font-weight: bold">x</span> in outer <span style="font-weight: bold">let</span> expression  <span style="font-weight: bold">let x = 3+4 in ...</span>
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = <span class="dv">10</span> <span class="kw">in</span> (<span class="kw">let</span> x = x*<span class="dv">2</span> <span class="kw">in</span> x * x);; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="co">(* inner x shadows the outer x. It is same as *)</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> x = <span class="dv">10</span> <span class="kw">in</span> (<span class="kw">let</span> y = x*<span class="dv">2</span> <span class="kw">in</span> y * y);;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a># - : <span class="dt">int</span> = <span class="dv">400</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">400</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><h4 class="heading">1.18<tt>&nbsp;</tt><a name="(part._.Tuples)"></a>Tuples<span class="button-group"><a href="#(part._.Tuples)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>A tuple is an ordered sequence of n values written in parenthesis and separated by
commas as <span style="font-weight: bold">(e1, e2, ..., en)</span>. For instance, <span style="font-weight: bold">(330, "hello", true)</span> is a 3-tuple that
contains the integer &lsquo;42&lsquo; as its first component, the string &lsquo;"hello"&lsquo; as its second
component, and the boolean value &lsquo;true&lsquo; as its third component. <span style="font-weight: bold">()</span> denotes the empty
tuple with &lsquo;0&lsquo; element. It is called <span style="font-weight: bold">unit</span> in OCaml.</p><p><div class="SIntrapara">Tuple types use <span style="font-weight: bold">*</span> to separate the type of its components. For example:
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>(<span class="dv">1</span>, <span class="dv">2</span>) : (<span class="dt">int</span> * <span class="dt">int</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>(<span class="dv">1</span>, <span class="st">&quot;string&quot;</span>, <span class="fl">3.5</span>) : <span class="dt">int</span> * <span class="dt">string</span> * <span class="dt">float</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>(<span class="dv">1</span>, [<span class="st">&quot;a&quot;</span>; <span class="st">&quot;b&quot;</span>], <span class="ch">&#39;c&#39;</span>) :<span class="dt">int</span> * <span class="dt">string</span> <span class="dt">list</span> * <span class="dt">char</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>[(<span class="dv">1</span>,<span class="dv">2</span>)] : (<span class="dt">int</span> * <span class="dt">int</span>) <span class="dt">list</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>[(<span class="dv">1</span>, <span class="dv">2</span>); (<span class="dv">3</span>, <span class="dv">4</span>)] :(<span class="dt">int</span> * <span class="dt">int</span>) <span class="dt">list</span></span></code></pre></div>

Tuples are fixed size. The following code does not type check
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> foo x = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">match</span> x <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    (a, b) -&gt; a + b </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    |(a, b, c) -&gt; a + b + c;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>Line <span class="dv">4</span>, characters <span class="dv">5-14</span>:</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="dv">4</span> |     |(a, b, c) -&gt; a + b + c;;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>         ^^^^^^^^^</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>Error: This pattern matches values <span class="kw">of</span> <span class="kw">type</span> <span class="st">&quot;&#39;a * &#39;b * &#39;c&quot;</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>       but a pattern was expected which matches values <span class="kw">of</span> <span class="kw">type</span> <span class="st">&quot;&#39;d * &#39;e&quot;</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">because the pattern <span style="font-weight: bold">(a,b)</span> has the type <span style="font-weight: bold">int * int</span>, and the second
pattern has the type <span style="font-weight: bold">int * int * int</span>, but all the pattern expressions in
a <span style="font-weight: bold">match</span> must have a same type.</div></p><h5 class="heading">1.18.1<tt>&nbsp;</tt><a name="(part._.Pattern_.Matching_.Tuples)"></a>Pattern Matching Tuples<span class="button-group"><a href="#(part._.Pattern_.Matching_.Tuples)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p><div class="SIntrapara">In OCaml, you can use pattern matching on tuples to directly unpack their components.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> plus3 t = <span class="kw">match</span> t <span class="kw">with</span> (x, y, z) -&gt; x + y + z;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> plus3(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>);;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> plus3 : <span class="dt">int</span> * <span class="dt">int</span> * <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">6</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> plus3&#39; (x, y, z) = x + y + z;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> plus3&#39;(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>);;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> plus3&#39; : <span class="dt">int</span> * <span class="dt">int</span> * <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">6</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> addOne (x, y, z) = (x+<span class="dv">1</span>, y+<span class="dv">1</span>, z+<span class="dv">1</span>);; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> addOne(<span class="dv">10</span>,<span class="dv">20</span>,<span class="dv">30</span>);;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> addOne : <span class="dt">int</span> * <span class="dt">int</span> * <span class="dt">int</span> -&gt; <span class="dt">int</span> * <span class="dt">int</span> * <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> * <span class="dt">int</span> * <span class="dt">int</span> = (<span class="dv">11</span>, <span class="dv">21</span>, <span class="dv">31</span>)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote><p><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> sum ((a, b), c) = (a+c, b+c);; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> sum ((<span class="dv">1</span>, <span class="dv">2</span>), <span class="dv">3</span>) = (<span class="dv">4</span>, <span class="dv">5</span>);;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> sum : (<span class="dt">int</span> * <span class="dt">int</span>) * <span class="dt">int</span> -&gt; <span class="dt">int</span> * <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">bool</span> = <span class="kw">true</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> plusFirstTwo (x::y::_, a) = (x + a, y + a);; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> plusFirstTwo ([<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>], <span class="dv">4</span>) = (<span class="dv">5</span>, <span class="dv">6</span>);;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a># Line <span class="dv">1</span>, characters <span class="dv">17-29</span>:</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> | <span class="kw">let</span> plusFirstTwo (x::y::_, a) = (x + a, y + a);; </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>                     ^^^^^^^^^^^^</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>Warning <span class="dv">8</span> [partial-<span class="kw">match</span>]: this pattern-matching is <span class="dt">not</span> exhaustive.</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>Here is an example <span class="kw">of</span> a case that is <span class="dt">not</span> matched:</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>(x::[], _)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> plusFirstTwo : <span class="dt">int</span> <span class="dt">list</span> * <span class="dt">int</span> -&gt; <span class="dt">int</span> * <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">bool</span> = <span class="kw">true</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><h4 class="heading">1.19<tt>&nbsp;</tt><a name="(part._.Records)"></a>Records<span class="button-group"><a href="#(part._.Records)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p><div class="SIntrapara">A record represents a collection of values stored together as one, where each
component is identified by a different field name. The syntax for a record type declaration is as follows:
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &lt;record-name&gt; =</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    { &lt;field&gt; : &lt;<span class="kw">type</span>&gt;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>      &lt;field&gt; : &lt;<span class="kw">type</span>&gt;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>      ...</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div>

For example, we can define a record type &lsquo;date&lsquo; as:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> date = { month: <span class="dt">string</span>; day: <span class="dt">int</span>; year: <span class="dt">int</span> } </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="co">(* Now, we can define a record: *)</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> today = { day = <span class="dv">16</span>; year = <span class="dv">2017</span>; month = <span class="st">&quot;f&quot;</span> ^ <span class="st">&quot;eb&quot;</span> };;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> date = { month : <span class="dt">string</span>; day : <span class="dt">int</span>; year : <span class="dt">int</span>; }</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> today : date = {month = <span class="st">&quot;feb&quot;</span>; day = <span class="dv">16</span>; year = <span class="dv">2017</span>}</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">We can access the components of a record by field name or pattern matching.
Here is an example of accessing a record by field name:
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">print_string</span> today.month;; <span class="co">(* prints feb *)</span></span></code></pre></div>
</div></p><p><div class="SIntrapara">Here is an example of accessing the record by pattern matching
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> date = { month: <span class="dt">string</span>; day: <span class="dt">int</span>; year: <span class="dt">int</span> } </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> f x = </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> x <span class="kw">with</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    {year; day; month}-&gt; <span class="dt">Printf</span>.printf <span class="st">&quot;%d</span><span class="ch">\t</span><span class="st">%s</span><span class="ch">\t</span><span class="st">%d</span><span class="ch">\n</span><span class="st">&quot;</span> year month day;; </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> f {year=<span class="dv">2024</span>;day=<span class="dv">6</span>;month=<span class="st">&quot;Feb&quot;</span>};;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a># <span class="kw">type</span> date = { month : <span class="dt">string</span>; day : <span class="dt">int</span>; year : <span class="dt">int</span>; }</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> f : date -&gt; <span class="dt">unit</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="dv">2024</span>    Feb <span class="dv">6</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">unit</span> = ()</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><p><div class="SIntrapara">We can also bind records fields to pattern variables:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> date = { month: <span class="dt">string</span>; day: <span class="dt">int</span>; year: <span class="dt">int</span> } </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> f x = </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> x <span class="kw">with</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    {year=y; day=d; month=m} -&gt; <span class="dt">Printf</span>.printf <span class="st">&quot;%d</span><span class="ch">\t</span><span class="st">%s</span><span class="ch">\t</span><span class="st">%d</span><span class="ch">\n</span><span class="st">&quot;</span> y m d;; </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> f {year=<span class="dv">2024</span>;day=<span class="dv">6</span>;month=<span class="st">&quot;Feb&quot;</span>};;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a># <span class="kw">type</span> date = { month : <span class="dt">string</span>; day : <span class="dt">int</span>; year : <span class="dt">int</span>; }</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> f : date -&gt; <span class="dt">unit</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="dv">2024</span>    Feb <span class="dv">6</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">unit</span> = ()</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">There is a syntactic sugar for the match
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f3 {year; day; month} = <span class="dt">Printf</span>.printf <span class="st">&quot;%d   %s  %d</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;</span> year month day</span></code></pre></div>

or
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f {year =y; day=d; month=m} = <span class="dt">Printf</span>.printf <span class="st">&quot;%d %s  %d</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;</span> y m d</span></code></pre></div>
</div></p><p><div class="SIntrapara">You can also destruct a record using let expressions.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> date = { month: <span class="dt">string</span>; day: <span class="dt">int</span>; year: <span class="dt">int</span> } </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> today = {year=<span class="dv">2023</span>;day=<span class="dv">6</span>;month=<span class="st">&quot;Feb&quot;</span>};; </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> {year; day; month} = today <span class="kw">in</span> <span class="dt">Printf</span>.printf <span class="st">&quot;%d</span><span class="ch">\t</span><span class="st">%s</span><span class="ch">\t</span><span class="st">%d</span><span class="ch">\n</span><span class="st">&quot;</span> year month day;; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> {year =y; day=d; month=m} = today <span class="kw">in</span> <span class="dt">Printf</span>.printf <span class="st">&quot;%d</span><span class="ch">\t</span><span class="st">%s</span><span class="ch">\t</span><span class="st">%d</span><span class="ch">\n</span><span class="st">&quot;</span> y m d;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a># <span class="kw">type</span> date = { month : <span class="dt">string</span>; day : <span class="dt">int</span>; year : <span class="dt">int</span>; }</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> today : date = {month = <span class="st">&quot;Feb&quot;</span>; day = <span class="dv">6</span>; year = <span class="dv">2023</span>}</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a># <span class="dv">2023</span>  Feb <span class="dv">6</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">unit</span> = ()</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="dv">2023</span>    Feb <span class="dv">6</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">unit</span> = ()</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">Or access any number of fields of the record:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> date = { month: <span class="dt">string</span>; day: <span class="dt">int</span>; year: <span class="dt">int</span> } </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> today = {year=<span class="dv">2023</span>;day=<span class="dv">6</span>;month=<span class="st">&quot;Feb&quot;</span>};; </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> {year} = today <span class="kw">in</span> <span class="dt">Printf</span>.printf <span class="st">&quot;%d</span><span class="ch">\n</span><span class="st">&quot;</span> year;; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> {year =y; day=d} = today <span class="kw">in</span> <span class="dt">Printf</span>.printf <span class="st">&quot;%d</span><span class="ch">\t</span><span class="st">%d</span><span class="ch">\n</span><span class="st">&quot;</span> y d;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a># <span class="kw">type</span> date = { month : <span class="dt">string</span>; day : <span class="dt">int</span>; year : <span class="dt">int</span>; }</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> today : date = {month = <span class="st">&quot;Feb&quot;</span>; day = <span class="dv">6</span>; year = <span class="dv">2023</span>}</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a># <span class="dv">2023</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">unit</span> = ()</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="dv">2023</span>    <span class="dv">6</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">unit</span> = ()</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><p>Quiz: What is the type of shift?
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> point = {x:<span class="dt">int</span>; y:<span class="dt">int</span>}</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> shift { x=px } = [px]::[]</span></code></pre></div>

Answer: The type of &lsquo;shift&lsquo; is <span style="font-weight: bold">point -&gt; int list list</span>.
Argument &lsquo;{ x=px }&lsquo; is a record with a field &lsquo;x&lsquo;.
We know it is the &lsquo;pont&lsquo;.  &lsquo;{ x=px }&lsquo;also binds the field &lsquo;x&lsquo; of &lsquo;point&lsquo; to &lsquo;px&lsquo;.
Because &lsquo;x&lsquo; is &lsquo;int&lsquo;, &lsquo;px&lsquo; is also &lsquo;int&lsquo;. If &lsquo;px&lsquo; is &lsquo;int&lsquo;, then &lsquo;[px]&lsquo; is &lsquo;int list&lsquo;
and &lsquo;[px]::[]&lsquo; is an &lsquo;int list list&lsquo;.</p><h4 class="heading">1.20<tt>&nbsp;</tt><a name="(part._.Anonymous_.Functions)"></a>Anonymous Functions<span class="button-group"><a href="#(part._.Anonymous_.Functions)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p><div class="SIntrapara">In OCaml, we use &lsquo;fun&lsquo; to make a function with no name. For example:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> x -&gt; x + <span class="dv">3</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">Here, &lsquo;x&lsquo; is the parameter and &lsquo;x+3&lsquo; is the body. We can apply this anonymous function as:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">fun</span> x -&gt; x + <span class="dv">3</span>) <span class="dv">5</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">8</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">The evaluation and typechecking rules are same as functions.</div></p><p><div class="SIntrapara">Quiz: What is this expression&#8217;s type?
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>(<span class="kw">fun</span> x y -&gt; x) <span class="dv">2</span> <span class="dv">3</span></span></code></pre></div>

Type of <span style="font-weight: bold">(fun x y&#8594; x)</span> is <span style="font-weight: bold">&rsquo;a&#8594;&rsquo;b&#8594;&rsquo;a</span>. Because we apply this anonymous
function to arguments <span style="font-weight: bold">2 3</span>, <span style="font-weight: bold">&rsquo;a</span> and <span style="font-weight: bold">&rsquo;b</span> will be restricted to <span style="font-weight: bold">int</span>s. Therefore,
 the return type will be an <span style="font-weight: bold">int</span>.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">fun</span> x y -&gt; x) <span class="dv">2</span> <span class="dv">3</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">2</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><h5 class="heading">1.20.1<tt>&nbsp;</tt><a name="(part._.Functions_and_.Binding)"></a>Functions and Binding<span class="button-group"><a href="#(part._.Functions_and_.Binding)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p><div class="SIntrapara">In OCaml, functions are first-class, so you can bind them to other names as you like
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f x = x + <span class="dv">3</span>;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> g = f;; </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> g <span class="dv">5</span>;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> f : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> g : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">8</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">In fact, let for functions is a syntactic shorthand
<span style="font-weight: bold">let f x = body</span> is semantically equivalent to
<span style="font-weight: bold">let f = fun x -&gt;  body</span>. For example:</div></p><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> next x = x + <span class="dv">1</span></span></code></pre></div>
 is the short for
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> next = <span class="kw">fun</span> x -&gt; x + <span class="dv">1</span></span></code></pre></div>
</p><p>and,
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> plus x y = x + y</span></code></pre></div>

is the short for
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> plus = <span class="kw">fun</span> x y -&gt; x + y</span></code></pre></div>
</p><p>Quiz: What does this evaluate to?
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f = <span class="kw">fun</span> x -&gt; <span class="dv">0</span> <span class="kw">in</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> g = f <span class="kw">in</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> h = <span class="kw">fun</span> y -&gt; g (y+<span class="dv">1</span>) <span class="kw">in</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>h <span class="dv">1</span>;;</span></code></pre></div>

Answer:
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>h <span class="dv">1</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>(<span class="kw">fun</span> y -&gt; g (y+<span class="dv">1</span>)) <span class="dv">1</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>g (<span class="dv">1</span>+<span class="dv">1</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>g <span class="dv">2</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>f <span class="dv">2</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>(<span class="kw">fun</span> x -&gt; <span class="dv">0</span>) <span class="dv">2</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="dv">0</span></span></code></pre></div>
</p><h4 class="heading">1.21<tt>&nbsp;</tt><a name="(part._.Higher_.Order_.Functions)"></a>Higher Order Functions<span class="button-group"><a href="#(part._.Higher_.Order_.Functions)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>In OCaml, a function can take other functions as arguments or return them as results.
 Such functions are called higher-order functions. This works because functions in
 OCaml are first-class values&#8212;you can pass them around just like integers,
 strings, or lists.</p><p><div class="SIntrapara">Here is an example:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> plus3 x = x + <span class="dv">3</span>;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> twice f z = f (f z);; </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> twice plus3 <span class="dv">5</span>;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> plus3 : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> twice : (&#39;a -&gt; &#39;a) -&gt; &#39;a -&gt; &#39;a = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">11</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><p>In this example, we pass the function plus3 as an argument to the function twice.
The function twice then applies plus3 to 5 two times:</p><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>twice plus3 <span class="dv">5</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>plus3 (plus3 <span class="dv">5</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>plus3 <span class="dv">8</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="dv">11</span></span></code></pre></div>
</p><h4 class="heading">1.22<tt>&nbsp;</tt><a name="(part._.Map)"></a>Map<span class="button-group"><a href="#(part._.Map)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>OCaml&#8217;s <span style="font-weight: bold">map</span> is a higher-order function.
<span style="font-weight: bold">map f l</span> takes a function <span style="font-weight: bold">f</span> and a list <span style="font-weight: bold">l</span>, applies
<span style="font-weight: bold">f</span> to each element of <span style="font-weight: bold">l</span>, and returns a new list of the
results while <span style="font-weight: bold">preserving the original order</span>. The <span style="font-weight: bold">map</span>
function is defined in the <span style="font-weight: bold">List</span> module, so you can either
write <span style="font-weight: bold">open List</span> first or call it as <span style="font-weight: bold">List.map</span>.</p><p><div class="SIntrapara">In the following example, <span style="font-weight: bold">map</span> apples <span style="font-weight: bold">add_one</span> to each
element of the list <span style="font-weight: bold">[1;2;3]</span>.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> add_one x = x + <span class="dv">1</span>;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="dt">List</span>.map add_one [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>];;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> add_one : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">4</span>]</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">In the following example, <span style="font-weight: bold">map</span> apples <span style="font-weight: bold">negate</span> to each element of the list <span style="font-weight: bold">[9; -5; 0]</span>.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> negate x = -x;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="dt">List</span>.map negate [<span class="dv">9</span>; <span class="dv">-5</span>; <span class="dv">0</span>];;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> negate : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">-9</span>; <span class="dv">5</span>; <span class="dv">0</span>]</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><h5 class="heading">1.22.1<tt>&nbsp;</tt><a name="(part._.Implementing_map)"></a>Implementing map<span class="button-group"><a href="#(part._.Implementing_map)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> map f l = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> l <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    [] -&gt; [] </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    | h::t -&gt; (f h)::(map f t);;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> map : (&#39;a -&gt; &#39;b) -&gt; &#39;a <span class="dt">list</span> -&gt; &#39;b <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote><p>What is the type of <span style="font-weight: bold">map</span>?</p><p><span style="font-weight: bold">map</span> takes two arguments, so its type must look like
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">type</span> <span class="kw">of</span> f) -&gt; (<span class="kw">type</span> <span class="kw">of</span> l) -&gt; <span class="kw">type</span> <span class="kw">of</span> return</span></code></pre></div>
.</p><p>The function <span style="font-weight: bold">f</span> can take any type as input and return any
type, so its type is <span style="font-weight: bold">&rsquo;a -&gt; &rsquo;b</span>. From the application <span style="font-weight: bold">f h</span>,
we see that <span style="font-weight: bold">h</span> must have type <span style="font-weight: bold">&rsquo;a</span>. From the expression
<span style="font-weight: bold">(f h) :: (map f t)</span>, we know the result is a list whose elements
have the type of <span style="font-weight: bold">f h</span>, namely <span style="font-weight: bold">&rsquo;b list</span>.</p><p>Putting this all together, the type of <span style="font-weight: bold">map</span> is:
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>(&#39;a -&gt; &#39;b) -&gt; &#39;a <span class="dt">list</span> -&gt; &#39;b <span class="dt">list</span></span></code></pre></div>
</p><p>Let us look at another example:
Apply a list of functions <span style="font-weight: bold">neg</span>, <span style="font-weight: bold">add_one</span>, and <span style="font-weight: bold">double</span> to a list of ints.</p><p><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> neg x = -x;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> add_one x = x+<span class="dv">1</span>;; </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> double x = x + x;; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> fs = [neg; add_one; double];; <span class="co">(* (int -&gt; int) list *)</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> lst = [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>];; </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> <span class="dt">List</span>.map (<span class="kw">fun</span> f-&gt; <span class="dt">List</span>.map f lst) fs;;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> neg : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> add_one : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> double : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> fs : (<span class="dt">int</span> -&gt; <span class="dt">int</span>) <span class="dt">list</span> = [&lt;<span class="kw">fun</span>&gt;; &lt;<span class="kw">fun</span>&gt;; &lt;<span class="kw">fun</span>&gt;]</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> lst : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>]</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> <span class="dt">list</span> = [[<span class="dv">-1</span>; <span class="dv">-2</span>; <span class="dv">-3</span>]; [<span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">4</span>]; [<span class="dv">2</span>; <span class="dv">4</span>; <span class="dv">6</span>]]</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">In the above example, the outer <span style="font-weight: bold">map</span> applies the anonymous function to each element of the the list &lsquo;fs&lsquo;.
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>map (<span class="kw">fun</span> f-&gt; map f lst) fs</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>map (<span class="kw">fun</span> f-&gt; map f [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>]) [neg; add_one; double]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>((<span class="kw">fun</span> f-&gt; map f [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>]) neg) :: map (<span class="kw">fun</span> f-&gt; map f [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>]) [add_one; double]</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>[<span class="dv">-1</span>; <span class="dv">-2</span>; <span class="dv">-3</span>]::map (<span class="kw">fun</span> f-&gt; map f [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>]) [add_one; double]</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>[<span class="dv">-1</span>; <span class="dv">-2</span>; <span class="dv">-3</span>]::((<span class="kw">fun</span> f-&gt; map f [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>]) add_one) :: map (<span class="kw">fun</span> f-&gt; map f [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>]) [double]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>[<span class="dv">-1</span>; <span class="dv">-2</span>; <span class="dv">-3</span>]::[<span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">4</span>]::map (<span class="kw">fun</span> f-&gt; map f [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>]) [double]</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>[<span class="dv">-1</span>; <span class="dv">-2</span>; <span class="dv">-3</span>]::[<span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">4</span>]::((<span class="kw">fun</span> f-&gt; map f [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>]) double) ::map (<span class="kw">fun</span> f-&gt; map f [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>]) []</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>[<span class="dv">-1</span>; <span class="dv">-2</span>; <span class="dv">-3</span>]::[<span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">4</span>]::[<span class="dv">2</span>; <span class="dv">4</span>; <span class="dv">6</span>]::[]</span></code></pre></div>
</div></p><h5 class="heading">1.22.2<tt>&nbsp;</tt><a name="(part._.Fold)"></a>Fold<span class="button-group"><a href="#(part._.Fold)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p><div class="SIntrapara">Fold is a higher order function that takes a function of two arguments, a final value,
and a list processes the list by applying the function to the head and the recursive
application of the function to the rest of the list, returning the final value for the empty list.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> fold f a l = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> l <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>      [] -&gt; a </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    | h::t -&gt; fold f (f a h) t;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> fold : (&#39;a -&gt; &#39;b -&gt; &#39;a) -&gt; &#39;a -&gt; &#39;b <span class="dt">list</span> -&gt; &#39;a = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><p>For example:
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> add x y = x + y</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>fold add <span class="dv">0</span>             [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>fold add (add <span class="dv">0</span> <span class="dv">1</span>)     [<span class="dv">2</span>; <span class="dv">3</span>]</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>fold add <span class="dv">1</span>             [<span class="dv">2</span>; <span class="dv">3</span>]</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>fold add (add <span class="dv">1</span> <span class="dv">2</span>)     [<span class="dv">3</span>]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>fold add <span class="dv">3</span>             [<span class="dv">3</span>]</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>fold add (add <span class="dv">3</span> <span class="dv">3</span>)     []</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>fold add <span class="dv">6</span>            []</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="dv">6</span>  <span class="co">(* 1 + 2 + 3 *)</span></span></code></pre></div>
</p><p>What does fold do?
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>fold f        v        [v1; v2; â€¦; vn] </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>= fold f    (f v v1)       [v2; â€¦; vn]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>= fold f (f (f v v1) v2)  [â€¦; vn]</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>= â€¦</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>= f (f (f (f v v1) v2) â€¦) vn</span></code></pre></div>

e.g.,
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>fold add <span class="dv">0</span> [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>;<span class="dv">4</span>] = </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>      add (add (add (add <span class="dv">0</span> <span class="dv">1</span>) <span class="dv">2</span>) <span class="dv">3</span>) <span class="dv">4</span> = <span class="dv">10</span></span></code></pre></div>
</p><p>Another Example: Using Fold to Build Reverse
Let&#8217;s build the reverse function with fold!
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> prepend a x = x::a</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>fold prepend [] [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">4</span>]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>fold prepend [<span class="dv">1</span>] [<span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">4</span>]</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>fold prepend [<span class="dv">2</span>; <span class="dv">1</span>] [<span class="dv">3</span>; <span class="dv">4</span>]</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>fold prepend [<span class="dv">3</span>; <span class="dv">2</span>; <span class="dv">1</span>] [<span class="dv">4</span>]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>fold prepend [<span class="dv">4</span>; <span class="dv">3</span>; <span class="dv">2</span>; <span class="dv">1</span>] []</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>[<span class="dv">4</span>; <span class="dv">3</span>; <span class="dv">2</span>; <span class="dv">1</span>]</span></code></pre></div>
</p><p><div class="SIntrapara">The <span style="font-weight: bold">fold</span> function is implemented in OCaml List module as <span style="font-weight: bold">List.fold_left</span>. OCaml List
module also provides another implementation of fold called <span style="font-weight: bold">fold_right</span>, which processes
the list from tail to head.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> fold_right f l a = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> l <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>      [] -&gt; a </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    | h::t -&gt; f h (fold_right f t a);;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> fold_right : (&#39;a -&gt; &#39;b -&gt; &#39;b) -&gt; &#39;a <span class="dt">list</span> -&gt; &#39;b -&gt; &#39;b = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><p><div class="SIntrapara">Depending on the function, the <span style="font-weight: bold">fold_left</span> and <span style="font-weight: bold">fold_right</span> may yield different results.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">List</span>.fold_left (<span class="kw">fun</span> x y -&gt; x - y) <span class="dv">0</span> [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>];;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">-6</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">The result is -6 because ((0-1)-2)-3 = -6.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">List</span>.fold_right  (<span class="kw">fun</span> x y -&gt; x - y) [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>] <span class="dv">0</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">2</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">The result is 2 because 1-(2-(3-0)) = 2</div></p><p>When should we use <span style="font-weight: bold">fold_left</span> versus <span style="font-weight: bold">fold_right</span>?
Many problems are naturally expressed with fold_right, but it
 has a performance drawback: it creates a deep call stack, with
 one frame per recursive call. By contrast, fold_left can be
 optimized through tail recursion, allowing it to run without
 consuming additional stack space.</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* Product of an int list *)</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> mul x y = x * y;; </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> lst = [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">4</span>; <span class="dv">5</span>];; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> <span class="dt">List</span>.fold_left mul <span class="dv">1</span> lst;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> mul : <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> lst : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">4</span>; <span class="dv">5</span>]</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">120</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* Collect even numbers in the list *)</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> f acc y = <span class="kw">if</span> (y <span class="kw">mod</span> <span class="dv">2</span>) = <span class="dv">0</span> <span class="kw">then</span> y::acc </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>                <span class="kw">else</span> acc;; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> <span class="dt">List</span>.fold_left f [] [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>;<span class="dv">4</span>;<span class="dv">5</span>;<span class="dv">6</span>];;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> f : <span class="dt">int</span> <span class="dt">list</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">6</span>; <span class="dv">4</span>; <span class="dv">2</span>]</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* Count elements of a list satisfying a condition *)</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> countif p l = </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="dt">List</span>.fold_left (<span class="kw">fun</span> counter element -&gt; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>         <span class="kw">if</span> p element <span class="kw">then</span> counter+<span class="dv">1</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>         <span class="kw">else</span> counter) <span class="dv">0</span> l ;; </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a> countif (<span class="kw">fun</span> x -&gt; x &gt; <span class="dv">0</span>) [<span class="dv">30</span>;<span class="dv">-1</span>;<span class="dv">45</span>;<span class="dv">100</span>;<span class="dv">0</span>];;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> countif : (&#39;a -&gt; <span class="dt">bool</span>) -&gt; &#39;a <span class="dt">list</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">3</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* Permute a list *)</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> permute lst = </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">rec</span> rm x l = <span class="dt">List</span>.filter ((&lt;&gt;) x) l </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">and</span> insertToPermute lst x = </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> t = rm x lst <span class="kw">in</span> </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>      <span class="dt">List</span>.map ((<span class="kw">fun</span> a b-&gt;a::b) x )(permuteall t) </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">and</span> permuteall lst = </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>      <span class="kw">match</span> lst <span class="kw">with</span> </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>      |[]-&gt;[] </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>      |[x]-&gt;[[x]] </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>      |_-&gt;<span class="dt">List</span>.flatten(<span class="dt">List</span>.map (insertToPermute lst) lst) </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span> permuteall lst;; </span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>   permute [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>];;</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> permute : &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> <span class="dt">list</span> =</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>[[<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>]; [<span class="dv">1</span>; <span class="dv">3</span>; <span class="dv">2</span>]; [<span class="dv">2</span>; <span class="dv">1</span>; <span class="dv">3</span>]; [<span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">1</span>]; [<span class="dv">3</span>; <span class="dv">1</span>; <span class="dv">2</span>]; [<span class="dv">3</span>; <span class="dv">2</span>; <span class="dv">1</span>]]</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">(* Power Set *)</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> populate a b =</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> b=[] <span class="kw">then</span> [[a]]</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">else</span>  <span class="kw">let</span> t = <span class="dt">List</span>.map (<span class="kw">fun</span> x-&gt;a::x) b <span class="kw">in</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        [a]::t @ b</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> powerset lst = <span class="dt">List</span>.fold_right populate lst [];;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>powerset [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>];;</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> populate : &#39;a -&gt; &#39;a <span class="dt">list</span> <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> powerset : &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a># - : <span class="dt">int</span> <span class="dt">list</span> <span class="dt">list</span> = [[<span class="dv">1</span>]; [<span class="dv">1</span>; <span class="dv">2</span>]; [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>]; [<span class="dv">1</span>; <span class="dv">3</span>]; [<span class="dv">2</span>]; [<span class="dv">2</span>; <span class="dv">3</span>]; [<span class="dv">3</span>]]</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote><p>Inner Product: given two lists of same size [x1;x2;..xn] and [y1;y2;...yn], compute
[x1;x2;x3]&#8727;[y1;y2;y3] = x1&#8727;y1 + x2&#8727;y2 +..+ xn&#8727;yn</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> map2 f a b = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>      <span class="kw">match</span> (a,b) <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>      |([],[])-&gt;([]) </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>      |(h1::t1,h2::t2)-&gt;(f h1 h2):: (map2 f t1 t2) </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>      |_-&gt;<span class="dt">invalid_arg</span> <span class="st">&quot;map2&quot;</span>;; </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> product v1 v2 = </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">List</span>.fold_left (+) <span class="dv">0</span> (map2 ( * ) v1 v2);; </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a> product [<span class="dv">2</span>;<span class="dv">4</span>;<span class="dv">6</span>] [<span class="dv">1</span>;<span class="dv">3</span>;<span class="dv">5</span>];;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> map2 : (&#39;a -&gt; &#39;b -&gt; &#39;c) -&gt; &#39;a <span class="dt">list</span> -&gt; &#39;b <span class="dt">list</span> -&gt; &#39;c <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> product : <span class="dt">int</span> <span class="dt">list</span> -&gt; <span class="dt">int</span> <span class="dt">list</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">44</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote><p><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>   <span class="co">(* Find the maximum from a list *)</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> maxList lst = </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>      <span class="kw">match</span> lst <span class="kw">with</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>       []-&gt;<span class="dt">failwith</span> <span class="st">&quot;empty list&quot;</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>      |h::t-&gt; <span class="dt">List</span>.fold_left <span class="dt">max</span> h t ;; </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a> maxList [<span class="dv">3</span>;<span class="dv">10</span>;<span class="dv">5</span>];;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> maxList : &#39;a <span class="dt">list</span> -&gt; &#39;a = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">10</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara"><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>maxList [<span class="dv">3</span>;<span class="dv">10</span>;<span class="dv">5</span>]</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>fold <span class="dt">max</span> <span class="dv">3</span> [<span class="dv">10</span>:<span class="dv">5</span>]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>fold <span class="dt">max</span> (<span class="dt">max</span> <span class="dv">3</span> <span class="dv">10</span>) [<span class="dv">5</span>]</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>fold <span class="dt">max</span> (<span class="dt">max</span> <span class="dv">10</span> <span class="dv">5</span>) []</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>fold <span class="dt">max</span> <span class="dv">10</span> []</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="dv">10</span></span></code></pre></div>
</div></p><p><div class="SIntrapara">Sum of sublists: Given a list of int lists, compute the sum of each int list, and return them as list.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> sumList  = <span class="dt">List</span>.map (<span class="dt">List</span>.fold_left (+) <span class="dv">0</span> );; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> sumList [[<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>];[<span class="dv">4</span>;<span class="dv">5</span>;<span class="dv">6</span>];[<span class="dv">10</span>]];;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> sumList : <span class="dt">int</span> <span class="dt">list</span> <span class="dt">list</span> -&gt; <span class="dt">int</span> <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">6</span>; <span class="dv">15</span>; <span class="dv">10</span>]</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">Maximum contiguous sublist: Given an int list, find the contiguous sublist, which has the largest sum and return its sum.</div></p><p><div class="SIntrapara">Example:
    Input: [-2,1,-3,4,-1,2,1,-5,4]
    Output: 6
    Explanation: [4,-1,2,1] has the largest sum = 6
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> f (m, acc) h = </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>     <span class="kw">let</span> m = <span class="dt">max</span> m (acc + h) <span class="kw">in</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>     <span class="kw">let</span>  x = <span class="kw">if</span> acc &lt; <span class="dv">0</span> <span class="kw">then</span> <span class="dv">0</span> <span class="kw">else</span> acc <span class="kw">in</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>     (m, x+h) </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> ;; </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> submax  lst = <span class="kw">let</span> (max_so_far, max_current) = </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>          <span class="dt">List</span>.fold_left f (<span class="dv">0</span>,<span class="dv">0</span>) lst <span class="kw">in</span> </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>          max_so_far;; </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a> submax [<span class="dv">-2</span>; <span class="dv">1</span>; <span class="dv">-3</span>; <span class="dv">4</span>; <span class="dv">-1</span>; <span class="dv">2</span>; <span class="dv">1</span>; <span class="dv">-5</span>; <span class="dv">4</span>];;</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> f : <span class="dt">int</span> * <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> * <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> submax : <span class="dt">int</span> <span class="dt">list</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">6</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><h4 class="heading">1.23<tt>&nbsp;</tt><a name="(part._.Tail_.Recursion)"></a>Tail Recursion<span class="button-group"><a href="#(part._.Tail_.Recursion)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Whenever a function&#8217;s result is completely computed by its recursive call, it
is called tail recursive. Its &#8220;tail&#8221; &#8211; the last thing it does &#8211; is recursive.</p><p>Tail recursive functions can be implemented without requiring a stack frame for each call
No intermediate variables need to be saved, so the compiler overwrites them</p><p>Typical pattern is to use an accumulator to build up the result, and return it in the base case.</p><p><div class="SIntrapara">We have seen the recursive factorial function
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> fact  n = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> n = <span class="dv">0</span> <span class="kw">then</span> <span class="dv">1</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>      <span class="kw">else</span> n * fact (n<span class="dv">-1</span>);; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> fact <span class="dv">4</span>;;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> fact : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">24</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">Now, let us look at how <span style="font-weight: bold">fact 3</span> is executed:
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>fact <span class="dv">3</span> = <span class="dv">3</span> * fact <span class="dv">2</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>       = <span class="dv">3</span> * <span class="dv">2</span> * fact <span class="dv">1</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>       = <span class="dv">3</span> * <span class="dv">2</span> * <span class="dv">1</span> * fact <span class="dv">0</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>       = <span class="dv">3</span> * <span class="dv">2</span> * <span class="dv">1</span> * <span class="dv">1</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>       = <span class="dv">3</span> * <span class="dv">2</span> * <span class="dv">1</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>       = <span class="dv">3</span> * <span class="dv">2</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>       = <span class="dv">6</span>   </span></code></pre></div>

As shown below, each recursive call to the <span style="font-weight: bold">fact</span> function will
create a new stack frame in the memory.
<img src="factorial.png" alt="" width="310" height="175"/>
As such, if the recusrion is deep, it can cause <span style="font-weight: bold">Stack overflow</span> error. For example:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> sum n = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> n = <span class="dv">0</span> <span class="kw">then</span> <span class="dv">0</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> n + sum (n<span class="dv">-1</span>);; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> sum <span class="dv">10000000</span>;;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> sum : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">50000005000000</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><p><div class="SIntrapara">Now, let us look at another implementation of the factorial function
<img src="factorial_tail.png" alt="" width="302" height="75"/>
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> fact n = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">rec</span> aux x a = </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> x = <span class="dv">0</span> <span class="kw">then</span> a </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>      <span class="kw">else</span> aux (x<span class="dv">-1</span>) x*a </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span> </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    aux n <span class="dv">1</span>;;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> fact : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">Here is the execution of <span style="font-weight: bold">fact 3</span>
<img src="factorial_tail_stack.png" alt="" width="327" height="228"/></div></p><p>In the first implementation of the factoral, it makes recursive calls
<span style="font-weight: bold">fact (n-1)</span>, and then it takes the return value of the recursive call
 and calculate the result <span style="font-weight: bold">n * fact (n-1)</span>. In this manner, you don&rsquo;t
 get the result of your calculation until you have returned from every
 recursive call.</p><p>In the second implementation, it carries an accumulator <span style="font-weight: bold">a</span>. It performs
 calculation first, and then you execute the recursive call, passing the
 results of the current step to the next recursive step. This results in
  the last statement being in the form of <span style="font-weight: bold">(return (recursive-function params))</span>. Basically, the return value of the last recursive call is the
  final result. The consequence of this is that when you perforem the next
  recursive call, you do not need the current stack frame any more.</p><p>As shown above, in the last recursive call to <span style="font-weight: bold">fact 0</span>, it returns the
result of <span style="font-weight: bold">fact 3</span>. Therefore, we do not need all the stack frames for the
previous recursive calls. This allows for some optimization. Some compilers
can optimize the tail recursive calls to use only the current stack frame.
This is called tail recusrion optimization. Functional programming language
compilers usually optimizes the tail recursive calls because recusrion is the
only way to achieve repetiton.</p><p><div class="SIntrapara">Let us compare the two implemantion of factorial again:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* Waits for recursive callâ€™s result to compute final result *)</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> <span class="kw">rec</span> fact n = </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> n = <span class="dv">0</span> <span class="kw">then</span> <span class="dv">1</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>      <span class="kw">else</span> n * fact (n<span class="dv">-1</span>);;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> fact : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* final result is the result of the recursive call *)</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">let</span> fact n = </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>     <span class="kw">let</span> <span class="kw">rec</span> aux x acc = </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>       <span class="kw">if</span> x = <span class="dv">1</span> <span class="kw">then</span> acc </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>       <span class="kw">else</span> aux (x<span class="dv">-1</span>) (acc*x) </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>     <span class="kw">in</span> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    aux n <span class="dv">1</span>;;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> fact : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">Tail-recursive Sum of List
 </div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">(* non-tail recursive *)</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">let</span> <span class="kw">rec</span> sumlist l = </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>     <span class="kw">match</span> l <span class="kw">with</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>       [] -&gt; <span class="dv">0</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>     | (x::xs) -&gt; (sumlist xs) + x </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> ;; </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>   <span class="co">(* Tail-recursive version: *)</span> </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>   <span class="kw">let</span> sumlist l = </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>     <span class="kw">let</span> <span class="kw">rec</span> helper l a = </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>       <span class="kw">match</span> l <span class="kw">with</span> </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>         [] -&gt; a </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>       | (x::xs) -&gt; helper xs (x+a) <span class="kw">in</span> </span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>   helper l <span class="dv">0</span>;;</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> sumlist : <span class="dt">int</span> <span class="dt">list</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> sumlist : <span class="dt">int</span> <span class="dt">list</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><h5 class="heading">1.23.1<tt>&nbsp;</tt><a name="(part._fold_left_vs_fold_right)"></a>fold_left vs fold_right<span class="button-group"><a href="#(part._fold_left_vs_fold_right)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p><div class="SIntrapara">The <span style="font-weight: bold">fold_left</span> is tail recursive and the <span style="font-weight: bold">fold_right</span> is not tail recursive.
 The following examples calculates the sum of <span style="font-weight: bold">10000000</span> integers.
 The <span style="font-weight: bold">fold_left</span> returns the correct result, but <span style="font-weight: bold">fold_right</span> raises
 a <span style="font-weight: bold">Stack overflow</span> error.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">List</span>.fold_left (+) <span class="dv">0</span> (<span class="dt">List</span>.init <span class="dv">100000000</span> (<span class="kw">fun</span> _-&gt;<span class="dv">1</span>));;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">100000000</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">List</span>.fold_right (+) (<span class="dt">List</span>.init <span class="dv">100000000</span> (<span class="kw">fun</span> _-&gt;<span class="dv">1</span>)) <span class="dv">0</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="dt">Stack</span> overflow during evaluation (looping recursion?).</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><p>Why? Let us look at the implementation of <span style="font-weight: bold">fold_left</span> and <span style="font-weight: bold">fold_right</span>.
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> fold_left f a l =</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    [] -&gt; a</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  | h::t -&gt; fold_left f (f a h) t</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>fold_left (+) <span class="dv">0</span> [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>]</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>fold_left (+) <span class="dv">1</span> [<span class="dv">2</span>;<span class="dv">3</span>]</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>fold_left (+) <span class="dv">3</span> [<span class="dv">3</span>]</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>fold_left (+) <span class="dv">6</span> []</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="dv">6</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> fold_right f l a =</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> l <span class="kw">with</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    [] -&gt; a</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>  | h::t -&gt; f h (fold_right f t a)</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>fold_right (+) [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>] <span class="dv">0</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> + (fold_right (+) [<span class="dv">2</span>;<span class="dv">3</span>] <span class="dv">0</span>)</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> + (<span class="dv">2</span> + (fold_right (+) [<span class="dv">3</span>] <span class="dv">0</span>))</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> + (<span class="dv">2</span> + (<span class="dv">3</span> (fold_right (+) [] <span class="dv">0</span>)))</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> + (<span class="dv">2</span> + ( <span class="dv">3</span> + <span class="dv">0</span>))</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> + (<span class="dv">2</span> + <span class="dv">3</span>)</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> + <span class="dv">5</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a><span class="dv">6</span></span></code></pre></div>

For &lsquo;fold_left&lsquo;, the call to &lsquo;fold_left&lsquo; is in the form of &lsquo;(return
(recursive-function params))&lsquo;.  There is no operation after the recursive call returns.
 However, for <span style="font-weight: bold">fold_right</span>, after the recursive call to <span style="font-weight: bold">fold_right</span> returns, we still
 need to perform the &lsquo;f h recursive_call_return&lsquo;. We need to keep the current stack frame
  before calling the next recurvie call. Therefore, <span style="font-weight: bold">fold_right</span> is not tail recursive
  and cannot be optimized.</p><h5 class="heading">1.23.2<tt>&nbsp;</tt><a name="(part._.Tail_.Recursion_.Pattern)"></a>Tail Recursion Pattern<span class="button-group"><a href="#(part._.Tail_.Recursion_.Pattern)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p><div class="SIntrapara">Non-tail-recursive functions can often be transformed into tail-recursive ones by following this pattern:
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> func x =</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> helper arg acc =</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> (base case) <span class="kw">then</span> acc</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> arg&#39; = <span class="co">(* argument to recursive call *)</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> acc&#39; = helper arg&#39; acc&#39; <span class="kw">in</span> <span class="co">(* end of helper fun *)</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span> </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  helper x;; <span class="co">(* initial val of accumulator *)</span></span></code></pre></div>

We now apply this pattern to obtain a tail-recursive version of
the factorial function.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> fact x = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">rec</span> helper arg acc = </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> arg = <span class="dv">0</span> <span class="kw">then</span> acc </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>      <span class="kw">else</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> arg&#39; = arg - <span class="dv">1</span> <span class="kw">in</span> </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> acc&#39; = acc * arg <span class="kw">in</span> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>        helper arg&#39; acc&#39; <span class="kw">in</span> <span class="co">(* end of helper fun *)</span> </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    helper x <span class="dv">1</span>;;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> fact : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">The list reverse function rev can be written in a tail-recursive form as follows:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> rev x = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">rec</span> rev_helper arg acc = </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>      <span class="kw">match</span> arg <span class="kw">with</span> [] -&gt; acc </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>      | h::t -&gt; </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> arg&#39; = t <span class="kw">in</span> </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> acc&#39; = h::acc <span class="kw">in</span> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>        rev_helper arg&#39; acc&#39; <span class="kw">in</span> <span class="co">(* end of helper fun *)</span> </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    rev_helper x [];;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> rev : &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><h4 class="heading">1.24<tt>&nbsp;</tt><a name="(part._.O.Caml_.Data_.Types__.Variants_)"></a>OCaml Data Types (Variants)<span class="button-group"><a href="#(part._.O.Caml_.Data_.Types__.Variants_)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p><div class="SIntrapara">So far, we have encountered these forms of data:
</div><div class="SIntrapara"><ul><li><p>Basic types: <span class="RktSym">int</span><span class="RktMeta"></span>, <span class="RktSym">float</span><span class="RktMeta"></span>, <span class="RktSym">char</span><span class="RktMeta"></span>, <span class="RktSym">string</span><span class="RktMeta"></span></p></li><li><p>Lists: A recursive data structure. A list is either <span class="RktPn">[</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">]</span><span class="RktMeta"></span> or <span class="RktSym">h::t</span><span class="RktMeta"></span>,
and is typically processed using pattern matching</p></li><li><p>Tuples and Records: Group values together into fixed-size collections</p></li><li><p>Functions</p></li></ul></div></p><p>However, relying solely on lists and tuples can be limiting or cumbersome.
How can we design new kinds of data structures more naturally?</p><h4 class="heading">1.25<tt>&nbsp;</tt><a name="(part._.User_.Defined_.Types)"></a>User Defined Types<span class="button-group"><a href="#(part._.User_.Defined_.Types)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>We can introduce new types using the <span style="font-weight: bold">type</span> keyword. In simplest form,
it is like a C &lsquo;enum&lsquo;. They let you represent data that may take on multiple
different forms, where each form is marked by an explicit tag. User defined
types are also called variants or algebraic data types. It is similar to an enumeration
in other languages, but more powerful because each constructor can also carry associated data.</p><p><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> color = Red | Green | Blue | Yellow;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> c = Red;; </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> ;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a># <span class="kw">type</span> color = Red | Green | Blue | Yellow</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> c : color = Red</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">The different constructors can also carry other values with them. For example,
suppose we want a type <span style="font-weight: bold">gen</span> that can either be an integers, a string, or
a float. It can be declared as follows:</div></p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> gen = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    | Int <span class="kw">of</span> <span class="dt">int</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    | Str <span class="kw">of</span> <span class="dt">string</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    | Float <span class="kw">of</span> <span class="dt">float</span>;; </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> ls = [Int <span class="dv">10</span>; Str <span class="st">&quot;alice&quot;</span>; Int <span class="dv">20</span>; Float <span class="fl">1.5</span>];; </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> ;; </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a> <span class="co">(* print a gen type value *)</span> </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> print_gen x = </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> x <span class="kw">with</span> </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>     | Int i -&gt; <span class="dt">Printf</span>.printf <span class="st">&quot;%d</span><span class="ch">\n</span><span class="st">&quot;</span> i </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>     | Str s -&gt; <span class="dt">Printf</span>.printf <span class="st">&quot;%s</span><span class="ch">\n</span><span class="st">&quot;</span> s </span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>     | Float n -&gt; <span class="dt">Printf</span>.printf <span class="st">&quot;%f</span><span class="ch">\n</span><span class="st">&quot;</span> n </span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a> ;; </span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a> <span class="co">(* print a gen list *)</span> </span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a> <span class="dt">List</span>.iter print_gen ls;;</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a># <span class="kw">type</span> gen = Int <span class="kw">of</span> <span class="dt">int</span> | Str <span class="kw">of</span> <span class="dt">string</span> | Float <span class="kw">of</span> <span class="dt">float</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> ls : gen <span class="dt">list</span> = [Int <span class="dv">10</span>; Str <span class="st">&quot;alice&quot;</span>; Int <span class="dv">20</span>; Float <span class="fl">1.5</span>]</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a># # <span class="kw">val</span> print_gen : gen -&gt; <span class="dt">unit</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="dv">10</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>alice</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a><span class="dv">20</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a><span class="fl">1.500000</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">unit</span> = ()</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote><p><div class="SIntrapara">Here is another example:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> suit = Club | Diamond | Heart | Spade;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">type</span> value = Jack | Queen | King | Ace | Num <span class="kw">of</span> <span class="dt">int</span>;; </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">type</span> card = Card <span class="kw">of</span> value * suit;; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> <span class="kw">type</span> hand = card <span class="dt">list</span>;; </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> ([Card(Ace, Spade); Card(Num <span class="dv">7</span>, Heart)]:hand);;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a># <span class="kw">type</span> suit = Club | Diamond | Heart | Spade</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a># <span class="kw">type</span> value = Jack | Queen | King | Ace | Num <span class="kw">of</span> <span class="dt">int</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a># <span class="kw">type</span> card = Card <span class="kw">of</span> value * suit</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a># <span class="kw">type</span> hand = card <span class="dt">list</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>- : hand = [Card (Ace, Spade); Card (Num <span class="dv">7</span>, Heart)]</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><p><div class="SIntrapara">Yet another example:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> coin = Heads | Tails </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> flip x = </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> x <span class="kw">with</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>      Heads -&gt; Tails </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    | Tails -&gt; Heads;; </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> <span class="kw">rec</span> count_heads x = </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> x <span class="kw">with</span> </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>      [] -&gt; <span class="dv">0</span> </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    | (Heads::x&#39;) -&gt; <span class="dv">1</span> + count_heads x&#39; </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    | (_::x&#39;) -&gt; count_heads x&#39;;;</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a># <span class="kw">type</span> coin = Heads | Tails</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> flip : coin -&gt; coin = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> count_heads : coin <span class="dt">list</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><p>The syntax of the variants is as follows:</p><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> t = C1 [<span class="kw">of</span> t1] |... | Cn [<span class="kw">of</span> tn]</span></code></pre></div>
</p><p>the <span style="font-weight: bold">Ci</span> are called constructors</p><p>When we evaluate a variant, a constructor &lsquo;Ci&lsquo; is a value if it has
no associated data. &lsquo;Ci vi&lsquo; is a value if it carries a data. We can destruct
a value of type <span style="font-weight: bold">t</span> by pattern matching. Patterns are constructors &lsquo;Ci&lsquo;
with data components, if any.</p><p>In OCaml, a variant type is a sum type. The type system enforces rules to ensure
constructors are used consistently. Here are the main typechecking rules for variants:</p><ul><li><p><div class="SIntrapara">Constructor Type Uniqueness: Each constructor belongs to exactly one variant type.
Its name determines its type. If a constructor is defined more than once, the later definition
overrides the earlier one.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> color = Red | Green;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">type</span> traffic = Red | Yellow | Green;; </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> Red;; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> ;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a># <span class="kw">type</span> color = Red | Green</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a># <span class="kw">type</span> traffic = Red | Yellow | Green</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a># - : traffic = Red</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p></li><li><p><div class="SIntrapara">Constructor Arity: A constructor may carry no data or one tuple of data.
The types of the carried values must match the declaration.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> shape = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    | Circle <span class="kw">of</span> <span class="dt">float</span> <span class="co">(* radius *)</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    | Rectangle <span class="kw">of</span> <span class="dt">float</span> * <span class="dt">float</span>;; <span class="co">(* width*length *)</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>   <span class="co">(* Rectangle and Circle are constructors, so a shape is either </span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co">    Rectangle(w,l) for any floats w and l, or Circle r for any </span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co">    float r *)</span> </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> c = Circle <span class="fl">3.0</span>;;          <span class="co">(* âœ… correct *)</span> </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> r = Rectangle (<span class="fl">3.0</span>, <span class="fl">4.0</span>);; <span class="co">(* âœ… correct *)</span> </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a> <span class="co">(* let bad = Circle &quot;hi&quot;;; âŒ type error: expected float *)</span> </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a> <span class="co">(* We can also creates of list of shapes *)</span> </span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> lst = [Rectangle (<span class="fl">3.0</span>, <span class="fl">4.0</span>) ; Circle <span class="fl">3.0</span>];; </span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> area s = </span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> s <span class="kw">with</span> </span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>      Rectangle (w, l) -&gt; w *. l </span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    | Circle r -&gt; r  *. r *. <span class="fl">3.14</span>;; </span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a> area (Rectangle (<span class="fl">3.0</span>, <span class="fl">4.0</span>));; <span class="co">(* 12.0  *)</span> </span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a> area (Circle <span class="fl">3.0</span>);;      <span class="co">(* 28.26 *)</span> </span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a> ;;</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a># <span class="kw">type</span> shape = Circle <span class="kw">of</span> <span class="dt">float</span> | Rectangle <span class="kw">of</span> <span class="dt">float</span> * <span class="dt">float</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> c : shape = Circle <span class="dv">3</span>.</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> r : shape = Rectangle (<span class="dv">3</span>., <span class="dv">4</span>.)</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> lst : shape <span class="dt">list</span> = [Rectangle (<span class="dv">3</span>., <span class="dv">4</span>.); Circle <span class="dv">3</span>.]</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> area : shape -&gt; <span class="dt">float</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a># - : <span class="dt">float</span> = <span class="dv">12</span>.</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a># - : <span class="dt">float</span> = <span class="fl">28.26</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p></li><li><p>Pattern Matching: In pattern matching, the set of patterns must account
for every constructor of the variant type. If a new constructor is introduced
subsequently, the compiler issues a warning to indicate that the match is no longer exhaustive.</p></li></ul><h5 class="heading">1.25.1<tt>&nbsp;</tt><a name="(part._.Option_.Type)"></a>Option Type<span class="button-group"><a href="#(part._.Option_.Type)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p><div class="SIntrapara">Option values explicitly indicate the presence or absence of a value. Comparing to
 Java, &lsquo;None&lsquo; is like &lsquo;null&lsquo;, while &lsquo;Some i&lsquo; is like an &lsquo;Integer(i)&lsquo; object
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> optional_int = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">None</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>   | <span class="dt">Some</span> <span class="kw">of</span> <span class="dt">int</span> ;; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>   ;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a># <span class="kw">type</span> optional_int = <span class="dt">None</span> | <span class="dt">Some</span> <span class="kw">of</span> <span class="dt">int</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara"><span style="font-weight: bold">Some v</span> reprents the presence of a value &lsquo;v&lsquo;, and &lsquo;None&lsquo; represents the absence of a value.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> divide x y = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> y != <span class="dv">0</span> <span class="kw">then</span> <span class="dt">Some</span> (x/y) </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> <span class="dt">None</span>;; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> string_of_opt o = </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> o <span class="kw">with</span> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Some</span> i -&gt; <span class="dt">string_of_int</span> i </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">None</span> -&gt; <span class="st">&quot;nothing&quot;</span>;; </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> p = divide <span class="dv">1</span> <span class="dv">0</span>;; </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a> <span class="dt">print_string</span> (string_of_opt p);;</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> divide : <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> <span class="dt">option</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> string_of_opt : <span class="dt">int</span> <span class="dt">option</span> -&gt; <span class="dt">string</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> p : <span class="dt">int</span> <span class="dt">option</span> = <span class="dt">None</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>nothing</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">unit</span> = ()</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><p><div class="SIntrapara">The Option type can be polymorphic. We can define an option type that can
hold a value of any data type as follows.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a <span class="dt">option</span> = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Some</span> <span class="kw">of</span> &#39;a </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> | <span class="dt">None</span>;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a <span class="dt">option</span> = <span class="dt">Some</span> <span class="kw">of</span> &#39;a | <span class="dt">None</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">Previously, we implemented the &lsquo;hd&lsquo; function as:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> hd l = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> l <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    | h::_ -&gt;h;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>Lines <span class="dv">2-3</span>, characters <span class="dv">4-14</span>:</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span> | ....<span class="kw">match</span> l <span class="kw">with</span> </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="dv">3</span> |     | h::_ -&gt;h..</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>Warning <span class="dv">8</span> [partial-<span class="kw">match</span>]: this pattern-matching is <span class="dt">not</span> exhaustive.</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>Here is an example <span class="kw">of</span> a case that is <span class="dt">not</span> matched:</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>[]</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> hd : &#39;a <span class="dt">list</span> -&gt; &#39;a = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">This implementaion throws a <span style="font-weight: bold">Match_failure</span> exception when the input is an empty list.
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>hd [];;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>Exception: <span class="dt">Match_failure</span></span></code></pre></div>

Now, we can reimplement the <span style="font-weight: bold">hd</span> function for the list using an option type.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a <span class="dt">option</span> =   <span class="dt">Some</span> <span class="kw">of</span> &#39;a | <span class="dt">None</span>;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> hd l = </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> l <span class="kw">with</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    [] -&gt; <span class="dt">None</span> </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    | x::_ -&gt; <span class="dt">Some</span> x </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    ;; </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> p = hd [];; </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> q = hd [<span class="dv">1</span>;<span class="dv">2</span>];; </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> r = hd [<span class="st">&quot;a&quot;</span>];;</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a># <span class="kw">type</span> &#39;a <span class="dt">option</span> = <span class="dt">Some</span> <span class="kw">of</span> &#39;a | <span class="dt">None</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> hd : &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">option</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> p : &#39;a <span class="dt">option</span> = <span class="dt">None</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> q : <span class="dt">int</span> <span class="dt">option</span> = <span class="dt">Some</span> <span class="dv">1</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> r : <span class="dt">string</span> <span class="dt">option</span> = <span class="dt">Some</span> <span class="st">&quot;a&quot;</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><h5 class="heading">1.25.2<tt>&nbsp;</tt><a name="(part._.Recursive_.Data_.Types)"></a>Recursive Data Types<span class="button-group"><a href="#(part._.Recursive_.Data_.Types)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>A type is recursive if in its implementation it refers to to its own
definition. Functions over a recursive type are often defined by recursion.</p><p><div class="SIntrapara">We can write our own version of lists using variant types. Suppose we want
to define values that act like linked lists of integers. A linked list is
 either empty, or it has an integer followed by another list containing the
 rest of the list elements. This leads to a the following type declaration:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> intlist = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    | Nil </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    | Cons <span class="kw">of</span> (<span class="dt">int</span> * intlist);; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> ;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a># <span class="kw">type</span> intlist = Nil | Cons <span class="kw">of</span> (<span class="dt">int</span> * intlist)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">This type has two constructors, <span style="font-weight: bold">Nil</span> and <span style="font-weight: bold">Cons</span>. It is a recursive type
because it mentions itself in its own definition in the Cons constructor.</div></p><p>Any list of integers can be represented by using this type. For example, the
empty list is just the constructor <span style="font-weight: bold">Nil</span>, and <span style="font-weight: bold">Cons</span> corresponds to the operator
<span style="font-weight: bold">::</span>. Here are some examples of lists:
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>Nil;;   <span class="co">(* empty list *)</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>- : intlist = Nil</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a># Cons(<span class="dv">1</span>,Nil);;  <span class="co">(* 1--&gt;Nil *)</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>- : intlist = Cons (<span class="dv">1</span>, Nil)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a># Cons(<span class="dv">1</span>, Cons(<span class="dv">2</span>,Cons(<span class="dv">3</span>,Nil)));; <span class="co">(* 1--&gt;2--&gt;3--&gt;Nil *)</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>- : intlist = Cons (<span class="dv">1</span>, Cons (<span class="dv">2</span>, Cons (<span class="dv">3</span>, Nil)))</span></code></pre></div>
</p><h5 class="heading">1.25.3<tt>&nbsp;</tt><a name="(part._.Polymorphic_.List)"></a>Polymorphic List<span class="button-group"><a href="#(part._.Polymorphic_.List)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a mylist = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>     Nil </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    | Cons <span class="kw">of</span> (<span class="dt">int</span> * &#39;a mylist);; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> <span class="co">(* length of the list *)</span> </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> <span class="kw">rec</span> len = <span class="kw">function</span> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>     Nil -&gt; <span class="dv">0</span> </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>   | Cons (_, t) -&gt; <span class="dv">1</span> + (len t);; </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a> len (Cons (<span class="dv">10</span>, Cons (<span class="dv">20</span>, Cons (<span class="dv">30</span>, Nil))));; </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a> <span class="co">(* Remove repeated elements from the list *)</span> </span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> <span class="kw">rec</span> uniq lst = </span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> lst <span class="kw">with</span> </span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    |Nil -&gt; Nil </span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    | Cons(x, Nil) -&gt; Cons(x, Nil) </span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    | Cons(x, Cons(y, t)) -&gt; </span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>       <span class="kw">if</span> x = y <span class="kw">then</span> uniq (Cons (y , t)) </span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>       <span class="kw">else</span> Cons(x , uniq (Cons(y , t)));; </span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> l = Cons(<span class="dv">1</span>, Cons(<span class="dv">2</span>, Cons(<span class="dv">2</span>, Cons(<span class="dv">3</span>,Nil))));; </span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a> uniq l;; </span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a> <span class="co">(* Create an mylist from an OCaml list *)</span> </span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> <span class="kw">rec</span> mylist_of_list (ls : &#39;a <span class="dt">list</span>) : &#39;a mylist = </span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> ls <span class="kw">with</span> </span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>          [] -&gt; Nil </span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>          | h::t -&gt; Cons(h, (mylist_of_list t));; </span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> ol = mylist_of_list [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>;<span class="dv">4</span>];; </span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a> <span class="co">(* sum of a mylist *)</span> </span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> <span class="kw">rec</span> list_sum l = </span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> l <span class="kw">with</span> </span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>          |Nil-&gt;<span class="dv">0</span> </span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>          |Cons(h,t) -&gt; h + (list_sum t);; </span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> m = list_sum ol;; </span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> c = Cons(<span class="dv">10</span>,Cons(<span class="dv">20</span>,Cons(<span class="dv">30</span>,Nil)));; </span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a> <span class="dt">print_int</span> (list_sum c);; <span class="co">(* 60 *)</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a># <span class="kw">type</span> &#39;a mylist = Nil | Cons <span class="kw">of</span> (<span class="dt">int</span> * &#39;a mylist)</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> len : &#39;a mylist -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a># - : <span class="dt">int</span> = <span class="dv">3</span></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> uniq : &#39;a mylist -&gt; &#39;b mylist = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> l : &#39;a mylist = Cons (<span class="dv">1</span>, Cons (<span class="dv">2</span>, Cons (<span class="dv">2</span>, Cons (<span class="dv">3</span>, Nil))))</span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a># - : &#39;a mylist = Cons (<span class="dv">1</span>, Cons (<span class="dv">2</span>, Cons (<span class="dv">3</span>, Nil)))</span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> mylist_of_list : <span class="dt">int</span> <span class="dt">list</span> -&gt; <span class="dt">int</span> mylist = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> ol : <span class="dt">int</span> mylist = Cons (<span class="dv">1</span>, Cons (<span class="dv">2</span>, Cons (<span class="dv">3</span>, Cons (<span class="dv">4</span>, Nil))))</span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> list_sum : &#39;a mylist -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> m : <span class="dt">int</span> = <span class="dv">10</span></span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> c : &#39;a mylist = Cons (<span class="dv">10</span>, Cons (<span class="dv">20</span>, Cons (<span class="dv">30</span>, Nil)))</span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a><span class="dv">60</span></span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">unit</span> = ()</span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote><h5 class="heading">1.25.4<tt>&nbsp;</tt><a name="(part._.Binary_.Trees)"></a>Binary Trees<span class="button-group"><a href="#(part._.Binary_.Trees)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p><div class="SIntrapara">We can use variants to represnt tree data structures as well. Here is the definition of a binary tree:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a tree =</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>   | Leaf</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>   | Node <span class="kw">of</span> &#39;a tree * &#39;a * &#39;a tree;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> empty = Leaf;;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> t = Node(Leaf, <span class="dv">100</span>, Node(Leaf,<span class="dv">200</span>,Leaf));;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a># <span class="kw">type</span> &#39;a tree = Leaf | Node <span class="kw">of</span> &#39;a tree * &#39;a * &#39;a tree</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> empty : &#39;a tree = Leaf</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> t : <span class="dt">int</span> tree = Node (Leaf, <span class="dv">100</span>, Node (Leaf, <span class="dv">200</span>, Leaf))</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">For the following examples, we use the binary trees t and t2 as illustrated below:
<img src="binary_tree1.png" alt="" width="256" height="384"/>
:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">a</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">/</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">\</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">b</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">c</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">/ \</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">/ \</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">/</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">\</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">\</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">d</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">e</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">f</span></p></td></tr><tr><td><p><span class="stt">/\</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">/\</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">/ \</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">g</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">/ \</span></p></td></tr></table></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a tree =</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>   | Leaf</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>   | Node <span class="kw">of</span> &#39;a tree * &#39;a * &#39;a tree;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> t2 = Node(Node(Node(Leaf, <span class="ch">&#39;d&#39;</span>, Leaf),<span class="ch">&#39;b&#39;</span>, Node(Leaf,<span class="ch">&#39;e&#39;</span>, Leaf)), <span class="ch">&#39;a&#39;</span>, </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>     Node(Leaf,<span class="ch">&#39;c&#39;</span>, Node(Node(Leaf, <span class="ch">&#39;g&#39;</span>, Leaf),<span class="ch">&#39;f&#39;</span>, Leaf)));;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="co">(* sun of an int tree *)</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> sum t = </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> t <span class="kw">with</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>  Leaf -&gt; <span class="dv">0</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>  | Node(l,v,r)-&gt; (sum l) + v + (sum r)</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="co">(* Count the number of nodes *)</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> count tree = </span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> tree <span class="kw">with</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    Leaf-&gt;<span class="dv">0</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    |Node(l,v,r)-&gt;<span class="dv">1</span> + count(l) + count(r);;</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="co">(* Coune the number of leaves *)</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> count_leaves = <span class="kw">function</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>  | Leaf -&gt; <span class="dv">0</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>    | Node(Leaf,_, Leaf) -&gt; <span class="dv">1</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>    | Node(l,_, r) -&gt; count_leaves l + count_leaves r;;</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a><span class="co">(* Collect values of leaf nodes in a list *)</span> </span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> leaves = <span class="kw">function</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>    | Leaf -&gt; []</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>    | Node(Leaf, c, Leaf) -&gt; [c]</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>    | Node(l, _, r) -&gt; leaves l @ leaves r;;</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a><span class="co">(* Collect the internal nodes of a binary tree in a list *)</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> internals = <span class="kw">function</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>    | Leaf | Node(Leaf,_, Leaf) -&gt; []</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>    | Node(l, v, r) -&gt; internals l @ (v :: internals r);;</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a><span class="co">(* Collect the nodes at a given level in a list *)</span></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> at_level t n = <span class="kw">match</span> t <span class="kw">with</span></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>    | Leaf -&gt; []</span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>    | Node(left, c, right) -&gt;</span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> n = <span class="dv">1</span> <span class="kw">then</span> [c]</span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span> at_level left (n - <span class="dv">1</span>) @ at_level right (n - <span class="dv">1</span>);;</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a> at_level t2 <span class="dv">2</span>;;</span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a><span class="co">(* insert an item to a binary search tree *)</span></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> insert t n =</span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> t <span class="kw">with</span> </span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>    |Leaf-&gt;Node(Leaf, n,Leaf)</span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>    |Node(left,value,right)-&gt; </span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> n &lt; value <span class="kw">then</span> Node((insert left n), value,right) </span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> </span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> n &gt; value <span class="kw">then</span> Node(left, value,(insert right n))</span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>      <span class="kw">else</span> Node(left,value,right);;</span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a><span class="co">(* Height of a tree *)</span></span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> height t=</span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> t <span class="kw">with</span> </span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>    |Leaf -&gt; <span class="dv">0</span></span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>    |Node(l,v,r)-&gt;<span class="dv">1</span> + <span class="dt">max</span> (height l) (height r);;</span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a><span class="co">(* Inorder traversal *)</span></span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> inorder t = </span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> t <span class="kw">with</span> </span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a>    |Leaf-&gt;[]</span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a>    |Node(l,v,r)-&gt; (inorder l)@[v]@(inorder r);;</span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a>inorder t2;;</span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a><span class="co">(* Preorder traversal *)</span></span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> preorder t = </span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> t <span class="kw">with</span> </span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a>    |Leaf-&gt;[]</span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a>    |Node(l,v,r)-&gt;</span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a>             v::(preorder l) @ (preorder r);;</span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true" tabindex="-1"></a>preorder t2;;</span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-81"><a href="#cb1-81" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> postorder t = </span>
<span id="cb1-82"><a href="#cb1-82" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> t <span class="kw">with</span> </span>
<span id="cb1-83"><a href="#cb1-83" aria-hidden="true" tabindex="-1"></a>    |Leaf-&gt;[]</span>
<span id="cb1-84"><a href="#cb1-84" aria-hidden="true" tabindex="-1"></a>    |Node(l,v,r)-&gt;</span>
<span id="cb1-85"><a href="#cb1-85" aria-hidden="true" tabindex="-1"></a>            (postorder l)@</span>
<span id="cb1-86"><a href="#cb1-86" aria-hidden="true" tabindex="-1"></a>            (postorder r)@</span>
<span id="cb1-87"><a href="#cb1-87" aria-hidden="true" tabindex="-1"></a>        [v];;</span>
<span id="cb1-88"><a href="#cb1-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-89"><a href="#cb1-89" aria-hidden="true" tabindex="-1"></a>postorder t2;;</span>
<span id="cb1-90"><a href="#cb1-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-91"><a href="#cb1-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-92"><a href="#cb1-92" aria-hidden="true" tabindex="-1"></a><span class="co">(* Level order traversal *)</span></span>
<span id="cb1-93"><a href="#cb1-93" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> levelOrder t = </span>
<span id="cb1-94"><a href="#cb1-94" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> q=<span class="dt">Queue</span>.create () <span class="kw">in</span> </span>
<span id="cb1-95"><a href="#cb1-95" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> _ = <span class="dt">Queue</span>.push t q <span class="kw">in</span> </span>
<span id="cb1-96"><a href="#cb1-96" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> aux queue =</span>
<span id="cb1-97"><a href="#cb1-97" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> <span class="dt">Queue</span>.is_empty queue <span class="kw">then</span> () <span class="kw">else</span></span>
<span id="cb1-98"><a href="#cb1-98" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> c = <span class="dt">Queue</span>.pop queue <span class="kw">in</span></span>
<span id="cb1-99"><a href="#cb1-99" aria-hidden="true" tabindex="-1"></a>            <span class="kw">match</span> c <span class="kw">with</span> </span>
<span id="cb1-100"><a href="#cb1-100" aria-hidden="true" tabindex="-1"></a>            |Leaf -&gt;aux queue</span>
<span id="cb1-101"><a href="#cb1-101" aria-hidden="true" tabindex="-1"></a>            |Node(l,v,r)-&gt;<span class="dt">Printf</span>.printf <span class="st">&quot;%c,&quot;</span> v;</span>
<span id="cb1-102"><a href="#cb1-102" aria-hidden="true" tabindex="-1"></a>                <span class="kw">let</span> _= <span class="dt">Queue</span>.push l queue <span class="kw">in</span></span>
<span id="cb1-103"><a href="#cb1-103" aria-hidden="true" tabindex="-1"></a>                <span class="kw">let</span> _ = <span class="dt">Queue</span>.push r queue <span class="kw">in</span></span>
<span id="cb1-104"><a href="#cb1-104" aria-hidden="true" tabindex="-1"></a>        aux queue</span>
<span id="cb1-105"><a href="#cb1-105" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span> aux q;;</span>
<span id="cb1-106"><a href="#cb1-106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-107"><a href="#cb1-107" aria-hidden="true" tabindex="-1"></a>levelOrder t2;;</span>
<span id="cb1-108"><a href="#cb1-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-109"><a href="#cb1-109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-110"><a href="#cb1-110" aria-hidden="true" tabindex="-1"></a># <span class="kw">type</span> &#39;a tree = Leaf | Node <span class="kw">of</span> &#39;a tree * &#39;a * &#39;a tree</span>
<span id="cb1-111"><a href="#cb1-111" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> t2 : <span class="dt">char</span> tree =</span>
<span id="cb1-112"><a href="#cb1-112" aria-hidden="true" tabindex="-1"></a>  Node (Node (Node (Leaf, <span class="ch">&#39;d&#39;</span>, Leaf), <span class="ch">&#39;b&#39;</span>, Node (Leaf, <span class="ch">&#39;e&#39;</span>, Leaf)), <span class="ch">&#39;a&#39;</span>,</span>
<span id="cb1-113"><a href="#cb1-113" aria-hidden="true" tabindex="-1"></a>   Node (Leaf, <span class="ch">&#39;c&#39;</span>, Node (Node (Leaf, <span class="ch">&#39;g&#39;</span>, Leaf), <span class="ch">&#39;f&#39;</span>, Leaf)))</span>
<span id="cb1-114"><a href="#cb1-114" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> sum : <span class="dt">int</span> tree -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-115"><a href="#cb1-115" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> count : &#39;a tree -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-116"><a href="#cb1-116" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> count_leaves : &#39;a tree -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-117"><a href="#cb1-117" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> leaves : &#39;a tree -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-118"><a href="#cb1-118" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> internals : &#39;a tree -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-119"><a href="#cb1-119" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> at_level : &#39;a tree -&gt; <span class="dt">int</span> -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-120"><a href="#cb1-120" aria-hidden="true" tabindex="-1"></a># - : <span class="dt">char</span> <span class="dt">list</span> = [<span class="ch">&#39;b&#39;</span>; <span class="ch">&#39;c&#39;</span>]</span>
<span id="cb1-121"><a href="#cb1-121" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> insert : &#39;a tree -&gt; &#39;a -&gt; &#39;a tree = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-122"><a href="#cb1-122" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> height : &#39;a tree -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-123"><a href="#cb1-123" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> inorder : &#39;a tree -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-124"><a href="#cb1-124" aria-hidden="true" tabindex="-1"></a># - : <span class="dt">char</span> <span class="dt">list</span> = [<span class="ch">&#39;d&#39;</span>; <span class="ch">&#39;b&#39;</span>; <span class="ch">&#39;e&#39;</span>; <span class="ch">&#39;a&#39;</span>; <span class="ch">&#39;c&#39;</span>; <span class="ch">&#39;g&#39;</span>; <span class="ch">&#39;f&#39;</span>]</span>
<span id="cb1-125"><a href="#cb1-125" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> preorder : &#39;a tree -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-126"><a href="#cb1-126" aria-hidden="true" tabindex="-1"></a># - : <span class="dt">char</span> <span class="dt">list</span> = [<span class="ch">&#39;a&#39;</span>; <span class="ch">&#39;b&#39;</span>; <span class="ch">&#39;d&#39;</span>; <span class="ch">&#39;e&#39;</span>; <span class="ch">&#39;c&#39;</span>; <span class="ch">&#39;f&#39;</span>; <span class="ch">&#39;g&#39;</span>]</span>
<span id="cb1-127"><a href="#cb1-127" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> postorder : &#39;a tree -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-128"><a href="#cb1-128" aria-hidden="true" tabindex="-1"></a># - : <span class="dt">char</span> <span class="dt">list</span> = [<span class="ch">&#39;d&#39;</span>; <span class="ch">&#39;e&#39;</span>; <span class="ch">&#39;b&#39;</span>; <span class="ch">&#39;g&#39;</span>; <span class="ch">&#39;f&#39;</span>; <span class="ch">&#39;c&#39;</span>; <span class="ch">&#39;a&#39;</span>]</span>
<span id="cb1-129"><a href="#cb1-129" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> levelOrder : <span class="dt">char</span> tree -&gt; <span class="dt">unit</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-130"><a href="#cb1-130" aria-hidden="true" tabindex="-1"></a># a,b,c,d,e,f,g,- : <span class="dt">unit</span> = ()</span>
<span id="cb1-131"><a href="#cb1-131" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-132"><a href="#cb1-132" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><p>We can construct a binary search tree from a list using <span style="font-weight: bold">fold</span>,
which progressively inserts the elements of the list into the accumulator.
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> root = <span class="dt">List</span>.fold_left insert Leaf [<span class="dv">100</span>;<span class="dv">50</span>;<span class="dv">200</span>;<span class="dv">10</span>;<span class="dv">60</span>;<span class="dv">250</span>;<span class="dv">300</span>];;</span></code></pre></div>
</p><h5 class="heading">1.25.5<tt>&nbsp;</tt><a name="(part._.N-ary_.Trees)"></a>N-ary Trees<span class="button-group"><a href="#(part._.N-ary_.Trees)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p><div class="SIntrapara">N-ary tree is a collection of nodes where each node stores a data of type &lsquo;&rsquo;a&lsquo; and its children, a list of &lsquo;&rsquo;a trees&lsquo;. When this list is empty, then the Node is implicitly a leaf node. Note that leaf and inner nodes all contain data in this representation of a tree. Type:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a n_tree = Node <span class="kw">of</span> &#39;a * &#39;a n_tree <span class="dt">list</span>;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> ;;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a># <span class="kw">type</span> &#39;a n_tree = Node <span class="kw">of</span> &#39;a * &#39;a n_tree <span class="dt">list</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">Here is a tree that you can use for simple tests of your functions.
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">1</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">/</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">\</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">/</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">\</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">2</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">7</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span><span class="stt">/</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">|</span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">\</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">\</span></p></td></tr><tr><td><p><span class="stt">3</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">4</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">5</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">8</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">|</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">6</span></p></td></tr></table></div></p><p><div class="SIntrapara">* Count the nodes in an n-ary tree
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &#39;a n_tree = Node <span class="kw">of</span> &#39;a * &#39;a n_tree <span class="dt">list</span>;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> <span class="kw">rec</span> nodes t = </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> t <span class="kw">with</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    | Node (x, children) -&gt; <span class="dv">1</span> + <span class="dt">List</span>.fold_left ( + ) <span class="dv">0</span> (<span class="dt">List</span>.map nodes children);; </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> t = </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    Node </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>      ( <span class="dv">1</span>, </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>        [ </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>          Node </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>            ( <span class="dv">2</span>, </span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>              [ </span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>                Node (<span class="dv">3</span>, []); </span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>                Node (<span class="dv">4</span>, [ Node (<span class="dv">6</span>, []) ]); </span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>                Node (<span class="dv">5</span>, []) </span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>              ] </span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>            ); </span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>          Node (<span class="dv">7</span>, [ Node (<span class="dv">8</span>, []) ]); </span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>        ] );; </span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a> nodes t;; </span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a> <span class="co">(* Calculate the sum an int n-ary tree *)</span> </span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> <span class="kw">rec</span> sum t = </span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> t <span class="kw">with</span> </span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    | Node (x, children) -&gt; x + <span class="dt">List</span>.fold_left ( + ) <span class="dv">0</span> (<span class="dt">List</span>.map sum children);; </span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a> sum t;; </span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a> <span class="co">(* Print an n-anry tree *)</span> </span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> <span class="kw">rec</span> print t = </span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> t <span class="kw">with</span> </span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>    | Node (x, children) -&gt; </span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Printf</span>.printf <span class="st">&quot;%d,&quot;</span> x; </span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>        <span class="dt">List</span>.iter print children;; </span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a> print t;;</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a># <span class="kw">type</span> &#39;a n_tree = Node <span class="kw">of</span> &#39;a * &#39;a n_tree <span class="dt">list</span></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> nodes : &#39;a n_tree -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> t : <span class="dt">int</span> n_tree =</span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>  Node (<span class="dv">1</span>,</span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>   [Node (<span class="dv">2</span>, [Node (<span class="dv">3</span>, []); Node (<span class="dv">4</span>, [Node (<span class="dv">6</span>, [])]); Node (<span class="dv">5</span>, [])]);</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>    Node (<span class="dv">7</span>, [Node (<span class="dv">8</span>, [])])])</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a># - : <span class="dt">int</span> = <span class="dv">8</span></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> sum : <span class="dt">int</span> n_tree -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a># - : <span class="dt">int</span> = <span class="dv">36</span></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> print : <span class="dt">int</span> n_tree -&gt; <span class="dt">unit</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">6</span>,<span class="dv">5</span>,<span class="dv">7</span>,<span class="dv">8</span>,</span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">unit</span> = ()</span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><h4 class="heading">1.26<tt>&nbsp;</tt><a name="(part._.Exceptions)"></a>Exceptions<span class="button-group"><a href="#(part._.Exceptions)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>In OCaml, exceptions are used to handle errors or unusual
conditions in a controlled way. They are similar in spirit
to exceptions in other languages (like Java or Python), but
they integrate neatly into OCaml&#8217;s functional style.</p><p>Exceptions are introduced using the exception keyword. They
can also be listed in a module&#8217;s signature. Like type
constructors, exceptions may carry arguments, but they
can also be defined without any arguments.
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">exception</span> <span class="dt">Not_found</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">exception</span> Invalid_input <span class="kw">of</span> <span class="dt">string</span></span></code></pre></div>
</p><p>You use raise to throw an exception:
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="dt">raise</span> <span class="dt">Not_found</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="dt">raise</span> (Invalid_input <span class="st">&quot;negative number&quot;</span>)</span></code></pre></div>
</p><p><div class="SIntrapara">Exceptions are caught using <span style="font-weight: bold">try ... with</span>, where
the <span style="font-weight: bold">with</span> clause supports pattern matching.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">exception</span> Invalid_input <span class="kw">of</span> <span class="dt">string</span>;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> safe_div a b = </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">try</span> a / b <span class="kw">with</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">Division_by_zero</span> -&gt; <span class="dv">0</span>;; </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> parse_positive s = </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">try</span> </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> n = <span class="dt">int_of_string</span> s <span class="kw">in</span> </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> n &lt; <span class="dv">0</span> <span class="kw">then</span> <span class="dt">raise</span> (Invalid_input <span class="st">&quot;negative number&quot;</span>); </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>      n </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">with</span> </span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    | <span class="dt">Failure</span> _ -&gt; <span class="dt">raise</span> (Invalid_input <span class="st">&quot;not an integer&quot;</span>) </span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    | Invalid_input msg -&gt; </span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Printf</span>.printf <span class="st">&quot;Invalid: %s</span><span class="ch">\n</span><span class="st">&quot;</span> msg; </span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0</span> </span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>      ;;</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a># <span class="kw">exception</span> Invalid_input <span class="kw">of</span> <span class="dt">string</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> safe_div : <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> parse_positive : <span class="dt">string</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">If an exception is not caught:
</div><div class="SIntrapara"><ul><li><p>The current function terminates immediately.</p></li><li><p>Control is passed up the call stack.</p></li><li><p>This continues until the exception is handled, or it propagates to the top level.</p></li></ul></div></p><p><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">exception</span> My_exception <span class="kw">of</span> <span class="dt">int</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> f n = </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> n &gt; <span class="dv">0</span> <span class="kw">then</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>      <span class="dt">raise</span> (My_exception n) </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>      <span class="dt">raise</span> (<span class="dt">Failure</span> <span class="st">&quot;foo&quot;</span>) </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a> <span class="co">(* Handle the exception with try-with *)</span> </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> bar n = </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">try</span> </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>      f n </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">with</span> My_exception n -&gt; </span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Printf</span>.printf <span class="st">&quot;Caught %d</span><span class="ch">\n</span><span class="st">&quot;</span> n </span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>      | <span class="dt">Failure</span> s -&gt; </span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Printf</span>.printf <span class="st">&quot;Caught %s</span><span class="ch">\n</span><span class="st">&quot;</span> s;;</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="kw">exception</span> My_exception <span class="kw">of</span> <span class="dt">int</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> f : <span class="dt">int</span> -&gt; &#39;a = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> bar : <span class="dt">int</span> -&gt; <span class="dt">unit</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara"><ul><li><p><span style="font-weight: bold">failwith s</span>:Raises exception Failure s (s is a string).</p></li><li><p><span style="font-weight: bold">Not_found</span>:Exception raised by library functions if the object does not exist</p></li><li><p><span style="font-weight: bold">invalid_arg s</span>:Raises exception Invalid_argument s.</p></li></ul></div></p><p><div class="SIntrapara"><span style="font-weight: bold">List.assoc</span> throws <span style="font-weight: bold">Not_Found</span> exception if the key is not found in the associative list.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> lst =[(<span class="dv">1</span>,<span class="st">&quot;alice&quot;</span>);(<span class="dv">2</span>,<span class="st">&quot;bob&quot;</span>);(<span class="dv">3</span>,<span class="st">&quot;cat&quot;</span>)];; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> lookup key lst = </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">try</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>      <span class="dt">List</span>.assoc key lst </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">with</span> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Not_found</span> -&gt; <span class="st">&quot;key does not exist&quot;</span>;; </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a> ;;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> lst : (<span class="dt">int</span> * <span class="dt">string</span>) <span class="dt">list</span> = [(<span class="dv">1</span>, <span class="st">&quot;alice&quot;</span>); (<span class="dv">2</span>, <span class="st">&quot;bob&quot;</span>); (<span class="dv">3</span>, <span class="st">&quot;cat&quot;</span>)]</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> lookup : &#39;a -&gt; (&#39;a * <span class="dt">string</span>) <span class="dt">list</span> -&gt; <span class="dt">string</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><h4 class="heading">1.27<tt>&nbsp;</tt><a name="(part._.Closures)"></a>Closures<span class="button-group"><a href="#(part._.Closures)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>In this section, we explore how to implement higher-order functions.</p><p>In OCaml, functions can be passed as arguments to operations like <span style="font-weight: bold">map</span>
or <span style="font-weight: bold">fold</span>. For instance, you can supply an anonymous function such as <span style="font-weight: bold">fun x -&gt; x * 2</span> directly to <span style="font-weight: bold">map</span>.</p><p><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">List</span>.map (<span class="kw">fun</span> x-&gt; x * <span class="dv">2</span>) [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>;<span class="dv">4</span>;<span class="dv">5</span>];;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">2</span>; <span class="dv">4</span>; <span class="dv">6</span>; <span class="dv">8</span>; <span class="dv">10</span>]</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">You can return functions as results as well.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> pick_fn n = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> plus3 x = x + <span class="dv">3</span> <span class="kw">in</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> plus4 x = x + <span class="dv">4</span> <span class="kw">in</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> n &gt; <span class="dv">0</span> <span class="kw">then</span> plus3 <span class="kw">else</span> plus4 </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    ;;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> pick_fn : <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">Here, <span style="font-weight: bold">pick_fn</span> takes an <span style="font-weight: bold">int</span> argument, and returns a function.
The type of <span style="font-weight: bold">pick_fn</span> is <span style="font-weight: bold">int -&gt; (int-&gt;int)</span></div></p><h5 class="heading">1.27.1<tt>&nbsp;</tt><a name="(part._.Multi-argument_.Functions)"></a>Multi-argument Functions<span class="button-group"><a href="#(part._.Multi-argument_.Functions)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p><div class="SIntrapara">Consider a rewriting of the function &lsquo;pick_fn&lsquo;
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> pick_fn n = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> n &gt; <span class="dv">0</span> <span class="kw">then</span> (<span class="kw">fun</span> x-&gt;x+<span class="dv">3</span>) <span class="kw">else</span> (<span class="kw">fun</span> x-&gt;x+<span class="dv">4</span>);;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> pick_fn : <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">Here&#8217;s another version
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> pick_fn n = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">fun</span> x -&gt; <span class="kw">if</span> n &gt; <span class="dv">0</span> <span class="kw">then</span> x+<span class="dv">3</span> <span class="kw">else</span> x+<span class="dv">4</span>);;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> pick_fn : <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">The shorthand for which is just
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> pick_fn n x = <span class="kw">if</span> n &gt; <span class="dv">0</span> <span class="kw">then</span> x+<span class="dv">3</span> <span class="kw">else</span> x+<span class="dv">4</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> pick_fn : <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">All the above implementation of <span style="font-weight: bold">pick_fn</span> are same: take one <span style="font-weight: bold">int</span> argument,
and returns a function that takes another <span style="font-weight: bold">int</span> argument.</div></p><h5 class="heading">1.27.2<tt>&nbsp;</tt><a name="(part._.Currying)"></a>Currying<span class="button-group"><a href="#(part._.Currying)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Functions in OCaml do not have a special notion of &#8220;multiple
arguments.&#8221; Instead, a multi-argument function is encoded as a
function that takes one argument and returns another function
for the remaining arguments.</p><p>This transformation is known as currying, named after the
logician Haskell B. Curry. In fact, three programming
languages&#8212;Haskell, Brook, and Curry&#8212;are named after him.
Currying is the process of converting a function of several
arguments into a sequence of single-argument functions.</p><p><div class="SIntrapara">OCaml syntax defaults to currying. E.g.,
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> add x y = x + y;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> add : <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><p><div class="SIntrapara">is identical to all of the following:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> add = (<span class="kw">fun</span> x -&gt; (<span class="kw">fun</span> y -&gt; x + y));; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> add = (<span class="kw">fun</span> x y -&gt; x + y);; </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> add x = (<span class="kw">fun</span> y -&gt; x+y);;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> add : <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> add : <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> add : <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">Thus &lsquo;add&lsquo; has type &lsquo;int -&gt; (int -&gt; int)&lsquo;. &lsquo;add 3&lsquo; has type &lsquo;int -&gt; int&lsquo;, and &lsquo;add 3&lsquo; is a function that &lsquo;adds 3&lsquo; to its argument. For example: &lsquo;(add 3) 4 = 7&lsquo;. This works for any number of arguments. Here is another example a curried add function with three arguments:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> add x y z = x + y + z;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> add : <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">is same as
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> add x = (<span class="kw">fun</span> y -&gt; (<span class="kw">fun</span> z -&gt; x+y+z));;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> add : <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">Then
</div><div class="SIntrapara"><ul><li><p><span style="font-weight: bold">add</span> has type <span style="font-weight: bold">int -&gt; (int -&gt; (int -&gt; int))</span></p></li><li><p><span style="font-weight: bold">add 4</span> has type <span style="font-weight: bold">int -&gt; (int -&gt; int)</span></p></li><li><p><span style="font-weight: bold">add 4 5</span> has type <span style="font-weight: bold">int -&gt; int</span></p></li><li><p><span style="font-weight: bold">add 4 5 6</span> is <span style="font-weight: bold">15</span></p></li></ul></div></p><p><div class="SIntrapara">Because currying is so common, OCaml uses the following conventions:
</div><div class="SIntrapara"><ul><li><p><span style="font-weight: bold">&#8594;</span> associates from the right. Thus <span style="font-weight: bold">int &#8594; int &#8594; int</span> is the same as <span style="font-weight: bold">int &#8594; (int &#8594; int)</span>. </p></li><li><p>function application associates from the left. Thus &lsquo;add 3 4&lsquo; is the same as &lsquo;(add 3) 4&lsquo;.</p></li></ul></div></p><p><div class="SIntrapara">Syntax note: function vs. fun
</div><div class="SIntrapara"><ul><li><p>fun x y &#8230; z -&gt; e defines a curried function.</p></li><li><p>function p1 -&gt; e1 | &#8230; | pn -&gt; en defines a single-argument function with multiple
pattern-matching cases, making it more expressive.</p></li></ul></div></p><p><div class="SIntrapara">For example, you can write: &#8230;
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> sum l = <span class="kw">match</span> l <span class="kw">with</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    [] -&gt; <span class="dv">0</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> | (h::t) -&gt; h + (sum t) </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> ;; </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> <span class="co">(* as  *)</span> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> <span class="kw">rec</span> sum = <span class="kw">function</span> </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>     [] -&gt; <span class="dv">0</span> </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>   | (h::t) -&gt; h + (sum t);; </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>   ;;</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> sum : <span class="dt">int</span> <span class="dt">list</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> sum : <span class="dt">int</span> <span class="dt">list</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">Another way you could encode support for multiple arguments is using tuples.
In the following example, function &lsquo;foo&lsquo; takes a single argument, a tuple with
two elements. Function &lsquo;bar&lsquo; takes two arguments. As the result, &lsquo;bar&lsquo; supports
partial application. It is useful when you want to provide some arguments
now, the rest later.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> foo (a,b) = a / b;; <span class="co">(* int*int -&gt; int *)</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> bar a b = a / b;; <span class="co">(* int-&gt; int-&gt; int *)</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> v = foo(<span class="dv">10</span>,<span class="dv">2</span>);; <span class="co">(* single argument *)</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> div10 = bar <span class="dv">10</span>;; </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> div10 <span class="dv">2</span>;; <span class="co">(* evaluates to 5 *)</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> foo : <span class="dt">int</span> * <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> bar : <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> v : <span class="dt">int</span> = <span class="dv">5</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> div10 : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">5</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><p>Currying is standard in OCaml. Pretty much all functions are curried, such as standard library &lsquo;map&lsquo;, &lsquo;fold&lsquo;, etc. In particular, look at the file &lsquo;list.ml&lsquo; for standard list functions. Here is the link to the implemntation of &lsquo;map&lsquo; in List module: https://github.com/ocaml/ocaml/blob/trunk/stdlib/list.ml#L80.</p><h5 class="heading">1.27.3<tt>&nbsp;</tt><a name="(part._.How_.Do_.We_.Implement_.Currying_)"></a>How Do We Implement Currying?<span class="button-group"><a href="#(part._.How_.Do_.We_.Implement_.Currying_)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>OCaml makes currying efficient because otherwise it would do a lot of useless allocation and destruction of closures. But implementing currying is tricky. Consider:</p><p><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> addN n l = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> add x = n + x <span class="kw">in</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="dt">List</span>.map add l;; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> ;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> addN : <span class="dt">int</span> -&gt; <span class="dt">int</span> <span class="dt">list</span> -&gt; <span class="dt">int</span> <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">The inner function &lsquo;add&lsquo; accesses the variable &lsquo;n&lsquo;
from the outer scope. &lsquo;AddN&lsquo; is equivalent to
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> addN n = (<span class="kw">fun</span> l -&gt; <span class="dt">List</span>.map (<span class="kw">fun</span> x -&gt; n + x) l);;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> addN : <span class="dt">int</span> -&gt; <span class="dt">int</span> <span class="dt">list</span> -&gt; <span class="dt">int</span> <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">When the anonymous function is called by &lsquo;map&lsquo;, &lsquo;n&lsquo; may not be on the stack any more because the the function &lsquo;addN&lsquo; terminates before &lsquo;map&lsquo; is called.  We need some way to keep &lsquo;n&lsquo; around after &lsquo;addN&lsquo; returns.</div></p><p><div class="SIntrapara">Another Example
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> foo x = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> bar = <span class="kw">fun</span> y -&gt; x + y <span class="kw">in</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>   bar;; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> foo <span class="dv">10</span>;;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> foo : <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><p><span style="font-weight: bold">foo 10</span> returns a function of type <span style="font-weight: bold">int -&gt; int</span>:
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">fun</span> y -&gt; <span class="dv">10</span> + y)</span></code></pre></div>
</p><p>But where is <span style="font-weight: bold">x</span> when <span style="font-weight: bold">(fun y -&gt; x + y)</span> is executed later?</p><h5 class="heading">1.27.4<tt>&nbsp;</tt><a name="(part._.Environment)"></a>Environment<span class="button-group"><a href="#(part._.Environment)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>When a function is defined, OCaml createa an environment for the function.
It is a mapping from variable names to values, just like a stack frame. We
call function and its environment together a closure. A closure is a
pair &lsquo;(f, e)&lsquo; consisting of
function code &lsquo;f&lsquo; and an environment &lsquo;e&lsquo;. When you invoke a closure,
&lsquo;f&lsquo; is evaluated using &lsquo;e&lsquo; to look up variable bindings.</p><p><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> add x = (<span class="kw">fun</span> y -&gt; x + y);;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> add : <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">&lsquo;add 3&lsquo; returns a closure where the function body is &lsquo;fun y -&gt; x + y&lsquo; and
the environment contains &lsquo;x=3&lsquo;. When we apply this closure to another
argument &lsquo;4&lsquo;, it calculates &lsquo;x+y&lsquo; by binding &lsquo;y&lsquo; to &lsquo;4&lsquo;, and evaluating &lsquo;x&lsquo;
from its environment to &lsquo;3&lsquo; as shown in the image below.</div></p><p><img src="closure1.png" alt="" width="615" height="250"/></p><p><div class="SIntrapara">Here is another example:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> mult_sum (x, y) = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> z = x + y <span class="kw">in</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">fun</span> w -&gt; w * z;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> mult_sum : <span class="dt">int</span> * <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara"><img src="closure2.png" alt="" width="610" height="218"/></div></p><p>&lsquo;mult_sum (3,4)&lsquo; returns a closure where the function is &lsquo;fun w -&gt; w * z&lsquo; and its environment contains the bindings for &lsquo;x,y&lsquo;, and &lsquo;z&lsquo;.</p><h5 class="heading">1.27.5<tt>&nbsp;</tt><a name="(part._.Scope)"></a>Scope<span class="button-group"><a href="#(part._.Scope)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p><div class="SIntrapara">Scope refers to the places in a program where a variable is visible and
 can be referenced. Scoping rules are all about how to evaluate free
 variables in a function. It is generally divided into two classes:
 dynamic scope and static scope (also called lexcial scope).
</div><div class="SIntrapara"><ul><li><p>Dynamic scope</p><p>The body of a function is evaluated in the current dynamic environment at the time the function is called, not the old dynamic environment that existed at the time the function was defined.</p></li><li><p>Lexical scope</p><p>The body of a function is evaluated in the old dynamic environment that existed at the time the function was defined, not the current environment when the function is called.</p></li></ul></div><div class="SIntrapara">What does this expression should evaluate to?
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = <span class="dv">1</span> <span class="kw">in</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> f = <span class="kw">fun</span> y -&gt; x <span class="kw">in</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> x = <span class="dv">2</span> <span class="kw">in</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> f <span class="dv">0</span>;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>Line <span class="dv">3</span>, characters <span class="dv">5-6</span>:</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="dv">3</span> |  <span class="kw">let</span> x = <span class="dv">2</span> <span class="kw">in</span> </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>         ^</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>Warning <span class="dv">26</span> [unused-var]: unused variable x.</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">1</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">With lexcial scoping, when &lsquo;f 0&lsquo; is evaluated, &lsquo;x&lsquo; refers to &lsquo;1&lsquo;, the value when
the function &lsquo;f&lsquo; is
defined. Therefore, this expression evalues to 1. However, with dynamic scoping, &lsquo;x&lsquo;
refers to &lsquo;2&lsquo;, the value in the environment when then function is called. Therefore,
this expression evalues to &lsquo;2&lsquo;. OCaml and most modern languages use lexcial scoping.
If you try the above example in &lsquo;Utop&lsquo;, it should evaluate to &lsquo;1&lsquo;.</div></p><h5 class="heading">1.27.6<tt>&nbsp;</tt><a name="(part._.Higher-.Order_.Functions_in_.C)"></a>Higher-Order Functions in C<span class="button-group"><a href="#(part._.Higher-.Order_.Functions_in_.C)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p><div class="SIntrapara">C supports function pointers. The function &lsquo;app&lsquo; takes a function
pointer as an argument, and applies that function to each member of
the array. Therefore, &lsquo;app&lsquo; is basically a higher order function.
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">int</span> <span class="op">(*</span>int_func<span class="op">)(</span><span class="dt">int</span><span class="op">);</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> app<span class="op">(</span>int_func f<span class="op">,</span> <span class="dt">int</span> <span class="op">*</span>a<span class="op">,</span> <span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    a<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> f<span class="op">(</span>a<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> add_one<span class="op">(</span><span class="dt">int</span> x<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> x <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> a<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">5</span><span class="op">,</span> <span class="dv">6</span><span class="op">,</span> <span class="dv">7</span><span class="op">};</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  app<span class="op">(</span>add_one<span class="op">,</span> a<span class="op">,</span> <span class="dv">3</span><span class="op">);</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>

But C does not support closures.  Since no nested functions allowed, unbound symbols (free variable) always in global scope
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> y <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> app<span class="op">(</span><span class="dt">int</span><span class="op">(*</span>f<span class="op">)(</span><span class="dt">int</span><span class="op">),</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> f<span class="op">(</span>n<span class="op">);</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> add_y<span class="op">(</span><span class="dt">int</span> x<span class="op">)</span> <span class="op">{</span> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> x <span class="op">+</span> y<span class="op">;</span>  <span class="co">//takes y from the global scope</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  app<span class="op">(</span>add_y<span class="op">,</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>

In C, we cannot access non-local variables. For example, given the following OCaml code:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> add x y = x + y;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> add : <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">Equivalent code in C is illegal
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">(*</span> add<span class="op">(</span><span class="dt">int</span> x<span class="op">))(</span><span class="dt">int</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> add_y<span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> add_y<span class="op">(</span><span class="dt">int</span> y<span class="op">)</span> <span class="op">{</span> </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> x <span class="op">+</span> y<span class="op">;</span> <span class="co">/* error: x undefined */</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div></p><p>Java 8 and many other languages now supports lambda expressions and closures.
Ocaml&#8217;s
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> (a, b) -&gt; a + b</span></code></pre></div>

Is like the following in Java 8
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>(a, b) -&gt; a + b</span></code></pre></div>
</p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="index.html" title="backward to &quot;CMSC 330 Lecture Notes&quot;" data-pltdoc="x" rel="prev">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;CMSC 330 Lecture Notes&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="Imperative_OCaml.html" title="forward to &quot;2 Imperative Programming with OCaml&quot;" data-pltdoc="x" rel="next">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>