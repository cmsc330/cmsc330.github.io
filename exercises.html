<!DOCTYPE html>
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>3&nbsp;OCaml Exercises</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><link rel="stylesheet" type="text/css" href="extra.css" title="default"/><link rel="stylesheet" type="text/css" href="faq.css" title="default"/><link rel="stylesheet" type="text/css" href="fancyverb.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="accordion.js"></script><script type="text/javascript" src="quiz.js"></script><script type="text/javascript" src="manual-racket.js"></script></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">CMSC 330 Lecture Notes</a></td></tr></table></div><div class="tocviewsublistonly" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="intro.html" class="tocviewlink" data-pltdoc="x">Introduction</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="ocaml.html" class="tocviewlink" data-pltdoc="x">Functional Programming with OCaml</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">OCaml Exercises</a></td></tr></table></div></div></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">9.0</span></div><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="ocaml.html" title="backward to &quot;2 Functional Programming with OCaml&quot;" data-pltdoc="x" rel="prev">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;CMSC 330 Lecture Notes&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<span class="nonavigation">next &rarr;</span></span>&nbsp;</div><section class="SsectionLevel2" id="section 3"><h2 class="heading">3<span class="stt">&nbsp;</span><a name="(part._exercises)"></a>OCaml Exercises<span class="button-group"><a href="#(part._exercises)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h2><details class="SubFlow accordion-section"><summary><span style="font-weight: bold">True or False</span></summary><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>Using mutable variables can cause side effects.</p><p><label class="quiz-option"><input type="radio" name="sp25-1-2" value="true" data-correct="true"/> True</label></p><p><label class="quiz-option"><input type="radio" name="sp25-1-2" value="false"/> False</label></p></blockquote></summary><p>Answer: True. Mutable variables allow state to be changed, which is a side effect. Modifying a mutable variable affects the program state beyond just returning a value.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>Due to OCaml&rsquo;s type constraints, you cannot make a list of functions.</p><p><label class="quiz-option"><input type="radio" name="sp25-1-3" value="true"/> True</label></p><p><label class="quiz-option"><input type="radio" name="sp25-1-3" value="false" data-correct="true"/> False</label></p></blockquote></summary><p>Answer: False. You can make a list of functions in OCaml as long as they all have the same type. For example, <span class="stt">[(fun x -&gt; x + 1); (fun x -&gt; x * 2)]</span> is a valid <span class="stt">(int -&gt; int) list</span>.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p><span class="stt">fold_left</span>&rsquo;s accumulator can be a list.</p><p><label class="quiz-option"><input type="radio" name="sp25-1-4" value="true" data-correct="true"/> True</label></p><p><label class="quiz-option"><input type="radio" name="sp25-1-4" value="false"/> False</label></p></blockquote></summary><p>Answer: True. The accumulator can be any type, including a list. For example, <span class="stt">fold_left (fun acc x -&gt; x :: acc) [] [1;2;3]</span> uses a list as the accumulator.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p><span class="stt">fold_left</span>&rsquo;s accumulator can be a tuple.</p><p><label class="quiz-option"><input type="radio" name="sp25-1-5" value="true" data-correct="true"/> True</label></p><p><label class="quiz-option"><input type="radio" name="sp25-1-5" value="false"/> False</label></p></blockquote></summary><p>Answer: True. The accumulator can be any type, including a tuple. For example, <span class="stt">fold_left (fun (s, c) x -&gt; (s + x, c + 1)) (0, 0) [1;2;3]</span> uses a tuple to track both sum and count.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>OCaml uses type inference to determine the type of variables.</p><p><label class="quiz-option"><input type="radio" name="sp24-1-1" value="true" data-correct="true"/> True</label></p><p><label class="quiz-option"><input type="radio" name="sp24-1-1" value="false"/> False</label></p></blockquote></summary><p>Answer: True. OCaml has a powerful type inference system that automatically determines the types of expressions without requiring explicit type annotations.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>Functional Programming Languages favor mutable data.</p><p><label class="quiz-option"><input type="radio" name="sp24-1-2" value="true"/> True</label></p><p><label class="quiz-option"><input type="radio" name="sp24-1-2" value="false" data-correct="true"/> False</label></p></blockquote></summary><p>Answer: False. Functional programming languages favor immutable data. Immutability helps avoid side effects and makes programs easier to reason about.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>Functional Programming aims to decrease the amount of side effects.</p><p><label class="quiz-option"><input type="radio" name="sp24-1-3" value="true" data-correct="true"/> True</label></p><p><label class="quiz-option"><input type="radio" name="sp24-1-3" value="false"/> False</label></p></blockquote></summary><p>Answer: True. A core goal of functional programming is to minimize side effects by using pure functions and immutable data.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>Functions are expressions in OCaml.</p><p><label class="quiz-option"><input type="radio" name="sp24-1-4" value="true" data-correct="true"/> True</label></p><p><label class="quiz-option"><input type="radio" name="sp24-1-4" value="false"/> False</label></p></blockquote></summary><p>Answer: True. In OCaml, functions are first-class values and therefore expressions. You can pass them as arguments, return them from other functions, and bind them to variables.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>In OCaml, all values are expressions but not all expressions are values.</p><p><label class="quiz-option"><input type="radio" name="f24-1-1" value="true" data-correct="true"/> True</label></p><p><label class="quiz-option"><input type="radio" name="f24-1-1" value="false"/> False</label></p></blockquote></summary><p>Answer: True. Everything is an expression, but <span class="stt">2 + 3</span> is an expression that is not a value &#8212;<wbr></wbr> it must be evaluated to produce the value <span class="stt">5</span>.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p><span class="stt">map (fun x -&gt; x + 1) a</span> will modify the list <span class="stt">a</span> in-place.</p><p><label class="quiz-option"><input type="radio" name="f24-1-2" value="true"/> True</label></p><p><label class="quiz-option"><input type="radio" name="f24-1-2" value="false" data-correct="true"/> False</label></p></blockquote></summary><p>Answer: False. <span class="stt">map</span> doesn&rsquo;t modify anything in place because lists are immutable in OCaml. It returns a new list.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>Having mutable variables can make it hard to reason about how a program runs.</p><p><label class="quiz-option"><input type="radio" name="f24-1-3" value="true" data-correct="true"/> True</label></p><p><label class="quiz-option"><input type="radio" name="f24-1-3" value="false"/> False</label></p></blockquote></summary><p>Answer: True. Side effects occur when we have mutability, which can make it difficult to reason about program behavior.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>A function with type <span class="stt">int -&gt; float -&gt; bool</span> returns 2 things: a float and a bool.</p><p><label class="quiz-option"><input type="radio" name="f24-1-4" value="true"/> True</label></p><p><label class="quiz-option"><input type="radio" name="f24-1-4" value="false" data-correct="true"/> False</label></p></blockquote></summary><p>Answer: False. Functions return only 1 thing. This function takes an <span class="stt">int</span> and a <span class="stt">float</span> and returns a <span class="stt">bool</span>.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>A function with type <span class="stt">int -&gt; bool -&gt; float</span> could be interpreted as returning a <span class="stt">bool -&gt; float</span> function.</p><p><label class="quiz-option"><input type="radio" name="f24-1-5" value="true" data-correct="true"/> True</label></p><p><label class="quiz-option"><input type="radio" name="f24-1-5" value="false"/> False</label></p></blockquote></summary><p>Answer: True. Currying allows for this interpretation. <span class="stt">int -&gt; bool -&gt; float</span> is equivalent to <span class="stt">int -&gt; (bool -&gt; float)</span>.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p><span class="stt">let f x = x + 3</span> is an example of a higher order function.</p><p><label class="quiz-option"><input type="radio" name="f24-1-6" value="true"/> True</label></p><p><label class="quiz-option"><input type="radio" name="f24-1-6" value="false" data-correct="true"/> False</label></p></blockquote></summary><p>Answer: False. This function has type <span class="stt">int -&gt; int</span>. It neither takes a function as an argument nor returns a function, so it is not a higher order function.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p><span class="stt">let f x = x 3</span> is an example of a higher order function.</p><p><label class="quiz-option"><input type="radio" name="f24-1-7" value="true" data-correct="true"/> True</label></p><p><label class="quiz-option"><input type="radio" name="f24-1-7" value="false"/> False</label></p></blockquote></summary><p>Answer: True. Because we use <span class="stt">x</span> as a function name (applying it to <span class="stt">3</span>), OCaml infers this has type <span class="stt">(int -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a) -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a</span>. It takes a function as an argument, making it higher order.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>An OCaml function can return different types depending on how it&rsquo;s called.</p><p><label class="quiz-option"><input type="radio" name="f24-1-8" value="true"/> True</label></p><p><label class="quiz-option"><input type="radio" name="f24-1-8" value="false" data-correct="true"/> False</label></p></blockquote></summary><p>Answer: False. A function can only return 1 type (or 1 polymorphic type). The return type is fixed at definition time.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p><span class="stt">let x = 3 in let x = 4 in x</span> is an example of variable shadowing.</p><p><label class="quiz-option"><input type="radio" name="f24-1-9" value="true" data-correct="true"/> True</label></p><p><label class="quiz-option"><input type="radio" name="f24-1-9" value="false"/> False</label></p></blockquote></summary><p>Answer: True. This returns 4. The second <span class="stt">let x = 4</span> shadows the first <span class="stt">let x = 3</span>. Variables are immutable, so shadowing creates a new binding rather than mutating.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p><span class="stt">let x = 3 in let y = 4 in y + x</span> is an example of variable shadowing.</p><p><label class="quiz-option"><input type="radio" name="f24-1-10" value="true"/> True</label></p><p><label class="quiz-option"><input type="radio" name="f24-1-10" value="false" data-correct="true"/> False</label></p></blockquote></summary><p>Answer: False. There are no two variables with the same name, so no shadowing occurs.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p><span class="stt">List.length x = (List.length (List.map f x))</span> for all valid <span class="stt">f</span> and <span class="stt">x</span> (i.e., assume <span class="stt">List.map f x</span> compiles).</p><p><label class="quiz-option"><input type="radio" name="q1-1" value="true" data-correct="true"/> True</label></p><p><label class="quiz-option"><input type="radio" name="q1-1" value="false"/> False</label></p></blockquote></summary><p>Answer: True. <span class="stt">List.map f x</span> always produces a list of the same length as <span class="stt">x</span>, regardless of what <span class="stt">f</span> does to each element.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>If <span class="stt">fold_left f a l</span> compiles and results in value <span class="stt">v</span>, then <span class="stt">fold_right (fun x a -&gt; f a x) l a</span> should also result in <span class="stt">v</span>.</p><p><label class="quiz-option"><input type="radio" name="q1-2" value="true"/> True</label></p><p><label class="quiz-option"><input type="radio" name="q1-2" value="false" data-correct="true"/> False</label></p></blockquote></summary><p>Answer: False. <span class="stt">fold_left</span> and <span class="stt">fold_right</span> process the list in different orders. They only produce the same result when the function <span class="stt">f</span> is associative and commutative (e.g., addition). For non-commutative operations like subtraction or string concatenation, the results differ.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>In OCaml the entire function body is a single expression.</p><p><label class="quiz-option"><input type="radio" name="q1-3" value="true" data-correct="true"/> True</label></p><p><label class="quiz-option"><input type="radio" name="q1-3" value="false"/> False</label></p></blockquote></summary><p>Answer: True. In OCaml, a function body is always a single expression. There are no statements &#8212;<wbr></wbr> everything is an expression that evaluates to a value.</p></details><details class="SubFlow"><summary>OCaml lists are immutable. List 2 benefits of immutability in functional programming.</summary><p>Some benefits of immutability:</p><ul><li><p><span style="font-weight: bold">No aliasing bugs</span>: Since data cannot be modified, sharing references is always safe. You never have to worry about one part of your code unexpectedly changing data used elsewhere.</p></li><li><p><span style="font-weight: bold">Thread safety</span>: Immutable data can be freely shared between threads without locks or synchronization, since no thread can modify the data.</p></li><li><p><span style="font-weight: bold">Easier reasoning</span>: Code is easier to understand and debug because values don&rsquo;t change over time. You can always rely on a value being what it was when it was created.</p></li></ul></details></details><details class="SubFlow accordion-section"><summary><span style="font-weight: bold">Multiple Choice: Typing and Evaluating</span></summary><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of <span class="stt">foo</span> and what does <span class="stt">foo [] [1;2;3]</span> evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> foo x y =</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> x,y <span class="kw">with</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  x::xs,y::ys -&gt; y :: xs</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  | _ -&gt; [] ;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>foo [] [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>] ;;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="sp25-2a" value="1" data-correct="true"/> 'a list -&gt; 'a list -&gt; 'a list, evaluates to []</label></p><p><label class="quiz-option"><input type="radio" name="sp25-2a" value="2"/> 'a list -&gt; 'a list -&gt; 'a list, evaluates to [1]</label></p><p><label class="quiz-option"><input type="radio" name="sp25-2a" value="3"/> int list -&gt; int list -&gt; int list, evaluates to []</label></p><p><label class="quiz-option"><input type="radio" name="sp25-2a" value="4"/> TYPE ERROR</label></p></blockquote></summary><p>Answer: Type is <span class="stt"></span><span class="stt">&rsquo;</span><span class="stt">a list -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a list -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a list</span>. The function pattern-matches on a tuple of two lists. When both are non-empty, it returns <span class="stt">y :: xs</span>. Since <span class="stt">x = []</span> matches the wildcard case, the result is <span class="stt">[]</span>.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of <span class="stt">foo</span> and what does <span class="stt">foo [3;6;9]</span> evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> foo lst = <span class="kw">let</span> total, _ =</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  fold_left</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">fun</span> (tot, idx) ele -&gt;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    (tot + ele * idx, idx + <span class="dv">1</span>))</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  (<span class="dv">0</span>, <span class="dv">0</span>)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  lst <span class="kw">in</span> total;;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>foo [<span class="dv">3</span>;<span class="dv">6</span>;<span class="dv">9</span>] ;;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="sp25-2b" value="1" data-correct="true"/> int list -&gt; int, evaluates to 24</label></p><p><label class="quiz-option"><input type="radio" name="sp25-2b" value="2"/> int list -&gt; int, evaluates to 18</label></p><p><label class="quiz-option"><input type="radio" name="sp25-2b" value="3"/> int list -&gt; int * int, evaluates to (24, 3)</label></p><p><label class="quiz-option"><input type="radio" name="sp25-2b" value="4"/> TYPE ERROR</label></p></blockquote></summary><p>Answer: Type is <span class="stt">int list -&gt; int</span>. The fold computes a weighted sum using the index: <span class="stt">3*0 + 6*1 + 9*2 = 0 + 6 + 18 = 24</span>. The accumulator is a tuple <span class="stt">(total, index)</span>, but <span class="stt">let total, _ = ...</span> destructures it to return only <span class="stt">total</span>.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of <span class="stt">foo</span> and what does <span class="stt">foo [] [1;2;3]</span> evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> foo x y =</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> x,y <span class="kw">with</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  x::xs,y::ys -&gt; y :: xs</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  | _ -&gt; (<span class="dv">0</span>,<span class="dv">0</span>) ;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>foo [] [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>] ;;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="sp25-2c" value="1" data-correct="true"/> TYPE ERROR</label></p><p><label class="quiz-option"><input type="radio" name="sp25-2c" value="2"/> 'a list -&gt; 'a list -&gt; 'a list, evaluates to []</label></p><p><label class="quiz-option"><input type="radio" name="sp25-2c" value="3"/> int list -&gt; int list -&gt; int * int, evaluates to (0,0)</label></p><p><label class="quiz-option"><input type="radio" name="sp25-2c" value="4"/> int list -&gt; int list -&gt; int list, evaluates to (0,0)</label></p></blockquote></summary><p>Answer: TYPE ERROR. The first branch returns <span class="stt">y :: xs</span> (a list), but the second branch returns <span class="stt">(0,0)</span> (a tuple). These types are incompatible, so the match expression cannot be typed.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of <span class="stt">foo</span> and what does <span class="stt">foo [7;4;23]</span> evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> foo lst = <span class="kw">let</span> total, _ =</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  fold_left</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">fun</span> (tot, idx) ele -&gt;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    (tot*ele*idx, idx + <span class="dv">1</span>))</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  (<span class="dv">0</span>, <span class="dv">0</span>)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  lst <span class="kw">in</span> total;;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>foo [<span class="dv">7</span>;<span class="dv">4</span>;<span class="dv">23</span>] ;;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="sp25-2d" value="1" data-correct="true"/> int list -&gt; int, evaluates to 0</label></p><p><label class="quiz-option"><input type="radio" name="sp25-2d" value="2"/> int list -&gt; int, evaluates to 644</label></p><p><label class="quiz-option"><input type="radio" name="sp25-2d" value="3"/> int list -&gt; int, evaluates to 28</label></p><p><label class="quiz-option"><input type="radio" name="sp25-2d" value="4"/> TYPE ERROR</label></p></blockquote></summary><p>Answer: Type is <span class="stt">int list -&gt; int</span>, evaluates to <span class="stt">0</span>. The initial accumulator is <span class="stt">(0, 0)</span>. Since <span class="stt">tot</span> starts at 0 and gets multiplied (<span class="stt">tot*ele*idx</span>), the result stays 0 throughout: <span class="stt">0*7*0 = 0</span>, <span class="stt">0*4*1 = 0</span>, <span class="stt">0*23*2 = 0</span>.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of <span class="stt">foo</span> and what does <span class="stt">foo [] [1;2;3]</span> evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> foo x y = <span class="kw">match</span> x,y <span class="kw">with</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  x::xs,y::ys -&gt; y :: xs</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  | _ -&gt; [<span class="dv">9</span>] ;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>foo [] [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>] ;;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="sp25-2e" value="1" data-correct="true"/> int list -&gt; int list -&gt; int list, evaluates to [9]</label></p><p><label class="quiz-option"><input type="radio" name="sp25-2e" value="2"/> 'a list -&gt; 'a list -&gt; 'a list, evaluates to [9]</label></p><p><label class="quiz-option"><input type="radio" name="sp25-2e" value="3"/> int list -&gt; int list -&gt; int list, evaluates to []</label></p><p><label class="quiz-option"><input type="radio" name="sp25-2e" value="4"/> TYPE ERROR</label></p></blockquote></summary><p>Answer: Type is <span class="stt">int list -&gt; int list -&gt; int list</span>. The wildcard branch returns <span class="stt">[9]</span>, which constrains the type to <span class="stt">int list</span> (not polymorphic <span class="stt"></span><span class="stt">&rsquo;</span><span class="stt">a list</span>). Since <span class="stt">x = []</span> matches the wildcard, the result is <span class="stt">[9]</span>.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of <span class="stt">foo</span> and what does <span class="stt">foo [2;4;8]</span> evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> foo lst = <span class="kw">let</span> total, _ =</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  fold_left</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">fun</span> (tot, idx) ele -&gt;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    (tot + ele * idx, idx + <span class="dv">1</span>))</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  (<span class="dv">0</span>, <span class="dv">0</span>)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  lst <span class="kw">in</span> total;;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>foo [<span class="dv">2</span>;<span class="dv">4</span>;<span class="dv">8</span>] ;;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="sp25-2f" value="1" data-correct="true"/> int list -&gt; int, evaluates to 20</label></p><p><label class="quiz-option"><input type="radio" name="sp25-2f" value="2"/> int list -&gt; int, evaluates to 14</label></p><p><label class="quiz-option"><input type="radio" name="sp25-2f" value="3"/> int list -&gt; int, evaluates to 24</label></p><p><label class="quiz-option"><input type="radio" name="sp25-2f" value="4"/> TYPE ERROR</label></p></blockquote></summary><p>Answer: Type is <span class="stt">int list -&gt; int</span>, evaluates to <span class="stt">20</span>. The fold computes a weighted sum: <span class="stt">2*0 + 4*1 + 8*2 = 0 + 4 + 16 = 20</span>.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of <span class="stt">foo</span> and what does <span class="stt">foo (1,3) [1;2;3]</span> evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> foo x y = <span class="kw">match</span> x,y <span class="kw">with</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  x::xs,y::ys -&gt; y :: xs</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  | _ -&gt; [] ;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>foo (<span class="dv">1</span>,<span class="dv">3</span>) [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>] ;;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="sp25-2g" value="1" data-correct="true"/> 'a list -&gt; 'a list -&gt; 'a list, evaluates to Error</label></p><p><label class="quiz-option"><input type="radio" name="sp25-2g" value="2"/> 'a list -&gt; 'a list -&gt; 'a list, evaluates to []</label></p><p><label class="quiz-option"><input type="radio" name="sp25-2g" value="3"/> TYPE ERROR</label></p><p><label class="quiz-option"><input type="radio" name="sp25-2g" value="4"/> 'a list -&gt; 'a list -&gt; 'a list, evaluates to [1]</label></p></blockquote></summary><p>Answer: Type is <span class="stt"></span><span class="stt">&rsquo;</span><span class="stt">a list -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a list -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a list</span>, but the call causes a runtime error. <span class="stt">foo</span> expects two lists, but <span class="stt">(1,3)</span> is a tuple, not a list. The function itself type-checks fine, but the call <span class="stt">foo (1,3) [1;2;3]</span> is a type mismatch at the call site, causing an error.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of <span class="stt">foo</span> and what does <span class="stt">foo [1;3;5]</span> evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> foo lst = <span class="kw">let</span> total, _ =</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  fold_left</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">fun</span> (tot, idx) ele -&gt;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    (tot * ele * idx, idx + <span class="dv">1</span>))</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  (<span class="dv">1</span>, <span class="dv">0</span>)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  lst <span class="kw">in</span> total;;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>foo [<span class="dv">1</span>;<span class="dv">3</span>;<span class="dv">5</span>] ;;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="sp25-2h" value="1" data-correct="true"/> int list -&gt; int, evaluates to 0</label></p><p><label class="quiz-option"><input type="radio" name="sp25-2h" value="2"/> int list -&gt; int, evaluates to 15</label></p><p><label class="quiz-option"><input type="radio" name="sp25-2h" value="3"/> int list -&gt; int, evaluates to 30</label></p><p><label class="quiz-option"><input type="radio" name="sp25-2h" value="4"/> TYPE ERROR</label></p></blockquote></summary><p>Answer: Type is <span class="stt">int list -&gt; int</span>, evaluates to <span class="stt">0</span>. Even though <span class="stt">tot</span> starts at 1, the first iteration multiplies by <span class="stt">idx = 0</span>: <span class="stt">1*1*0 = 0</span>. After that, <span class="stt">tot</span> remains 0: <span class="stt">0*3*1 = 0</span>, <span class="stt">0*5*2 = 0</span>.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of <span class="stt">f</span> and what does <span class="stt">f [4] [[6]]</span> evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f x y = <span class="kw">match</span> x <span class="kw">with</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  [] -&gt; y</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  |x::xs -&gt; [x]::[] ;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>f [<span class="dv">4</span>] [[<span class="dv">6</span>]] ;;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="sp24-2a" value="1" data-correct="true"/> 'a list -&gt; 'a list list -&gt; 'a list list, evaluates to [[4]]</label></p><p><label class="quiz-option"><input type="radio" name="sp24-2a" value="2"/> int list -&gt; int list list -&gt; int list list, evaluates to [[4]]</label></p><p><label class="quiz-option"><input type="radio" name="sp24-2a" value="3"/> 'a list -&gt; 'a list list -&gt; 'a list list, evaluates to [[6]]</label></p><p><label class="quiz-option"><input type="radio" name="sp24-2a" value="4"/> TYPE ERROR</label></p></blockquote></summary><p>Answer: Type is <span class="stt"></span><span class="stt">&rsquo;</span><span class="stt">a list -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a list list -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a list list</span>. The empty case returns <span class="stt">y</span> (a list list), and the non-empty case returns <span class="stt">[x]::[]</span>, which is also a list list. No operations constrain the type, so it&rsquo;s polymorphic. Since <span class="stt">x = [4]</span> is non-empty, <span class="stt">x = 4</span> and we return <span class="stt">[[4]]</span>.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of <span class="stt">f</span> and what does <span class="stt">f 2.0 false</span> evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f a b =</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> b &gt; a <span class="kw">then</span> b</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">else</span> a &lt; <span class="kw">true</span> ;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>f <span class="fl">2.0</span> <span class="kw">false</span>;;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="sp24-2b" value="1" data-correct="true"/> bool -&gt; bool -&gt; bool, evaluates to Error</label></p><p><label class="quiz-option"><input type="radio" name="sp24-2b" value="2"/> float -&gt; bool -&gt; bool, evaluates to false</label></p><p><label class="quiz-option"><input type="radio" name="sp24-2b" value="3"/> bool -&gt; bool -&gt; bool, evaluates to true</label></p><p><label class="quiz-option"><input type="radio" name="sp24-2b" value="4"/> TYPE ERROR</label></p></blockquote></summary><p>Answer: Type is <span class="stt">bool -&gt; bool -&gt; bool</span>. The <span class="stt">then</span> branch returns <span class="stt">b</span> and the <span class="stt">else</span> branch returns <span class="stt">a &lt; true</span>. Since <span class="stt">a &lt; true</span> compares <span class="stt">a</span> with a <span class="stt">bool</span>, <span class="stt">a : bool</span>. Since <span class="stt">b &gt; a</span> compares <span class="stt">b</span> with <span class="stt">a</span>, <span class="stt">b : bool</span>. The call passes <span class="stt">2.0</span> (a <span class="stt">float</span>) for <span class="stt">a</span>, which doesn&rsquo;t match &#8212;<wbr></wbr> Error.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of <span class="stt">f</span> and what does <span class="stt">f [4]</span> evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f x = <span class="kw">match</span> x <span class="kw">with</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  [] -&gt; [[<span class="dv">3</span>]]</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  |x::xs -&gt; [x]::[] ;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>f [<span class="dv">4</span>];;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="sp24-2d" value="1" data-correct="true"/> int list -&gt; int list list, evaluates to [[4]]</label></p><p><label class="quiz-option"><input type="radio" name="sp24-2d" value="2"/> 'a list -&gt; 'a list list, evaluates to [[4]]</label></p><p><label class="quiz-option"><input type="radio" name="sp24-2d" value="3"/> int list -&gt; int list list, evaluates to [[3]]</label></p><p><label class="quiz-option"><input type="radio" name="sp24-2d" value="4"/> TYPE ERROR</label></p></blockquote></summary><p>Answer: Type is <span class="stt">int list -&gt; int list list</span>. The <span class="stt">[[3]]</span> in the empty case constrains the type to <span class="stt">int</span>. Since <span class="stt">x = [4]</span> is non-empty, <span class="stt">x = 4</span> and we return <span class="stt">[[4]]</span>.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of <span class="stt">f</span> and what does <span class="stt">f true false (fun x y -&gt; x &gt; y)</span> evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f a b c =</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> b &gt; a <span class="kw">then</span> c</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">else</span> a &lt; <span class="kw">true</span> ;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>f <span class="kw">true</span> <span class="kw">false</span> (<span class="kw">fun</span> x y -&gt; x &gt; y);;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="sp24-2e" value="1" data-correct="true"/> bool -&gt; bool -&gt; bool -&gt; bool, evaluates to Error</label></p><p><label class="quiz-option"><input type="radio" name="sp24-2e" value="2"/> bool -&gt; bool -&gt; bool -&gt; bool, evaluates to true</label></p><p><label class="quiz-option"><input type="radio" name="sp24-2e" value="3"/> 'a -&gt; 'a -&gt; bool -&gt; bool, evaluates to false</label></p><p><label class="quiz-option"><input type="radio" name="sp24-2e" value="4"/> TYPE ERROR</label></p></blockquote></summary><p>Answer: Type is <span class="stt">bool -&gt; bool -&gt; bool -&gt; bool</span>. <span class="stt">a &lt; true</span> forces <span class="stt">a : bool</span>, <span class="stt">b &gt; a</span> forces <span class="stt">b : bool</span>, and <span class="stt">c</span> must match the return type <span class="stt">bool</span>. The call passes a function <span class="stt">fun x y -&gt; x &gt; y</span> for <span class="stt">c</span>, but <span class="stt">c : bool</span>, so this is a type error at the call site &#8212;<wbr></wbr> Error.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of <span class="stt">f</span> and what does <span class="stt">f [4] [[6]]</span> evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f x y = <span class="kw">match</span> x <span class="kw">with</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  [] -&gt; y</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  |_::xs -&gt; [<span class="dv">2</span>]::[]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  |<span class="dv">4</span>::xs -&gt; [<span class="dv">4</span>]::[];;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>f [<span class="dv">4</span>] [[<span class="dv">6</span>]] ;;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="sp24-2f" value="1" data-correct="true"/> int list -&gt; int list list -&gt; int list list, evaluates to [[2]]</label></p><p><label class="quiz-option"><input type="radio" name="sp24-2f" value="2"/> int list -&gt; int list list -&gt; int list list, evaluates to [[4]]</label></p><p><label class="quiz-option"><input type="radio" name="sp24-2f" value="3"/> 'a list -&gt; 'a list list -&gt; 'a list list, evaluates to [[2]]</label></p><p><label class="quiz-option"><input type="radio" name="sp24-2f" value="4"/> TYPE ERROR</label></p></blockquote></summary><p>Answer: Type is <span class="stt">int list -&gt; int list list -&gt; int list list</span>. The <span class="stt">[2]</span> and <span class="stt">[4]</span> constrain the type to <span class="stt">int</span>. Since <span class="stt">x = [4]</span> is non-empty, it matches the <span class="stt">_::xs</span> pattern first (patterns are tried in order), returning <span class="stt">[[2]]</span>.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of <span class="stt">f</span> and what does <span class="stt">f true 1.3</span> evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f a b =</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> b &gt; a <span class="kw">then</span> (<span class="fl">1.3</span> &lt; <span class="fl">4.6</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">else</span> a &lt; <span class="kw">true</span> ;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>f <span class="kw">true</span> <span class="fl">1.3</span>;;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="sp24-2g" value="1" data-correct="true"/> bool -&gt; bool -&gt; bool, evaluates to Error</label></p><p><label class="quiz-option"><input type="radio" name="sp24-2g" value="2"/> bool -&gt; bool -&gt; bool, evaluates to true</label></p><p><label class="quiz-option"><input type="radio" name="sp24-2g" value="3"/> bool -&gt; float -&gt; bool, evaluates to true</label></p><p><label class="quiz-option"><input type="radio" name="sp24-2g" value="4"/> TYPE ERROR</label></p></blockquote></summary><p>Answer: Type is <span class="stt">bool -&gt; bool -&gt; bool</span>. <span class="stt">a &lt; true</span> forces <span class="stt">a : bool</span>. <span class="stt">b &gt; a</span> forces <span class="stt">b : bool</span>. The <span class="stt">then</span> branch <span class="stt">1.3 &lt; 4.6</span> is a <span class="stt">bool</span> expression that evaluates at function call time. The call passes <span class="stt">1.3</span> (a <span class="stt">float</span>) for <span class="stt">b</span>, which doesn&rsquo;t match &#8212;<wbr></wbr> Error.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of <span class="stt">f</span> and what does <span class="stt">f [(1,2);(3,4)] [[(6,7)]]</span> evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f x y = <span class="kw">match</span> x <span class="kw">with</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  [] -&gt; y</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  |x::xs -&gt; [x]::[] ;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>f [(<span class="dv">1</span>,<span class="dv">2</span>);(<span class="dv">3</span>,<span class="dv">4</span>)] [[(<span class="dv">6</span>,<span class="dv">7</span>)]] ;;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="sp24-2h" value="1" data-correct="true"/> 'a list -&gt; 'a list list -&gt; 'a list list, evaluates to [[(1,2)]]</label></p><p><label class="quiz-option"><input type="radio" name="sp24-2h" value="2"/> (int * int) list -&gt; (int * int) list list -&gt; (int * int) list list, evaluates to [[(1,2)]]</label></p><p><label class="quiz-option"><input type="radio" name="sp24-2h" value="3"/> 'a list -&gt; 'a list list -&gt; 'a list list, evaluates to [[(6,7)]]</label></p><p><label class="quiz-option"><input type="radio" name="sp24-2h" value="4"/> TYPE ERROR</label></p></blockquote></summary><p>Answer: Type is <span class="stt"></span><span class="stt">&rsquo;</span><span class="stt">a list -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a list list -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a list list</span>. Same function as (a) &#8212;<wbr></wbr> no operations constrain the type. Since <span class="stt">x</span> is non-empty, <span class="stt">x = (1,2)</span> and we return <span class="stt">[[(1,2)]]</span>.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of <span class="stt">f</span> and what does <span class="stt">f (fun x -&gt; x &lt; 1) false</span> evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f a b =</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> b &gt; a <span class="kw">then</span> (<span class="st">&quot;hello&quot;</span> &lt; <span class="st">&quot;bye&quot;</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">else</span> a &lt; <span class="kw">true</span> ;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>f (<span class="kw">fun</span> x -&gt; x &lt; <span class="dv">1</span>) <span class="kw">false</span>;;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="sp24-2i" value="1" data-correct="true"/> bool -&gt; bool -&gt; bool, evaluates to Error</label></p><p><label class="quiz-option"><input type="radio" name="sp24-2i" value="2"/> bool -&gt; bool -&gt; bool, evaluates to true</label></p><p><label class="quiz-option"><input type="radio" name="sp24-2i" value="3"/> (int -&gt; bool) -&gt; bool -&gt; bool, evaluates to false</label></p><p><label class="quiz-option"><input type="radio" name="sp24-2i" value="4"/> TYPE ERROR</label></p></blockquote></summary><p>Answer: Type is <span class="stt">bool -&gt; bool -&gt; bool</span>. <span class="stt">a &lt; true</span> forces <span class="stt">a : bool</span>, <span class="stt">b &gt; a</span> forces <span class="stt">b : bool</span>. The <span class="stt">then</span> branch <span class="stt">"hello" &lt; "bye"</span> is a <span class="stt">bool</span> expression. The call passes a function <span class="stt">fun x -&gt; x &lt; 1</span> for <span class="stt">a</span>, which doesn&rsquo;t match <span class="stt">bool</span> &#8212;<wbr></wbr> Error.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of <span class="stt">f</span> and what does <span class="stt">f [] [1;2;3]</span> evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f x y = <span class="kw">match</span> x <span class="kw">with</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  [] -&gt; []</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  |x::xs -&gt; y :: xs ;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>f [] [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>] ;;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="f24-2a" value="1" data-correct="true"/> 'a list -&gt; 'a -&gt; 'a list, evaluates to []</label></p><p><label class="quiz-option"><input type="radio" name="f24-2a" value="2"/> 'a list -&gt; 'a list -&gt; 'a list, evaluates to []</label></p><p><label class="quiz-option"><input type="radio" name="f24-2a" value="3"/> 'a list -&gt; 'a -&gt; 'a list, evaluates to [1;2;3]</label></p><p><label class="quiz-option"><input type="radio" name="f24-2a" value="4"/> TYPE ERROR</label></p></blockquote></summary><p>Answer: Type is <span class="stt"></span><span class="stt">&rsquo;</span><span class="stt">a list -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a list</span>. <span class="stt">x</span> is matched as a list and <span class="stt">y</span> is consed onto <span class="stt">xs</span>, so <span class="stt">y</span> is an element (not a list). No operations force a specific type, so it&rsquo;s polymorphic. Since <span class="stt">x = []</span>, the first branch matches and returns <span class="stt">[]</span>.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of <span class="stt">f</span> and what does <span class="stt">f [] [1;2;3]</span> evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f x y = <span class="kw">match</span> x <span class="kw">with</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  [] -&gt; [<span class="dv">1</span>]</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  |x::xs -&gt; y :: xs ;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>f [] [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>] ;;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="f24-2b" value="1" data-correct="true"/> int list -&gt; int -&gt; int list, evaluates to Error</label></p><p><label class="quiz-option"><input type="radio" name="f24-2b" value="2"/> int list -&gt; int -&gt; int list, evaluates to [1]</label></p><p><label class="quiz-option"><input type="radio" name="f24-2b" value="3"/> 'a list -&gt; 'a -&gt; 'a list, evaluates to [1]</label></p><p><label class="quiz-option"><input type="radio" name="f24-2b" value="4"/> TYPE ERROR</label></p></blockquote></summary><p>Answer: Type is <span class="stt">int list -&gt; int -&gt; int list</span>. The <span class="stt">[1]</span> in the first branch constrains the type to <span class="stt">int list</span>. The call <span class="stt">f [] [1;2;3]</span> passes a list <span class="stt">[1;2;3]</span> as <span class="stt">y</span>, but <span class="stt">y</span> has type <span class="stt">int</span>, so this is a type error at the call site &#8212;<wbr></wbr> the function type-checks but the call causes an error.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of <span class="stt">f</span> and what does <span class="stt">f [1] [1;2;3]</span> evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f x y = <span class="kw">match</span> x <span class="kw">with</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  [] -&gt; [<span class="dv">14</span>]</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  |x::xs -&gt; y :: xs ;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>f [<span class="dv">1</span>] [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>] ;;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="f24-2c" value="1" data-correct="true"/> int list -&gt; int -&gt; int list, evaluates to Error</label></p><p><label class="quiz-option"><input type="radio" name="f24-2c" value="2"/> int list -&gt; int -&gt; int list, evaluates to [1;2;3]</label></p><p><label class="quiz-option"><input type="radio" name="f24-2c" value="3"/> int list -&gt; int -&gt; int list, evaluates to [14]</label></p><p><label class="quiz-option"><input type="radio" name="f24-2c" value="4"/> TYPE ERROR</label></p></blockquote></summary><p>Answer: Type is <span class="stt">int list -&gt; int -&gt; int list</span>. The <span class="stt">[14]</span> constrains types to <span class="stt">int</span>. The call passes <span class="stt">[1;2;3]</span> (a list) as <span class="stt">y</span>, but <span class="stt">y</span> should be <span class="stt">int</span>, so this is an error at the call site.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of <span class="stt">f</span> and what does <span class="stt">f 2.0 false</span> evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f a b =</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> b &lt;&gt; <span class="kw">false</span> <span class="kw">then</span> <span class="fl">1.0</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">else</span> a + <span class="fl">2.0</span> ;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>f <span class="fl">2.0</span> <span class="kw">false</span>;;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="f24-2e" value="1" data-correct="true"/> TYPE ERROR</label></p><p><label class="quiz-option"><input type="radio" name="f24-2e" value="2"/> float -&gt; bool -&gt; float, evaluates to 4.0</label></p><p><label class="quiz-option"><input type="radio" name="f24-2e" value="3"/> float -&gt; bool -&gt; float, evaluates to 1.0</label></p><p><label class="quiz-option"><input type="radio" name="f24-2e" value="4"/> float -&gt; bool -&gt; float, evaluates to Error</label></p></blockquote></summary><p>Answer: TYPE ERROR. The expression <span class="stt">a + 2.0</span> tries to use the integer addition operator <span class="stt">+</span> with a float. In OCaml, you must use <span class="stt">+.</span> for float addition.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of <span class="stt">f</span> and what does <span class="stt">f 2 "true"</span> evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f a b =</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> b = <span class="st">&quot;false&quot;</span> <span class="kw">then</span> <span class="dv">1</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">else</span> a + <span class="dv">2</span> ;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>f <span class="dv">2</span> <span class="st">&quot;true&quot;</span>;;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="f24-2f" value="1" data-correct="true"/> int -&gt; string -&gt; int, evaluates to 4</label></p><p><label class="quiz-option"><input type="radio" name="f24-2f" value="2"/> int -&gt; string -&gt; int, evaluates to 1</label></p><p><label class="quiz-option"><input type="radio" name="f24-2f" value="3"/> int -&gt; bool -&gt; int, evaluates to 4</label></p><p><label class="quiz-option"><input type="radio" name="f24-2f" value="4"/> TYPE ERROR</label></p></blockquote></summary><p>Answer: Type is <span class="stt">int -&gt; string -&gt; int</span>. <span class="stt">a</span> is added to <span class="stt">2</span> so it&rsquo;s <span class="stt">int</span>, and <span class="stt">b</span> is compared to the string <span class="stt">"false"</span> so it&rsquo;s <span class="stt">string</span>. Since <span class="stt">b = "true"</span> which is not <span class="stt">"false"</span>, the else branch runs: <span class="stt">2 + 2 = 4</span>.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of <span class="stt">f</span> and what does <span class="stt">f 2.0 false</span> evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f a b =</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> b &gt; <span class="dv">5</span> <span class="kw">then</span> a</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">else</span> <span class="kw">true</span> ;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>f <span class="fl">2.0</span> <span class="kw">false</span>;;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="f24-2g" value="1" data-correct="true"/> bool -&gt; int -&gt; bool, evaluates to Error</label></p><p><label class="quiz-option"><input type="radio" name="f24-2g" value="2"/> bool -&gt; int -&gt; bool, evaluates to true</label></p><p><label class="quiz-option"><input type="radio" name="f24-2g" value="3"/> float -&gt; int -&gt; float, evaluates to true</label></p><p><label class="quiz-option"><input type="radio" name="f24-2g" value="4"/> TYPE ERROR</label></p></blockquote></summary><p>Answer: Type is <span class="stt">bool -&gt; int -&gt; bool</span>. <span class="stt">a</span> must match the type of <span class="stt">true</span>, so <span class="stt">a : bool</span>. <span class="stt">b</span> is compared to <span class="stt">5</span>, so <span class="stt">b : int</span>. The call <span class="stt">f 2.0 false</span> passes a <span class="stt">float</span> for <span class="stt">a</span> and a <span class="stt">bool</span> for <span class="stt">b</span>, both wrong types &#8212;<wbr></wbr> runtime error.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of <span class="stt">f</span> and what does <span class="stt">f 2.0 false</span> evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f a b =</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> b &gt; <span class="kw">false</span> <span class="kw">then</span> a</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">else</span> <span class="fl">2.3</span> ;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>f <span class="fl">2.0</span> <span class="kw">false</span>;;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="f24-2h" value="1" data-correct="true"/> float -&gt; bool -&gt; float, evaluates to 2.3</label></p><p><label class="quiz-option"><input type="radio" name="f24-2h" value="2"/> float -&gt; bool -&gt; float, evaluates to 2.0</label></p><p><label class="quiz-option"><input type="radio" name="f24-2h" value="3"/> 'a -&gt; bool -&gt; float, evaluates to 2.3</label></p><p><label class="quiz-option"><input type="radio" name="f24-2h" value="4"/> TYPE ERROR</label></p></blockquote></summary><p>Answer: Type is <span class="stt">float -&gt; bool -&gt; float</span>. <span class="stt">a</span> must match the type of <span class="stt">2.3</span>, so <span class="stt">a : float</span>. <span class="stt">b</span> is compared to <span class="stt">false</span>, so <span class="stt">b : bool</span>. Since <span class="stt">false &gt; false</span> is <span class="stt">false</span>, the else branch runs, returning <span class="stt">2.3</span>.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of <span class="stt">f</span> and what does <span class="stt">f (fun x -&gt; x mod 2 = 1) [1;2;3]</span> evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> f g lst = <span class="kw">match</span> lst <span class="kw">with</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  [] -&gt; []</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  |x::xs -&gt; (x, g x)::(f g xs) ;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>f (<span class="kw">fun</span> x -&gt; x <span class="kw">mod</span> <span class="dv">2</span> = <span class="dv">1</span>) [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>] ;;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="f24-2i" value="1" data-correct="true"/> ('a -&gt; 'b) -&gt; 'a list -&gt; ('a * 'b) list, evaluates to [(1,true);(2,false);(3,true)]</label></p><p><label class="quiz-option"><input type="radio" name="f24-2i" value="2"/> ('a -&gt; 'b) -&gt; 'a list -&gt; ('b * 'a) list, evaluates to [(true,1);(false,2);(true,3)]</label></p><p><label class="quiz-option"><input type="radio" name="f24-2i" value="3"/> (int -&gt; bool) -&gt; int list -&gt; (int * bool) list, evaluates to [(1,true);(2,false);(3,true)]</label></p><p><label class="quiz-option"><input type="radio" name="f24-2i" value="4"/> TYPE ERROR</label></p></blockquote></summary><p>Answer: Type is <span class="stt">(</span><span class="stt">&rsquo;</span><span class="stt">a -&gt; </span><span class="stt">&rsquo;</span><span class="stt">b) -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a list -&gt; (</span><span class="stt">&rsquo;</span><span class="stt">a * </span><span class="stt">&rsquo;</span><span class="stt">b) list</span>. The function pairs each element <span class="stt">x</span> with <span class="stt">g x</span>. With <span class="stt">g = fun x -&gt; x mod 2 = 1</span>, each element is paired with whether it&rsquo;s odd.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of <span class="stt">f</span> and what does <span class="stt">f (fun x -&gt; x mod 2 = 0) [1;2;3]</span> evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> f g lst = <span class="kw">match</span> lst <span class="kw">with</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  [] -&gt; []</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  |x::xs -&gt; (g x, x)::(f g xs) ;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>f (<span class="kw">fun</span> x -&gt; x <span class="kw">mod</span> <span class="dv">2</span> = <span class="dv">0</span>) [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>] ;;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="f24-2j" value="1" data-correct="true"/> ('a -&gt; 'b) -&gt; 'a list -&gt; ('b * 'a) list, evaluates to [(false,1);(true,2);(false,3)]</label></p><p><label class="quiz-option"><input type="radio" name="f24-2j" value="2"/> ('a -&gt; 'b) -&gt; 'a list -&gt; ('a * 'b) list, evaluates to [(1,false);(2,true);(3,false)]</label></p><p><label class="quiz-option"><input type="radio" name="f24-2j" value="3"/> (int -&gt; bool) -&gt; int list -&gt; (bool * int) list, evaluates to [(false,1);(true,2);(false,3)]</label></p><p><label class="quiz-option"><input type="radio" name="f24-2j" value="4"/> TYPE ERROR</label></p></blockquote></summary><p>Answer: Type is <span class="stt">(</span><span class="stt">&rsquo;</span><span class="stt">a -&gt; </span><span class="stt">&rsquo;</span><span class="stt">b) -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a list -&gt; (</span><span class="stt">&rsquo;</span><span class="stt">b * </span><span class="stt">&rsquo;</span><span class="stt">a) list</span>. Note the tuple order is <span class="stt">(g x, x)</span>, so <span class="stt">g</span>&rsquo;s result comes first. Each element is paired with whether it&rsquo;s even.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of <span class="stt">f</span> and what does <span class="stt">f (fun x -&gt; x +. 2.0) [1.0;2.0;3.0]</span> evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> f g lst = <span class="kw">match</span> lst <span class="kw">with</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  [] -&gt; []</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  |x::xs -&gt; (g x, x)::(f g xs) ;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>f (<span class="kw">fun</span> x -&gt; x +. <span class="fl">2.0</span>) [<span class="fl">1.0</span>;<span class="fl">2.0</span>;<span class="fl">3.0</span>];;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="f24-2k" value="1" data-correct="true"/> ('a -&gt; 'b) -&gt; 'a list -&gt; ('b * 'a) list, evaluates to [(3.,1.);(4.,2.);(5.,3.)]</label></p><p><label class="quiz-option"><input type="radio" name="f24-2k" value="2"/> (float -&gt; float) -&gt; float list -&gt; (float * float) list, evaluates to [(3.,1.);(4.,2.);(5.,3.)]</label></p><p><label class="quiz-option"><input type="radio" name="f24-2k" value="3"/> ('a -&gt; 'b) -&gt; 'a list -&gt; ('a * 'b) list, evaluates to [(1.,3.);(2.,4.);(3.,5.)]</label></p><p><label class="quiz-option"><input type="radio" name="f24-2k" value="4"/> TYPE ERROR</label></p></blockquote></summary><p>Answer: Type is <span class="stt">(</span><span class="stt">&rsquo;</span><span class="stt">a -&gt; </span><span class="stt">&rsquo;</span><span class="stt">b) -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a list -&gt; (</span><span class="stt">&rsquo;</span><span class="stt">b * </span><span class="stt">&rsquo;</span><span class="stt">a) list</span>. The tuple order is <span class="stt">(g x, x)</span>. Each float has 2.0 added, and the result comes first in the pair.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of <span class="stt">f</span> and what does <span class="stt">f (fun x -&gt; x *. 2.0) [1.0;2.0;3.0]</span> evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> f g lst = <span class="kw">match</span> lst <span class="kw">with</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  [] -&gt; []</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  |x::xs -&gt; (x, g x)::(f g xs) ;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>f (<span class="kw">fun</span> x -&gt; x *. <span class="fl">2.0</span>) [<span class="fl">1.0</span>;<span class="fl">2.0</span>;<span class="fl">3.0</span>];;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="f24-2l" value="1" data-correct="true"/> ('a -&gt; 'b) -&gt; 'a list -&gt; ('a * 'b) list, evaluates to [(1.,2.);(2.,4.);(3.,6.)]</label></p><p><label class="quiz-option"><input type="radio" name="f24-2l" value="2"/> ('a -&gt; 'b) -&gt; 'a list -&gt; ('b * 'a) list, evaluates to [(2.,1.);(4.,2.);(6.,3.)]</label></p><p><label class="quiz-option"><input type="radio" name="f24-2l" value="3"/> (float -&gt; float) -&gt; float list -&gt; (float * float) list, evaluates to [(1.,2.);(2.,4.);(3.,6.)]</label></p><p><label class="quiz-option"><input type="radio" name="f24-2l" value="4"/> TYPE ERROR</label></p></blockquote></summary><p>Answer: Type is <span class="stt">(</span><span class="stt">&rsquo;</span><span class="stt">a -&gt; </span><span class="stt">&rsquo;</span><span class="stt">b) -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a list -&gt; (</span><span class="stt">&rsquo;</span><span class="stt">a * </span><span class="stt">&rsquo;</span><span class="stt">b) list</span>. The tuple order is <span class="stt">(x, g x)</span>. Each float is doubled by <span class="stt">g</span>, and the original comes first in the pair.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of <span class="stt">foo</span> and what does <span class="stt">foo [1;2;3;4;5]</span> evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> foo lst =</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> lst <span class="kw">with</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  h1::h2::t -&gt; h2 :: h1 :: foo t</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  | _ -&gt; lst;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>foo [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>;<span class="dv">4</span>;<span class="dv">5</span>];;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="q2a" value="1" data-correct="true"/> 'a list -&gt; 'a list, evaluates to [2;1;4;3;5]</label></p><p><label class="quiz-option"><input type="radio" name="q2a" value="2"/> 'a list -&gt; 'a list, evaluates to [1;2;3;4;5]</label></p><p><label class="quiz-option"><input type="radio" name="q2a" value="3"/> int list -&gt; int list, evaluates to [2;1;4;3;5]</label></p><p><label class="quiz-option"><input type="radio" name="q2a" value="4"/> TYPE ERROR</label></p></blockquote></summary><p>Answer: Type is <span class="stt"></span><span class="stt">&rsquo;</span><span class="stt">a list -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a list</span>. It swaps adjacent pairs of elements. <span class="stt">foo [1;2;3;4;5]</span> evaluates to <span class="stt">[2;1;4;3;5]</span>. The first pair <span class="stt">1,2</span> becomes <span class="stt">2,1</span>, the second pair <span class="stt">3,4</span> becomes <span class="stt">4,3</span>, and <span class="stt">5</span> is left as-is by the wildcard case.</p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="quiz-container"><p>What is the type of <span class="stt">foo</span> and what does the call evaluate to?</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> foo f x = f (f x);;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>foo (<span class="kw">fun</span> x -&gt; [<span class="dt">List</span>.length x]) [<span class="dv">3</span>;<span class="dv">6</span>;<span class="dv">9</span>];;</span></code></pre></div>
</div></p><p><label class="quiz-option"><input type="radio" name="q2b" value="1" data-correct="true"/> ('a -&gt; 'a) -&gt; 'a -&gt; 'a, evaluates to [1]</label></p><p><label class="quiz-option"><input type="radio" name="q2b" value="2"/> ('a -&gt; 'b) -&gt; 'a -&gt; 'b, evaluates to [1]</label></p><p><label class="quiz-option"><input type="radio" name="q2b" value="3"/> ('a -&gt; 'a) -&gt; 'a -&gt; 'a, evaluates to ERROR</label></p><p><label class="quiz-option"><input type="radio" name="q2b" value="4"/> TYPE ERROR</label></p></blockquote></summary><p>Answer: Type of <span class="stt">foo</span> is <span class="stt">(</span><span class="stt">&rsquo;</span><span class="stt">a -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a) -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a</span>. Since <span class="stt">f (f x)</span> requires the output type of <span class="stt">f</span> to match its input type. Here <span class="stt">f = fun x -&gt; [List.length x]</span> has type <span class="stt">int list -&gt; int list</span> (unifying <span class="stt"></span><span class="stt">&rsquo;</span><span class="stt">a = int</span>). So <span class="stt">f [3;6;9] = [3]</span>, then <span class="stt">f [3] = [1]</span>. The result is <span class="stt">[1]</span>.</p></details></details><details class="SubFlow accordion-section"><summary><span style="font-weight: bold">Write an Expression</span></summary><details class="SubFlow"><summary class="SubFlow"><blockquote class="SubFlow"><p>Write an expression that would have the type <span class="stt">int list -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a -&gt; bool</span>.</p></blockquote></summary><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> x y z -&gt; <span class="kw">match</span> x <span class="kw">with</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  |h::t -&gt; (<span class="kw">if</span> h = <span class="dv">0</span> <span class="kw">then</span> y = z <span class="kw">else</span> <span class="kw">false</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  |[] -&gt; <span class="kw">true</span></span></code></pre></div>
</div></p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="SubFlow"><p>Write an expression that would have the type <span class="stt">(int -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a) -&gt; int -&gt; int * </span><span class="stt">&rsquo;</span><span class="stt">a list</span>.</p></blockquote></summary><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> f a -&gt; (a + <span class="dv">1</span>, [f a])</span></code></pre></div>
</div></p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="SubFlow"><p>Write an expression that would have the type <span class="stt">(</span><span class="stt">&rsquo;</span><span class="stt">a -&gt; </span><span class="stt">&rsquo;</span><span class="stt">b) -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a -&gt; </span><span class="stt">&rsquo;</span><span class="stt">b -&gt; bool</span>.</p></blockquote></summary><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> x y z -&gt; (x y) = z</span></code></pre></div>
</div></p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="SubFlow"><p>Write an expression that would have the type <span class="stt">float -&gt; float -&gt; bool -&gt; float list</span>.</p></blockquote></summary><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> x y z -&gt; <span class="kw">if</span> z <span class="kw">then</span> [x +. <span class="fl">1.0</span>] <span class="kw">else</span> [y]</span></code></pre></div>
</div></p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="SubFlow"><p>Write an expression that would have the type <span class="stt">(int * </span><span class="stt">&rsquo;</span><span class="stt">a) -&gt; (bool -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a) -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a</span>.</p></blockquote></summary><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> (a, b) c -&gt; <span class="kw">if</span> a + <span class="dv">1</span> = <span class="dv">2</span> <span class="kw">then</span> b <span class="kw">else</span> c <span class="kw">true</span></span></code></pre></div>
</div></p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="SubFlow"><p>Write an expression that would have the type <span class="stt">int list -&gt; int -&gt; bool list</span>.</p></blockquote></summary><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> x y -&gt; <span class="kw">match</span> x <span class="kw">with</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  |h::t -&gt; [h + <span class="dv">1</span> = y]</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  |[] -&gt; [<span class="kw">false</span>]</span></code></pre></div>
</div></p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="SubFlow"><p>Write an expression that would have the type <span class="stt"></span><span class="stt">&rsquo;</span><span class="stt">a -&gt; </span><span class="stt">&rsquo;</span><span class="stt">b list -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a * </span><span class="stt">&rsquo;</span><span class="stt">a</span>.</p></blockquote></summary><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> x y z -&gt; <span class="kw">if</span> y = [] &amp;&amp; x = z <span class="kw">then</span> (x, z) <span class="kw">else</span> (x, z)</span></code></pre></div>
</div></p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="SubFlow"><p>Write an expression that would have the type <span class="stt"></span><span class="stt">&rsquo;</span><span class="stt">a -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a -&gt; bool list</span>.</p></blockquote></summary><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> a b -&gt; [a = b]</span></code></pre></div>
</div></p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="SubFlow"><p>Write an expression that would have the type <span class="stt">(</span><span class="stt">&rsquo;</span><span class="stt">a -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a) -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a -&gt; int</span>.</p></blockquote></summary><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> f a -&gt; <span class="kw">if</span> (f a) = a <span class="kw">then</span> <span class="dv">3</span> <span class="kw">else</span> <span class="dv">5</span></span></code></pre></div>
</div></p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="SubFlow"><p>Write an expression that would have the type <span class="stt">float -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a -&gt; (</span><span class="stt">&rsquo;</span><span class="stt">a * float)</span>.</p></blockquote></summary><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> a b -&gt; (b, a +. <span class="dv">2</span>.)</span></code></pre></div>
</div></p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="SubFlow"><p>Write an expression that would have the type <span class="stt">string -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a -&gt; (</span><span class="stt">&rsquo;</span><span class="stt">a * float * </span><span class="stt">&rsquo;</span><span class="stt">a)</span>.</p></blockquote></summary><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> s a -&gt; (a, (<span class="dt">float_of_string</span> s), a)</span></code></pre></div>
</div></p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="SubFlow"><p>Write an expression that would have the type <span class="stt">bool -&gt; int -&gt; (bool * int) list</span>.</p></blockquote></summary><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> b i -&gt; [b &gt; <span class="kw">true</span>, i + <span class="dv">3</span>]</span></code></pre></div>
</div></p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="SubFlow"><p>Write an expression that would have the type <span class="stt">(int -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a) -&gt; </span><span class="stt">&rsquo;</span><span class="stt">b -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a</span>.</p></blockquote></summary><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> f a -&gt; f <span class="dv">3</span></span></code></pre></div>
</div></p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="SubFlow"><p>Write an expression that would have the type <span class="stt">(</span><span class="stt">&rsquo;</span><span class="stt">a -&gt; </span><span class="stt">&rsquo;</span><span class="stt">b) -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a -&gt; </span><span class="stt">&rsquo;</span><span class="stt">b</span>.</p></blockquote></summary><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> f b -&gt; f b</span></code></pre></div>
</div></p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="SubFlow"><p>Write an expression that would have the type <span class="stt">(</span><span class="stt">&rsquo;</span><span class="stt">a -&gt; </span><span class="stt">&rsquo;</span><span class="stt">b -&gt; </span><span class="stt">&rsquo;</span><span class="stt">c) -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a -&gt; </span><span class="stt">&rsquo;</span><span class="stt">b -&gt; </span><span class="stt">&rsquo;</span><span class="stt">c</span>.</p></blockquote></summary><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> f a b -&gt; f a b</span></code></pre></div>
</div></p></details></details><details class="SubFlow accordion-section"><summary><span style="font-weight: bold">Coding</span></summary><details class="SubFlow"><summary class="SubFlow"><blockquote class="SubFlow"><p>Define a function <span style="font-weight: bold">fold_if</span> that behaves like <span class="stt">fold_left</span>,
but takes an additional predicate argument <span style="font-weight: bold">pred : &rsquo;acc -&gt; &rsquo;a -&gt; bool</span>.
During the fold, before applying the function to the current element,
<span style="font-weight: bold">pred</span> is checked with the current accumulator and the current element.
If <span style="font-weight: bold">pred</span> evaluates to false, the fold stops
and returns the current accumulator.</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* stop when we encounter an element &gt; 10 *)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="dt">pred</span> _acc x = x &lt;= <span class="dv">10</span> <span class="kw">in</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f acc x = acc + x <span class="kw">in</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>fold_if <span class="dt">pred</span> f <span class="dv">0</span> [<span class="dv">1</span>;<span class="dv">4</span>;<span class="dv">6</span>;<span class="dv">11</span>;<span class="dv">2</span>]</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co">(* returns 11 (1+4+6), stops at 11 *)</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co">(* stop once acc &gt;= 10 *)</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> pred_sum acc _x = acc &lt; <span class="dv">10</span> <span class="kw">in</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f acc x = acc + x <span class="kw">in</span> fold_if pred_sum f <span class="dv">0</span> [<span class="dv">3</span>;<span class="dv">4</span>;<span class="dv">5</span>;<span class="dv">1</span>]</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="co">(* returns 12 (3+4+5), stops before processing 1 *)</span></span></code></pre></div>
</div></p></blockquote></summary><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> fold_if <span class="dt">pred</span> f init lst =</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">match</span> lst <span class="kw">with</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  | [] -&gt; init</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  | x :: xs -&gt;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> <span class="dt">pred</span> init x <span class="kw">then</span> fold_if <span class="dt">pred</span> f (f init x) xs</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> init</span></code></pre></div>
</div></p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="SubFlow"><p><span class="stt">filter</span> is a common higher order function that has type <span class="stt">(</span><span class="stt">&rsquo;</span><span class="stt">a -&gt; bool) -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a list -&gt; </span><span class="stt">&rsquo;</span><span class="stt">a list</span>. It applies
a function to every item in a list and returns a list of the items that caused the function to return true. <span style="font-weight: bold">Using only fold</span>
(left or right), write a function called <span class="stt">my_filter</span> which has the same functionality as <span class="stt">filter</span>. <span class="stt">f</span> will be the
function that returns true or false, and <span class="stt">l</span> will be the list. Note: the original order must be maintained.</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* example: my_filter (fun x -&gt; x &gt; 3) [2;4;6] = [4;6] *)</span></span></code></pre></div>
</div></p></blockquote></summary><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* Using fold_right *)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> my_filter f l =</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  fold_right (<span class="kw">fun</span> x acc -&gt; <span class="kw">if</span> f x <span class="kw">then</span> x :: acc <span class="kw">else</span> acc) l []</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co">(* Alternatively, using fold_left *)</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> my_filter f l =</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  fold_left (<span class="kw">fun</span> acc x -&gt; <span class="kw">if</span> f x <span class="kw">then</span> acc @ [x] <span class="kw">else</span> acc) [] l</span></code></pre></div>
</div></p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="SubFlow"><p>Write a function <span class="stt">last_sum</span> which takes in a <span class="stt">int list list</span> and returns the sum of the last elements in each <span class="stt">int list</span>. If a list is empty, it adds nothing to the total.</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* last_sum has type int list list -&gt; int *)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">(* Examples:</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">   last_sum [] = 0</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co">   last_sum [[1;2;3];[4;5;6];[7;8;9]] = 18  (* 3 + 6 + 9 *)</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co">   last_sum [[];[1];[2;3]] = 4               (* 0 + 1 + 3 *)</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co">*)</span></span></code></pre></div>
</div></p></blockquote></summary><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* Using map and fold_left *)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> last_sum mtx =</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> lasts = map (<span class="kw">fun</span> x -&gt; fold_left (<span class="kw">fun</span> acc el -&gt; el) <span class="dv">0</span> x) mtx <span class="kw">in</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  fold_left (+) <span class="dv">0</span> lasts</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co">(* Alternatively, using only fold_left *)</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> last_sum mtx =</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  fold_left (<span class="kw">fun</span> a x -&gt; a + (fold_left (<span class="kw">fun</span> a x -&gt; x) <span class="dv">0</span> x)) <span class="dv">0</span> mtx</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="co">(* Alternatively, with a helper function *)</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> get_last lst = <span class="kw">match</span> lst <span class="kw">with</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>  | [] -&gt; <span class="dv">0</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>  | [x] -&gt; x</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>  | _ :: xs -&gt; get_last xs</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> last_sum mtx =</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> lasts = map (<span class="kw">fun</span> x -&gt; get_last x) mtx <span class="kw">in</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>  fold_left (+) <span class="dv">0</span> lasts</span></code></pre></div>
</div></p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="SubFlow"><p>Write a function <span class="stt">last_prod</span> which takes in a <span class="stt">int list list</span> and returns the product of the last elements in each <span class="stt">int list</span>. If a list is empty, it multiplies the value by 1.</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* last_prod has type int list list -&gt; int *)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">(* Examples:</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">   last_prod [] = 1</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co">   last_prod [[1;2;3];[4;5;6];[7;8;9]] = 162  (* 3 * 6 * 9 *)</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co">   last_prod [[];[1];[2;3]] = 3                (* 1 * 1 * 3 *)</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co">*)</span></span></code></pre></div>
</div></p></blockquote></summary><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* Using map and fold_left *)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> last_prod mtx =</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> lasts = map (<span class="kw">fun</span> x -&gt; fold_left (<span class="kw">fun</span> acc el -&gt; el) <span class="dv">1</span> x) mtx <span class="kw">in</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  fold_left ( * ) <span class="dv">1</span> lasts</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co">(* Alternatively, using only fold_left *)</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> last_prod mtx =</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  fold_left (<span class="kw">fun</span> a x -&gt; a * (fold_left (<span class="kw">fun</span> a x -&gt; x) <span class="dv">1</span> x)) <span class="dv">1</span> mtx</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="co">(* Alternatively, with a helper function *)</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> get_last lst = <span class="kw">match</span> lst <span class="kw">with</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>  | [] -&gt; <span class="dv">1</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>  | [x] -&gt; x</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>  | _ :: xs -&gt; get_last xs</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> last_prod mtx =</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> lasts = map (<span class="kw">fun</span> x -&gt; get_last x) mtx <span class="kw">in</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>  fold_left ( * ) <span class="dv">1</span> lasts</span></code></pre></div>
</div></p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="SubFlow"><p>Write a function <span class="stt">last_concat</span> which takes in a <span class="stt">string list list</span> and returns the result of concatenating the last elements in each <span class="stt">string list</span>. If a list is empty, it should not modify the resulting string.</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* last_concat has type string list list -&gt; string *)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">(* Examples:</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">   last_concat [] = &quot;&quot;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co">   last_concat [[&quot;a&quot;;&quot;b&quot;];[&quot;c&quot;;&quot;d&quot;];[&quot;e&quot;;&quot;f&quot;]] = &quot;bdf&quot;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co">   last_concat [[];[&quot;a&quot;];[&quot;b&quot;;&quot;c&quot;]] = &quot;ac&quot;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co">*)</span></span></code></pre></div>
</div></p></blockquote></summary><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* Using map and fold_right *)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> last_concat mtx =</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> lasts = map (<span class="kw">fun</span> x -&gt; fold_left (<span class="kw">fun</span> acc el -&gt; el) <span class="st">&quot;&quot;</span> x) mtx <span class="kw">in</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  fold_right ( ^ ) lasts <span class="st">&quot;&quot;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co">(* Alternatively, with a helper function *)</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> get_last lst = <span class="kw">match</span> lst <span class="kw">with</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  | [] -&gt; <span class="st">&quot;&quot;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  | [x] -&gt; x</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  | _ :: xs -&gt; get_last xs</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> last_concat mtx =</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> lasts = map (<span class="kw">fun</span> x -&gt; get_last x) mtx <span class="kw">in</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>  fold_right ( ^ ) lasts <span class="st">&quot;&quot;</span></span></code></pre></div>
</div></p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="SubFlow"><p>Write a function <span class="stt">encode</span> that takes a <span class="stt">int list</span> and returns a <span class="stt">string list</span>, which consists of the string <span class="stt">"1"</span> repeated by each number in the <span class="stt">int list</span>. You may assume that all values in the input list are &gt;= 0.</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* Examples:</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">   encode [0;1;2;3] = [&quot;&quot;;&quot;1&quot;;&quot;11&quot;;&quot;111&quot;]</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">   encode [0;0;3] = [&quot;&quot;;&quot;&quot;;&quot;111&quot;]</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co">*)</span></span></code></pre></div>
</div></p></blockquote></summary><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> encode lst =</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="kw">rec</span> repeat n =</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> n = <span class="dv">0</span> <span class="kw">then</span> <span class="st">&quot;&quot;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> <span class="st">&quot;1&quot;</span> ^ repeat (n - <span class="dv">1</span>) <span class="kw">in</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  map repeat lst</span></code></pre></div>
</div></p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="SubFlow"><p>Write a function <span class="stt">calc</span> that takes a <span class="stt">(int * bool) list</span> and returns a <span class="stt">(int * bool)</span>, which consists of the sum of the ints and the result of AND&rsquo;ing the bools.</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* Examples:</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">   calc [(1,true); (2,false)] = (3,false)</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">   calc [(3,true); (4,true)] = (7,true)</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co">*)</span></span></code></pre></div>
</div></p></blockquote></summary><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* Recursive version *)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> calc lst = <span class="kw">match</span> lst <span class="kw">with</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  | [] -&gt; (<span class="dv">0</span>, <span class="kw">true</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  | (i, b) :: xs -&gt;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> (s, a) = calc xs <span class="kw">in</span> (s + i, b &amp;&amp; a)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co">(* Fold version *)</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> calc lst =</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  fold (<span class="kw">fun</span> (a, b) (c, d) -&gt; (a + c, b &amp;&amp; d)) (<span class="dv">0</span>, <span class="kw">true</span>) lst</span></code></pre></div>
</div></p></details><details class="SubFlow"><summary class="SubFlow"><blockquote class="SubFlow"><p>Using either <span class="stt">map</span> or <span class="stt">fold</span> and an anonymous function, write a curried function called <span class="stt">divisible</span> which, given a number <span class="stt">n</span> and a list of ints <span class="stt">lst</span>, returns a list of all elements of <span class="stt">lst</span> that are divisible by <span class="stt">n</span> (maintaining their relative ordering). You are allowed to use <span class="stt">List.rev</span> (reverses a list) and the (curried) <span class="stt">map</span> and <span class="stt">fold</span> functions provided, but no other OCaml library functions. Hint: <span class="stt">x</span> is divisible by <span class="stt">y</span> iff <span class="stt">(x mod y = 0)</span> is true.</p><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* divisible has type int -&gt; int list -&gt; int list *)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">(* Examples:</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">   divisible 4 [3;16;24] = [16; 24]</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co">   divisible 3 [4;1;11] = []</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co">   divisible 3 [] = []</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co">*)</span></span></code></pre></div>
</div></p></blockquote></summary><p><div class='fancy-box'><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> divisible v lst = <span class="dt">List</span>.rev</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  (fold (<span class="kw">fun</span> a h -&gt; <span class="kw">if</span> (h <span class="kw">mod</span> v = <span class="dv">0</span>) <span class="kw">then</span> (h::a) <span class="kw">else</span> a) [] lst)</span></code></pre></div>
</div></p></details></details></section><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="ocaml.html" title="backward to &quot;2 Functional Programming with OCaml&quot;" data-pltdoc="x" rel="prev">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;CMSC 330 Lecture Notes&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<span class="nonavigation">next &rarr;</span></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>