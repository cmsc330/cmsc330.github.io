<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>1&nbsp;Functional Programming with OCaml</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><link rel="stylesheet" type="text/css" href="extra.css" title="default"/><link rel="stylesheet" type="text/css" href="fancyverb.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript">
(function() {document.write('<scr' + 'ipt type="text/javascript" src="MathJax/MathJax.js?config=default"></scr' + 'ipt>');})();
</script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">CMSC 330 Lecture Notes</a></td></tr></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Functional Programming with OCaml</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td>1&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Functional Programming with OCaml</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">1.1&nbsp;</td><td><a href="#%28part._.Books%29" class="tocviewlink" data-pltdoc="x">Books</a></td></tr><tr><td align="right">1.2&nbsp;</td><td><a href="#%28part._.Installing_.O.Caml%29" class="tocviewlink" data-pltdoc="x">Installing OCaml</a></td></tr><tr><td align="right">1.3&nbsp;</td><td><a href="#%28part.__.O.P.A.M__.O.Caml_.Package_.Manager%29" class="tocviewlink" data-pltdoc="x"> OPAM:<span class="mywbr"> &nbsp;</span> OCaml Package Manager</a></td></tr><tr><td align="right">1.4&nbsp;</td><td><a href="#%28part.__.Working_with_.O.Caml%29" class="tocviewlink" data-pltdoc="x"> Working with OCaml</a></td></tr><tr><td align="right">1.5&nbsp;</td><td><a href="#%28part._.Project_.Builds_with_dune%29" class="tocviewlink" data-pltdoc="x">Project Builds with dune</a></td></tr><tr><td align="right">1.6&nbsp;</td><td><a href="#%28part.__.O.Caml_.Basics%29" class="tocviewlink" data-pltdoc="x"> OCaml Basics</a></td></tr><tr><td align="right">1.7&nbsp;</td><td><a href="#%28part._.O.Caml_toplevel__a_.R.E.P.L_for_.O.Caml%29" class="tocviewlink" data-pltdoc="x">OCaml toplevel, a REPL for OCaml</a></td></tr><tr><td align="right">1.8&nbsp;</td><td><a href="#%28part._.First_.O.Caml_.Example%29" class="tocviewlink" data-pltdoc="x">First OCaml Example</a></td></tr><tr><td align="right">1.9&nbsp;</td><td><a href="#%28part._.Expressions%29" class="tocviewlink" data-pltdoc="x">Expressions</a></td></tr><tr><td align="right">1.10&nbsp;</td><td><a href="#%28part._.Values%29" class="tocviewlink" data-pltdoc="x">Values</a></td></tr><tr><td align="right">1.11&nbsp;</td><td><a href="#%28part._.Types%29" class="tocviewlink" data-pltdoc="x">Types</a></td></tr><tr><td align="right">1.12&nbsp;</td><td><a href="#%28part._if_expression%29" class="tocviewlink" data-pltdoc="x">if expression</a></td></tr><tr><td align="right">1.13&nbsp;</td><td><a href="#%28part._.Functions%29" class="tocviewlink" data-pltdoc="x">Functions</a></td></tr><tr><td align="right">1.14&nbsp;</td><td><a href="#%28part._.Lists%29" class="tocviewlink" data-pltdoc="x">Lists</a></td></tr><tr><td align="right">1.15&nbsp;</td><td><a href="#%28part._.Pattern_.Matching%29" class="tocviewlink" data-pltdoc="x">Pattern Matching</a></td></tr><tr><td align="right">1.16&nbsp;</td><td><a href="#%28part._.Lists_and_.Recursion%29" class="tocviewlink" data-pltdoc="x">Lists and Recursion</a></td></tr><tr><td align="right">1.17&nbsp;</td><td><a href="#%28part.__.Let_.Expressions%29" class="tocviewlink" data-pltdoc="x"> Let Expressions</a></td></tr><tr><td align="right">1.18&nbsp;</td><td><a href="#%28part._.Tuples%29" class="tocviewlink" data-pltdoc="x">Tuples</a></td></tr><tr><td align="right">1.19&nbsp;</td><td><a href="#%28part._.Records%29" class="tocviewlink" data-pltdoc="x">Records</a></td></tr><tr><td align="right">1.20&nbsp;</td><td><a href="#%28part._.Anonymous_.Functions%29" class="tocviewlink" data-pltdoc="x">Anonymous Functions</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">1.1<tt>&nbsp;</tt></span><a href="#%28part._.Books%29" class="tocsubseclink" data-pltdoc="x">Books</a></td></tr><tr><td><span class="tocsublinknumber">1.1.1<tt>&nbsp;</tt></span><a href="#%28part._.Similar_.Courses%29" class="tocsubseclink" data-pltdoc="x">Similar Courses</a></td></tr><tr><td><span class="tocsublinknumber">1.2<tt>&nbsp;</tt></span><a href="#%28part._.Installing_.O.Caml%29" class="tocsubseclink" data-pltdoc="x">Installing OCaml</a></td></tr><tr><td><span class="tocsublinknumber">1.3<tt>&nbsp;</tt></span><a href="#%28part.__.O.P.A.M__.O.Caml_.Package_.Manager%29" class="tocsubseclink" data-pltdoc="x"> OPAM:<span class="mywbr"> &nbsp;</span> OCaml Package Manager</a></td></tr><tr><td><span class="tocsublinknumber">1.4<tt>&nbsp;</tt></span><a href="#%28part.__.Working_with_.O.Caml%29" class="tocsubseclink" data-pltdoc="x"> Working with OCaml</a></td></tr><tr><td><span class="tocsublinknumber">1.5<tt>&nbsp;</tt></span><a href="#%28part._.Project_.Builds_with_dune%29" class="tocsubseclink" data-pltdoc="x">Project Builds with dune</a></td></tr><tr><td><span class="tocsublinknumber">1.6<tt>&nbsp;</tt></span><a href="#%28part.__.O.Caml_.Basics%29" class="tocsubseclink" data-pltdoc="x"> OCaml Basics</a></td></tr><tr><td><span class="tocsublinknumber">1.7<tt>&nbsp;</tt></span><a href="#%28part._.O.Caml_toplevel__a_.R.E.P.L_for_.O.Caml%29" class="tocsubseclink" data-pltdoc="x">OCaml toplevel, a REPL for OCaml</a></td></tr><tr><td><span class="tocsublinknumber">1.8<tt>&nbsp;</tt></span><a href="#%28part._.First_.O.Caml_.Example%29" class="tocsubseclink" data-pltdoc="x">First OCaml Example</a></td></tr><tr><td><span class="tocsublinknumber">1.9<tt>&nbsp;</tt></span><a href="#%28part._.Expressions%29" class="tocsubseclink" data-pltdoc="x">Expressions</a></td></tr><tr><td><span class="tocsublinknumber">1.10<tt>&nbsp;</tt></span><a href="#%28part._.Values%29" class="tocsubseclink" data-pltdoc="x">Values</a></td></tr><tr><td><span class="tocsublinknumber">1.11<tt>&nbsp;</tt></span><a href="#%28part._.Types%29" class="tocsubseclink" data-pltdoc="x">Types</a></td></tr><tr><td><span class="tocsublinknumber">1.12<tt>&nbsp;</tt></span><a href="#%28part._if_expression%29" class="tocsubseclink" data-pltdoc="x">if expression</a></td></tr><tr><td><span class="tocsublinknumber">1.13<tt>&nbsp;</tt></span><a href="#%28part._.Functions%29" class="tocsubseclink" data-pltdoc="x">Functions</a></td></tr><tr><td><span class="tocsublinknumber">1.13.1<tt>&nbsp;</tt></span><a href="#%28part._.Calling_.Functions__.Function_.Application_%29" class="tocsubseclink" data-pltdoc="x">Calling Functions (Function Application)</a></td></tr><tr><td><span class="tocsublinknumber">1.13.2<tt>&nbsp;</tt></span><a href="#%28part._.Function_.Types%29" class="tocsubseclink" data-pltdoc="x">Function Types</a></td></tr><tr><td><span class="tocsublinknumber">1.13.3<tt>&nbsp;</tt></span><a href="#%28part._.Type_.Checking_of_.Function_application%29" class="tocsubseclink" data-pltdoc="x">Type Checking of Function application</a></td></tr><tr><td><span class="tocsublinknumber">1.13.4<tt>&nbsp;</tt></span><a href="#%28part._.More_.Examples_on_.Function_.Type_.Checking%29" class="tocsubseclink" data-pltdoc="x">More Examples on Function Type Checking</a></td></tr><tr><td><span class="tocsublinknumber">1.13.5<tt>&nbsp;</tt></span><a href="#%28part._.Mutually_.Recusrive_.Functions%29" class="tocsubseclink" data-pltdoc="x">Mutually Recusrive Functions</a></td></tr><tr><td><span class="tocsublinknumber">1.13.6<tt>&nbsp;</tt></span><a href="#%28part._.Polymorphic_.Types%29" class="tocsubseclink" data-pltdoc="x">Polymorphic Types</a></td></tr><tr><td><span class="tocsublinknumber">1.13.7<tt>&nbsp;</tt></span><a href="#%28part._.Type_annotations%29" class="tocsubseclink" data-pltdoc="x">Type annotations</a></td></tr><tr><td><span class="tocsublinknumber">1.14<tt>&nbsp;</tt></span><a href="#%28part._.Lists%29" class="tocsubseclink" data-pltdoc="x">Lists</a></td></tr><tr><td><span class="tocsublinknumber">1.14.1<tt>&nbsp;</tt></span><a href="#%28part._.Typing_.Lists%29" class="tocsubseclink" data-pltdoc="x">Typing Lists</a></td></tr><tr><td><span class="tocsublinknumber">1.14.2<tt>&nbsp;</tt></span><a href="#%28part.____.Operator%29" class="tocsubseclink" data-pltdoc="x">:<span class="mywbr"> &nbsp;</span>:<span class="mywbr"> &nbsp;</span> Operator</a></td></tr><tr><td><span class="tocsublinknumber">1.14.3<tt>&nbsp;</tt></span><a href="#%28part._.Lists_of_.Lists%29" class="tocsubseclink" data-pltdoc="x">Lists of Lists</a></td></tr><tr><td><span class="tocsublinknumber">1.15<tt>&nbsp;</tt></span><a href="#%28part._.Pattern_.Matching%29" class="tocsubseclink" data-pltdoc="x">Pattern Matching</a></td></tr><tr><td><span class="tocsublinknumber">1.15.1<tt>&nbsp;</tt></span><a href="#%28part._.Pattern_.Matching_.Lists%29" class="tocsubseclink" data-pltdoc="x">Pattern Matching Lists</a></td></tr><tr><td><span class="tocsublinknumber">1.15.2<tt>&nbsp;</tt></span><a href="#%28part._.Pattern_.Matching_~e2~80~93_.An_.Abbreviation%29" class="tocsubseclink" data-pltdoc="x">Pattern Matching &#8211; An Abbreviation</a></td></tr><tr><td><span class="tocsublinknumber">1.16<tt>&nbsp;</tt></span><a href="#%28part._.Lists_and_.Recursion%29" class="tocsubseclink" data-pltdoc="x">Lists and Recursion</a></td></tr><tr><td><span class="tocsublinknumber">1.17<tt>&nbsp;</tt></span><a href="#%28part.__.Let_.Expressions%29" class="tocsubseclink" data-pltdoc="x"> Let Expressions</a></td></tr><tr><td><span class="tocsublinknumber">1.17.1<tt>&nbsp;</tt></span><a href="#%28part._.Let_.Definitions_vs__.Let_.Expressions_%29" class="tocsubseclink" data-pltdoc="x">Let Definitions vs. Let Expressions </a></td></tr><tr><td><span class="tocsublinknumber">1.17.2<tt>&nbsp;</tt></span><a href="#%28part._.Let_.Expressions__.Scope%29" class="tocsubseclink" data-pltdoc="x">Let Expressions:<span class="mywbr"> &nbsp;</span> Scope</a></td></tr><tr><td><span class="tocsublinknumber">1.17.3<tt>&nbsp;</tt></span><a href="#%28part._.Nested_.Let_.Expressions%29" class="tocsubseclink" data-pltdoc="x">Nested Let Expressions</a></td></tr><tr><td><span class="tocsublinknumber">1.17.4<tt>&nbsp;</tt></span><a href="#%28part._.Let_.Expressions_in_.Functions%29" class="tocsubseclink" data-pltdoc="x">Let Expressions in Functions</a></td></tr><tr><td><span class="tocsublinknumber">1.17.5<tt>&nbsp;</tt></span><a href="#%28part._.Shadowing_.Names%29" class="tocsubseclink" data-pltdoc="x">Shadowing Names</a></td></tr><tr><td><span class="tocsublinknumber">1.18<tt>&nbsp;</tt></span><a href="#%28part._.Tuples%29" class="tocsubseclink" data-pltdoc="x">Tuples</a></td></tr><tr><td><span class="tocsublinknumber">1.18.1<tt>&nbsp;</tt></span><a href="#%28part._.Pattern_.Matching_.Tuples%29" class="tocsubseclink" data-pltdoc="x">Pattern Matching Tuples</a></td></tr><tr><td><span class="tocsublinknumber">1.19<tt>&nbsp;</tt></span><a href="#%28part._.Records%29" class="tocsubseclink" data-pltdoc="x">Records</a></td></tr><tr><td><span class="tocsublinknumber">1.20<tt>&nbsp;</tt></span><a href="#%28part._.Anonymous_.Functions%29" class="tocsubseclink" data-pltdoc="x">Anonymous Functions</a></td></tr><tr><td><span class="tocsublinknumber">1.20.1<tt>&nbsp;</tt></span><a href="#%28part._.Functions_and_.Binding%29" class="tocsubseclink" data-pltdoc="x">Functions and Binding</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">8.17</span></div><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="index.html" title="backward to &quot;CMSC 330 Lecture Notes&quot;" data-pltdoc="x" rel="prev">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;CMSC 330 Lecture Notes&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<span class="nonavigation">next &rarr;</span></span>&nbsp;</div><h3 class="heading">1<tt>&nbsp;</tt><a name="(part._ocaml)"></a>Functional Programming with OCaml<span class="button-group"><a href="#(part._ocaml)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h3><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Books%29" class="toclink" data-pltdoc="x">1.1<span class="hspace">&nbsp;</span>Books</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Installing_.O.Caml%29" class="toclink" data-pltdoc="x">1.2<span class="hspace">&nbsp;</span>Installing OCaml</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part.__.O.P.A.M__.O.Caml_.Package_.Manager%29" class="toclink" data-pltdoc="x">1.3<span class="hspace">&nbsp;</span> OPAM: OCaml Package Manager</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part.__.Working_with_.O.Caml%29" class="toclink" data-pltdoc="x">1.4<span class="hspace">&nbsp;</span> Working with OCaml</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Project_.Builds_with_dune%29" class="toclink" data-pltdoc="x">1.5<span class="hspace">&nbsp;</span>Project Builds with dune</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part.__.O.Caml_.Basics%29" class="toclink" data-pltdoc="x">1.6<span class="hspace">&nbsp;</span> OCaml Basics</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.O.Caml_toplevel__a_.R.E.P.L_for_.O.Caml%29" class="toclink" data-pltdoc="x">1.7<span class="hspace">&nbsp;</span>OCaml toplevel, a REPL for OCaml</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.First_.O.Caml_.Example%29" class="toclink" data-pltdoc="x">1.8<span class="hspace">&nbsp;</span>First OCaml Example</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Expressions%29" class="toclink" data-pltdoc="x">1.9<span class="hspace">&nbsp;</span>Expressions</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Values%29" class="toclink" data-pltdoc="x">1.10<span class="hspace">&nbsp;</span>Values</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Types%29" class="toclink" data-pltdoc="x">1.11<span class="hspace">&nbsp;</span>Types</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._if_expression%29" class="toclink" data-pltdoc="x">1.12<span class="hspace">&nbsp;</span>if expression</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Functions%29" class="toclink" data-pltdoc="x">1.13<span class="hspace">&nbsp;</span>Functions</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Lists%29" class="toclink" data-pltdoc="x">1.14<span class="hspace">&nbsp;</span>Lists</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Pattern_.Matching%29" class="toclink" data-pltdoc="x">1.15<span class="hspace">&nbsp;</span>Pattern Matching</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Lists_and_.Recursion%29" class="toclink" data-pltdoc="x">1.16<span class="hspace">&nbsp;</span>Lists and Recursion</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part.__.Let_.Expressions%29" class="toclink" data-pltdoc="x">1.17<span class="hspace">&nbsp;</span> Let Expressions</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Tuples%29" class="toclink" data-pltdoc="x">1.18<span class="hspace">&nbsp;</span>Tuples</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Records%29" class="toclink" data-pltdoc="x">1.19<span class="hspace">&nbsp;</span>Records</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Anonymous_.Functions%29" class="toclink" data-pltdoc="x">1.20<span class="hspace">&nbsp;</span>Anonymous Functions</a></p></td></tr></table><p><div class="SIntrapara">OCaml is a dialect of the ML programming language family, developed in France at INRIA. OCaml is the main implementation of the programming language Caml. The features of ML include:
</div><div class="SIntrapara"><ul><li><p>First-class functions</p></li><li><ul><li><p> Functions can be data. We can send functions as  parameters to other functions and return functions as return values.</p></li></ul></li><li><p>Favor immutability (assign once)</p></li><li><p>Data types and pattern matching</p></li><li><ul><li><p>Convenient for certain kinds of data structures</p></li></ul></li><li><p>Type inference</p></li><li><ul><li><p>OCaml is statically typed, but there is no need to write types in the source language</p></li><li><p>Supports parametric polymorphism, similar to Generics in Java, templates in C++</p></li></ul></li><li><p>Exceptions</p></li><li><p>Garbage collection</p></li></ul></div><div class="SIntrapara">Modern programming languages have borrowed many ideas from functional programming, including first-class functions, anonymous functions, and garbage collection.</div></p><h4 class="heading">1.1<tt>&nbsp;</tt><a name="(part._.Books)"></a>Books<span class="button-group"><a href="#(part._.Books)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p><div class="SIntrapara">Below is a list of free online books available on OCaml.
</div><div class="SIntrapara"><ul><li><p>Developing Applications with Objective Caml <a href="https://caml.inria.fr/pub/docs/oreilly-book/ocaml-ora-book.pdf">https://caml.inria.fr/pub/docs/oreilly-book/ocaml-ora-book.pdf</a></p></li><li><p>Introduction to the Objective Caml Programming Language <a href="http://courses.cms.caltech.edu/cs134/cs134b/book.pdf">http://courses.cms.caltech.edu/cs134/cs134b/book.pdf</a></p></li><li><p>Real World OCaml 2nd Edition <a href="https://dev.realworldocaml.org/">https://dev.realworldocaml.org/</a></p></li><li><p>OCaml from the Very Beginning <a href="https://johnwhitington.net/ocamlfromtheverybeginning/mlbook.pdf">https://johnwhitington.net/ocamlfromtheverybeginning/mlbook.pdf</a></p></li><li><p>Cornell cs3110 book <a href="https://cs3110.github.io/textbook/cover.html">https://cs3110.github.io/textbook/cover.html</a> is another course which uses OCaml; it is more focused on programming and less on PL theory than this class is.</p></li><li><p><a href="ocaml.org">ocaml.org</a> is the home of OCaml for finding downloads, documentation, etc. The tutorials are also very good and there is a page of books.</p></li></ul></div></p><h5 class="heading">1.1.1<tt>&nbsp;</tt><a name="(part._.Similar_.Courses)"></a>Similar Courses<span class="button-group"><a href="#(part._.Similar_.Courses)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>If you&rsquo;re interested, I&#8217;ve listed several similar courses from other universities. For example, Cornell offers a comparable course&#8212;CS 3110&#8212;and there are also similar offerings from the University of Washington, Princeton, Harvard, and UIUC. You can check out their websites; Cornell&#8217;s, in particular, provides an online textbook along with videos and other helpful resources.</p><p>You might find it helpful to watch their lectures, go through their examples, or even try out their projects or exams. They all use OCaml, and the course structure is quite similar.</p><p>So, it&#8217;s more than just a textbook&#8212;you have access to notes, slides, exams, and other useful materials.</p><ul><li><p>CS3110 (Cornell)</p></li><li><p>CSE341 (Washington)</p></li><li><p>601.426 (Johns Hopkins)</p></li><li><p>COS326 (Princeton)</p></li><li><p>CS152 (Harvard)</p></li><li><p>CS421 (UIUC)</p></li></ul><h4 class="heading">1.2<tt>&nbsp;</tt><a name="(part._.Installing_.O.Caml)"></a>Installing OCaml<span class="button-group"><a href="#(part._.Installing_.O.Caml)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Install the latest version of OCaml from https://ocaml.org/</p><h4 class="heading">1.3<tt>&nbsp;</tt><a name="(part.__.O.P.A.M__.O.Caml_.Package_.Manager)"></a> OPAM: OCaml Package Manager<span class="button-group"><a href="#(part.__.O.P.A.M__.O.Caml_.Package_.Manager)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p><div class="SIntrapara">Opam is the package manager for OCaml. It manages libraries and different compiler installations. For the class projects, you should install the following packages with <span style="font-weight: bold">opam</span>.
</div><div class="SIntrapara"><ul><li><p>ounit, a testing framework similar to minitest</p></li><li><p>utop, a top-level interface</p></li><li><p>dune, a build system for larger projects</p></li></ul></div></p><h4 class="heading">1.4<tt>&nbsp;</tt><a name="(part.__.Working_with_.O.Caml)"></a> Working with OCaml<span class="button-group"><a href="#(part.__.Working_with_.O.Caml)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>OCaml programs can be compiled using <span style="font-weight: bold">ocamlc</span>. It produces <span style="font-weight: bold"></span>.cmo (compiled object) and {.cmi} (compiled interface) files. You can use <span style="font-weight: bold">-o</span> to set output file name, and use <span style="font-weight: bold">-c</span> to compile only to <span style="font-weight: bold">.cmo/.cmi</span> and not to link. You can also compile with <span style="font-weight: bold">ocamlopt</span>. It produces <span style="font-weight: bold">cmx</span> files, which contain native code: faster, but not platform-independent (or as easily debugged)</p><h4 class="heading">1.5<tt>&nbsp;</tt><a name="(part._.Project_.Builds_with_dune)"></a>Project Builds with dune<span class="button-group"><a href="#(part._.Project_.Builds_with_dune)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>You use <span style="font-weight: bold">dune</span> to compile projects. It automatically finds dependencies, invokes compiler and linker. Let us create a new project with <span style="font-weight: bold">dune</span>:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">shell</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode fish"><code class="sourceCode fish"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="er">&gt;</span> dune init project HelloWorld</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">Entering</span> directory &#39;<span class="st">/Users/anwar/git/2025Fall/CMSC330/cmsc330-notes/notes/code/HelloWorld&#39;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">Success:</span> initialized project component named HelloWorld</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="fu">Leaving</span> directory &#39;<span class="st">/Users/anwar/git/2025Fall/CMSC330/cmsc330-notes/notes/code/HelloWorld&#39;</span></span></code></pre></div>
</p></blockquote></blockquote><p><div class="SIntrapara">It creates a &lsquo;HelloWorld&lsquo; project with the following files:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">shell</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode fish"><code class="sourceCode fish"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="er">&gt;</span> tree HelloWorld</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">HelloWorld</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>â”œâ”€â”€ <span class="fu">_build</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>â”‚Â Â  â””â”€â”€ <span class="fu">log</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>â”œâ”€â”€ <span class="fu">bin</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>â”‚Â Â  â”œâ”€â”€ <span class="fu">dune</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>â”‚Â Â  â””â”€â”€ <span class="fu">main.ml</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>â”œâ”€â”€ <span class="fu">dune-project</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>â”œâ”€â”€ <span class="fu">HelloWorld.opam</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>â”œâ”€â”€ <span class="fu">lib</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>â”‚Â Â  â””â”€â”€ <span class="fu">dune</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>â””â”€â”€ <span class="bu">test</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    â”œâ”€â”€ <span class="fu">dune</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    â””â”€â”€ <span class="fu">test_HelloWorld.ml</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>5 <span class="fu">directories,</span> 8 files</span></code></pre></div>
</p></blockquote></blockquote></div></p><p>Build the project:
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>dune build</span></code></pre></div>
</p><p>Run it:
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>dune exec bin/main.exe</span></code></pre></div>

or
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>_build/default/main.exe</span></code></pre></div>

Run the tests
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>dune runtest</span></code></pre></div>
</p><h4 class="heading">1.6<tt>&nbsp;</tt><a name="(part.__.O.Caml_.Basics)"></a> OCaml Basics<span class="button-group"><a href="#(part.__.O.Caml_.Basics)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p><div class="SIntrapara">OCaml files are written with a &ldquo;.ml&ldquo; extension. An OCaml file is similar to a Python file: when run, it evaluates the file directly. There is no special main function. An OCaml file consists of
</div><div class="SIntrapara"><ul><li><p>A series of open statements for including other modules</p></li><li><p>A series of declarations for defining datatypes, functions, and constants</p></li><li><p>A series of (though often just one) toplevel expressions to evaluate.</p></li></ul></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* A small OCaml program *)</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="dt">print_string</span> <span class="st">&quot;Hello world!</span><span class="ch">\n</span><span class="st">&quot;</span>;;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>Hello world!</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">unit</span> = ()</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">Or
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">open</span> <span class="dt">Printf</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> message = <span class="st">&quot;Hello world&quot;</span>;; </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> (printf <span class="st">&quot;%s</span><span class="ch">\n</span><span class="st">&quot;</span> message);;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> message : <span class="dt">string</span> = <span class="st">&quot;Hello world&quot;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>Hello world</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">unit</span> = ()</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">The first line includes the built-in library for printing, which provides functions similar to <span style="font-weight: bold">fprintf</span> and <span style="font-weight: bold">printf</span>
 from <span style="font-weight: bold">stdlib</span> in <span style="font-weight: bold">C</span>. The next two lines define a constant named message, and then call the <span style="font-weight: bold">&lsquo;printf</span> function with a format string (where &lsquo;%s&lsquo; means "format as string"), and the constant message we defined on the line before.</div></p><p><div class="SIntrapara">To compile and run
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">shell</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode fish"><code class="sourceCode fish"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="er">&gt;</span> ocamlc hello.ml -o hello</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="er">&gt;</span> ./hello</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">Hello</span> world!</span></code></pre></div>
</p></blockquote></blockquote></div></p><p><div class="SIntrapara">We can also compile multiple files to generate a single executable.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><a href="code/main.ml"><span class="stt">main.ml</span></a></span></p><blockquote class="Rfilecontent"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">*</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">main.ml</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">*</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym">let</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">main</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">=</span><span class="RktMeta"></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym">print_int</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">Util.add</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">10</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">20</span><span class="RktPn">)</span><span class="RktCmt">;</span><span class="hspace">&nbsp;</span><span class="RktCmt">print_string</span><span class="hspace">&nbsp;</span><span class="RktCmt">"\n"</span><span class="RktMeta"></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym">let</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">main</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta">&#160;</span></td></tr></table></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><a href="code/util.ml"><span class="stt">util.ml</span></a></span></p><blockquote class="Rfilecontent"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">*</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">util.ml</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">*</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym">let</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">add</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">x</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">y</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">x</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">+</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">y</span><span class="RktMeta"></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta">&#160;</span></td></tr></table></blockquote></blockquote></div></p><p>Compile and run:</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">shell</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode fish"><code class="sourceCode fish"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="er">&gt;</span> ocamlc util.ml main.ml -o main</span></code></pre></div>
</p></blockquote></blockquote><p>Or compile separately</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">shell</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode fish"><code class="sourceCode fish"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="er">&gt;</span> ocamlc -c util.ml</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="er">&gt;</span> ocamlc util.cmo main.ml</span></code></pre></div>
</p></blockquote></blockquote><p><div class="SIntrapara">It generates an executable <span style="font-weight: bold">main</span>. We can execute it by
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">shell</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode fish"><code class="sourceCode fish"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="er">&gt;</span> ./main</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>30</span></code></pre></div>
</p></blockquote></blockquote></div></p><h4 class="heading">1.7<tt>&nbsp;</tt><a name="(part._.O.Caml_toplevel__a_.R.E.P.L_for_.O.Caml)"></a>OCaml toplevel, a REPL for OCaml<span class="button-group"><a href="#(part._.O.Caml_toplevel__a_.R.E.P.L_for_.O.Caml)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>We will begin exploration of OCaml in the interactive top level. A top level is also called a read-eval-print loop (REPL) and it works like a terminal shell. To run the ocaml topleve, simply run &lsquo;ocaml&lsquo;
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> % ocaml</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> OCaml version <span class="fl">5.2</span>.<span class="dv">0</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> # <span class="dt">print_string</span> <span class="st">&quot;Hello world!</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;</span>;;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    Hello world!</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a> - : <span class="dt">unit</span> = ()</span></code></pre></div>

There is an alternative toplevel called <span style="font-weight: bold">utop</span>. It is more user friendly, and we will be using &lsquo;utop&lsquo; in the class. You can install <span style="font-weight: bold">utop</span> by runnung <span style="font-weight: bold">opam install utop</span>&lsquo;. Follow the instructions in the project 0 for installing opam and ocaml.</p><p>To load a &lsquo;.ml&lsquo; file into top level:
<pre class="&quot;ocaml&quot;"><code>
&quot;#use &quot;hello.ml&quot;

Hello world!
- : unit = ()</code></pre>
</p><p><div class="SIntrapara">To exit the top-level, type <span style="font-weight: bold">^D</span> (Control D) or call the exit 0
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt"># exit 0;;</span></p></td></tr></table></div></p><h4 class="heading">1.8<tt>&nbsp;</tt><a name="(part._.First_.O.Caml_.Example)"></a>First OCaml Example<span class="button-group"><a href="#(part._.First_.O.Caml_.Example)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* A small OCaml program (* with nested comments *) *)</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> x = <span class="dv">37</span>;; </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> y = x + <span class="dv">5</span>;; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> <span class="dt">print_int</span> y;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> x : <span class="dt">int</span> = <span class="dv">37</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> y : <span class="dt">int</span> = <span class="dv">42</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="dv">42</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">unit</span> = ()</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote><p><div class="SIntrapara">OCaml is strictly typed. It does not implicitly cast types. For example, <span style="font-weight: bold">print_int</span> only prints <span style="font-weight: bold">int</span>s.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">print_int</span> <span class="dv">10</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="dv">10</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">unit</span> = ()</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara"><span style="font-weight: bold">( )</span> is called unit. It is similar to &lsquo;void&lsquo; in other languages. Following expressions do not type check
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">print_int</span> <span class="fl">10.5</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>Line <span class="dv">1</span>, characters <span class="dv">10-14</span>:</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> | <span class="dt">print_int</span> <span class="fl">10.5</span>;;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>              ^^^^</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>Error: The constant <span class="st">&quot;10.5&quot;</span> has <span class="kw">type</span> <span class="st">&quot;float&quot;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>       but an expression was expected <span class="kw">of</span> <span class="kw">type</span> <span class="st">&quot;int&quot;</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">becase <span style="font-weight: bold">print_int</span> does not take <span style="font-weight: bold">float</span> as an argument. The following code does not typecheck because <span style="font-weight: bold">+</span> operator requires both operands are integers. Adding a float to an integer results in a type error.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> + <span class="fl">0.5</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>Line <span class="dv">1</span>, characters <span class="dv">4-7</span>:</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> | <span class="dv">1</span> + <span class="fl">0.5</span>;;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>        ^^^</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>Error: The constant <span class="st">&quot;0.5&quot;</span> has <span class="kw">type</span> <span class="st">&quot;float&quot;</span> but an expression was expected <span class="kw">of</span> <span class="kw">type</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>         <span class="st">&quot;int&quot;</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">Adding a boolean to an integer results in a type error too.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> + <span class="kw">true</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>Line <span class="dv">1</span>, characters <span class="dv">4-8</span>:</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> | <span class="dv">1</span> + <span class="kw">true</span>;;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>        ^^^^</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>Error: The constructor <span class="st">&quot;true&quot;</span> has <span class="kw">type</span> <span class="st">&quot;bool&quot;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>       but an expression was expected <span class="kw">of</span> <span class="kw">type</span> <span class="st">&quot;int&quot;</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><p><div class="SIntrapara">As expected, <span style="font-weight: bold">print_int</span> does not a string as an argument.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">print_int</span> <span class="st">&quot;This function expected an int&quot;</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>Line <span class="dv">1</span>, characters <span class="dv">10-41</span>:</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> | <span class="dt">print_int</span> <span class="st">&quot;This function expected an int&quot;</span>;;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>Error: This constant has <span class="kw">type</span> <span class="st">&quot;string&quot;</span> but an expression was expected <span class="kw">of</span> <span class="kw">type</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>         <span class="st">&quot;int&quot;</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><h4 class="heading">1.9<tt>&nbsp;</tt><a name="(part._.Expressions)"></a>Expressions<span class="button-group"><a href="#(part._.Expressions)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>In OCaml, expressions are the fundamental building blocks of programs, and evaluating an expression always produces a value. Unlike many imperative languages, which distinguish between statements (actions) and expressions (values), OCaml is expression-oriented&#8212;almost everything in the language is an expression that yields a result.</p><p><div class="SIntrapara">Every kind of expression has syntax and semantics. Semantics include:
 </div><div class="SIntrapara"><ul><li><p>Type checking rules (static semantics): produce a type or fail with an error message</p></li><li><p>Evaluation rules (dynamic semantics): produce a value or an exception or infinite loop. Evaluation rules are used only on expressions that type-check</p></li></ul></div></p><p>We use metavariable <span style="font-weight: bold">e</span> to designate an arbitrary expression.</p><h4 class="heading">1.10<tt>&nbsp;</tt><a name="(part._.Values)"></a>Values<span class="button-group"><a href="#(part._.Values)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>A value is an expression that is final. For example, <span style="font-weight: bold">34</span> and <span style="font-weight: bold">true</span> are values because we cannot evaluate them any further. On the contrary, <span style="font-weight: bold">34+17</span> is an expression, but not a value because we can further evaluate it. Evaluating an expression means running it until it is a value. For example <span style="font-weight: bold">34+17</span> evaluates to 51, which is a value. We use metavariable <span style="font-weight: bold">v</span> to designate an arbitrary value</p><h4 class="heading">1.11<tt>&nbsp;</tt><a name="(part._.Types)"></a>Types<span class="button-group"><a href="#(part._.Types)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Types classify expressions. It is the set of values an expression could evaluate to. Examples include &lsquo;int&lsquo;, &lsquo;bool&lsquo;, &lsquo;string&lsquo;, and more. We use metavariable <span style="font-weight: bold">t</span> to designate an arbitrary type. Expression <span style="font-weight: bold">e</span> has type <span style="font-weight: bold">t</span> if <span style="font-weight: bold">e</span> will (always) evaluate to a value of type <span style="font-weight: bold">t</span>. For example <span style="font-weight: bold">0</span>, <span style="font-weight: bold">1</span>, and <span style="font-weight: bold">-1</span> are values of type <span style="font-weight: bold">int</span> while <span style="font-weight: bold">true</span> has type <span style="font-weight: bold">bool</span>. <span style="font-weight: bold">34+17</span> is an expression of type <span style="font-weight: bold">int</span>, since it evaluates to <span style="font-weight: bold">51</span>, which has type <span style="font-weight: bold">int</span>. We usually write <span style="font-weight: bold">e : t</span> to say <span style="font-weight: bold">e</span> has type <span style="font-weight: bold">t</span>.  The process of determining <span style="font-weight: bold">e</span> has type <span style="font-weight: bold">t</span> is called <span style="font-weight: bold">type checking</span> simply, <span style="font-weight: bold">typing</span>.</p><h4 class="heading">1.12<tt>&nbsp;</tt><a name="(part._if_expression)"></a>if expression<span class="button-group"><a href="#(part._if_expression)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>The syntax of the if expression is
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span> e1 <span class="kw">then</span> e2 <span class="kw">else</span> e3</span></code></pre></div>
</p><p>We type check the if expression using the following type checking rules:
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span> e1 : <span class="dt">bool</span> <span class="kw">and</span> e2 : t <span class="kw">and</span> e3 : t <span class="kw">then</span>  <span class="kw">if</span> e1 <span class="kw">then</span> e2 <span class="kw">else</span> e3 : t</span></code></pre></div>
</p><ul><li><p>Condition must be a bool: The expression e1 (the condition) must have type bool. For example, writing if 1 then ... causes a type error, since 1 has type int, not bool.</p></li><li><p>Then- and Else-branches must have the same type: Both e2 and e3 must evaluate to values of the same type.</p></li></ul><p><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span> <span class="dv">7</span> &gt; <span class="dv">42</span> <span class="kw">then</span> <span class="st">&quot;hello&quot;</span> <span class="kw">else</span> <span class="st">&quot;goodbye&quot;</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">string</span> = <span class="st">&quot;goodbye&quot;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">The follwing expression does not type check because the two branches of the &lsquo;if&lsquo; expressin do not return the same type. The &lsquo;true&lsquo; branch returns &lsquo;string&lsquo;, while the &lsquo;false&lsquo; branch returns &lsquo;int&lsquo;
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span> <span class="dv">7</span> &gt; <span class="dv">42</span> <span class="kw">then</span> <span class="st">&quot;hello&quot;</span> <span class="kw">else</span> <span class="dv">10</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>Line <span class="dv">1</span>, characters <span class="dv">28-30</span>:</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> | <span class="kw">if</span> <span class="dv">7</span> &gt; <span class="dv">42</span> <span class="kw">then</span> <span class="st">&quot;hello&quot;</span> <span class="kw">else</span> <span class="dv">10</span>;;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>                                ^^</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>Error: The constant <span class="st">&quot;10&quot;</span> has <span class="kw">type</span> <span class="st">&quot;int&quot;</span> but an expression was expected <span class="kw">of</span> <span class="kw">type</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>         <span class="st">&quot;string&quot;</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><p>Display fraction: <div class="math">\frac{a}{b}</div></p><p><div class="SIntrapara">Evaluating an <span style="font-weight: bold">if</span> expression returns a value. For example, evaluaing <div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">if</span> <span class="dv">10</span> &gt; <span class="dv">5</span> <span class="kw">then</span> <span class="dv">100</span> <span class="kw">else</span> <span class="dv">200</span>)</span></code></pre></div>
 retuens <span style="font-weight: bold">100</span>.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">print_int</span> (<span class="kw">if</span> <span class="dv">10</span>&gt;<span class="dv">5</span> <span class="kw">then</span> <span class="dv">100</span> <span class="kw">else</span> <span class="dv">200</span>);;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="dv">100</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">unit</span> = ()</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><h4 class="heading">1.13<tt>&nbsp;</tt><a name="(part._.Functions)"></a>Functions<span class="button-group"><a href="#(part._.Functions)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>OCaml functions are like mathematical functions. They compute a result from provided arguments. We use &lsquo;let&lsquo; to define a function:</p><p>We now define the function <span style="font-weight: bold">next</span>, which accepts an integer <span style="font-weight: bold">n</span> and produces its successor.</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> next n = n + <span class="dv">1</span>;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> next <span class="dv">10</span>;;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> next : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">11</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote><p><div class="SIntrapara">Here is another function Factorial:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> fact n = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> n = <span class="dv">0</span> <span class="kw">then</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>       <span class="dv">1</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>       n * fact (n<span class="dv">-1</span>);; </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a> fact <span class="dv">5</span>;;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> fact : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">120</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara"><span style="font-weight: bold">rec</span> keyword is used to define <span style="font-weight: bold">recursive</span> functions. <span style="font-weight: bold">;;</span> ends an expression in the top-level of OCaml. We use it to say:  &#8220;Give me the value of this expression&#8221;. It is not used in the body of a function and it is not needed in the real OCaml development.</div></p><h5 class="heading">1.13.1<tt>&nbsp;</tt><a name="(part._.Calling_.Functions__.Function_.Application_)"></a>Calling Functions (Function Application)<span class="button-group"><a href="#(part._.Calling_.Functions__.Function_.Application_)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>In OCaml, calling a function is very straightforward &#8212; you just write the function name followed by its arguments, separated by spaces (not commas, and no parentheses are required unless for grouping). The calling syntax is:</p><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>f e1 e2 â€¦ en</span></code></pre></div>

Here is an example where we call the function <span style="font-weight: bold">square</span> with the argument <span style="font-weight: bold">5</span>.</p><p><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> square x = x * x;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> square <span class="dv">5</span>;;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> square : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">25</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">Nullary functions (Functions with no arguments) are a little special compared to languages like C or Python.</div></p><p>OCaml does not truly have &#8220;argumentless&#8221; functions. Instead, a nullary function is defined as one that takes the special value <span style="font-weight: bold">( )</span> of type <span style="font-weight: bold">unit</span>.</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> greet () = <span class="st">&quot;Hello&quot;</span>;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> greet ();;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> greet : <span class="dt">unit</span> -&gt; <span class="dt">string</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">string</span> = <span class="st">&quot;Hello&quot;</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote><p><div class="SIntrapara">We evaluate a function call expression according to these steps:
</div><div class="SIntrapara"><ul><li><p>Locate the definition of <span style="font-weight: bold">f</span>, i.e., <span style="font-weight: bold">let rec f x1 &#8230; xn = e</span>.</p></li><li><p>Evaluate the arguments <span style="font-weight: bold">e1 &#8230; en</span> to obtain values <span style="font-weight: bold">v1 &#8230; vn</span>.</p></li><li><p>Substitute the values <span style="font-weight: bold">v1 &#8230; vn</span> for the parameters <span style="font-weight: bold">x1 &#8230; xn</span> in the function body <span style="font-weight: bold">e</span>, yielding a new expression <span style="font-weight: bold">e&#8217;</span>.</p></li><li><p>Evaluate <span style="font-weight: bold">e&#8217;</span> to value <span style="font-weight: bold">v</span>, which is the final result</p></li></ul></div></p><p><div class="SIntrapara">Follwoing is an example of evaluating <span style="font-weight: bold">fact 2</span>
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> fact n = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> n = <span class="dv">0</span> <span class="kw">then</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>         <span class="dv">1</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>      <span class="kw">else</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>         n * fact (n<span class="dv">-1</span>);;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> fact : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td><p><span style="font-weight: bold">expression</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span style="font-weight: bold">semantics</span></p></td></tr><tr><td><p><span class="emph">fact 2</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p>substitute every occurence of n inside the body of fact with 2 </p></td></tr><tr><td><p><span class="emph">if 2=0 then 1 else 2*fact(2-1)</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p>evaluate the if expression</p></td></tr><tr><td><p><span class="emph">2 * fact 1</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p>result of the else branch</p></td></tr><tr><td><p><span class="emph">2 * (if 1=0 then 1 else 1*fact(1-1))</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p>substitute n with 1</p></td></tr><tr><td><p><span class="emph">2 * 1 * fact 0</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p>evaluate fact 0</p></td></tr><tr><td><p><span class="emph">2 * 1 * (if 0=0 then 1 else 0*fact(0-1))</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p>base case</p></td></tr><tr><td><p><span class="emph">2 * 1 * 1</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p></p></td></tr><tr><td><p><span class="emph">2</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p></p></td></tr></table></div></p><h5 class="heading">1.13.2<tt>&nbsp;</tt><a name="(part._.Function_.Types)"></a>Function Types<span class="button-group"><a href="#(part._.Function_.Types)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>In OCaml, <span style="font-weight: bold">&#8594;</span> is the function type constructor. Type <span style="font-weight: bold">t1 &#8594; t</span> is a function
with argument or domain type <span style="font-weight: bold">t1</span> and return or range type <span style="font-weight: bold">t</span>. Type
<span style="font-weight: bold">t1 &#8594; t2 &#8594; t</span> is a function that takes two inputs, of types <span style="font-weight: bold">t1</span> and <span style="font-weight: bold">t2</span>,
and returns a value of type <span style="font-weight: bold">t</span>.</p><h5 class="heading">1.13.3<tt>&nbsp;</tt><a name="(part._.Type_.Checking_of_.Function_application)"></a>Type Checking of Function application<span class="button-group"><a href="#(part._.Type_.Checking_of_.Function_application)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>As we have seen before, the syntax of a function application is
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>f e1 â€¦ en</span></code></pre></div>
</p><p>We use the following type checking rule for the function application:
If <span style="font-weight: bold">f : t1 &#8594; &#8230; &#8594; tn &#8594; u</span> and   <span style="font-weight: bold">e1 : t1,  &#8230;, en : tn</span> then
the type of <span style="font-weight: bold">f e1 &#8230; en</span> is <span style="font-weight: bold">u</span>.</p><p>For example: the type of <span style="font-weight: bold">not true</span> is <span style="font-weight: bold">bool</span> because <span style="font-weight: bold">not : bool &#8594; bool</span> and <span style="font-weight: bold">true : bool</span>.</p><h5 class="heading">1.13.4<tt>&nbsp;</tt><a name="(part._.More_.Examples_on_.Function_.Type_.Checking)"></a>More Examples on Function Type Checking<span class="button-group"><a href="#(part._.More_.Examples_on_.Function_.Type_.Checking)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p><div class="SIntrapara">The function <span style="font-weight: bold">next</span> calculates the next integer.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> next x = x + <span class="dv">1</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> next : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><p><div class="SIntrapara">Here is how &lsquo;ocaml&lsquo; inferred the type of <span style="font-weight: bold">next</span> as <span style="font-weight: bold">int&#8594;int</span>: <span style="font-weight: bold">+</span> is an integer addition operator. Both operands of <span style="font-weight: bold">+</span> must be integer. It means <span style="font-weight: bold">x</span> must be an integer. There the argument type and return type are <span style="font-weight: bold">int</span>. <span style="font-weight: bold">next</span> is a function, which takes an <span style="font-weight: bold">int</span> as n argument, and returns an <span style="font-weight: bold">int</span> value.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> next x = x + <span class="dv">1</span>;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> next <span class="dv">10</span>;;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> next : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">11</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">Calling next with an argument of a different type results in a type-checking error.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> next x = x + <span class="dv">1</span>;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> next <span class="fl">10.5</span>;;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> next : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>Line <span class="dv">1</span>, characters <span class="dv">6-10</span>:</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> |  next <span class="fl">10.5</span>;;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>          ^^^^</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>Error: The constant <span class="st">&quot;10.5&quot;</span> has <span class="kw">type</span> <span class="st">&quot;float&quot;</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>       but an expression was expected <span class="kw">of</span> <span class="kw">type</span> <span class="st">&quot;int&quot;</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><p><div class="SIntrapara">The following functions <span style="font-weight: bold">swap</span> and <span style="font-weight: bold">eq</span> are polymorphic function. The types <span style="font-weight: bold">&rsquo;a</span> and <span style="font-weight: bold">&rsquo;b</span> can be read as <span style="font-weight: bold">for all type a and b</span>
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* Swapping two values of a tuple (we will cover tuples later) *)</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> swap (x,y) = (y,x);;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> swap : &#39;a * &#39;b -&gt; &#39;b * &#39;a = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* Comparing other types *)</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> eq x y = x = y;; </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> eq <span class="dv">1</span> <span class="dv">2</span>;; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> eq <span class="st">&quot;hello&quot;</span> <span class="st">&quot;hello&quot;</span>;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> eq : &#39;a -&gt; &#39;a -&gt; <span class="dt">bool</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a># - : <span class="dt">bool</span> = <span class="kw">false</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">bool</span> = <span class="kw">true</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">The function <span style="font-weight: bold">eq</span>, take the arguments of any type as long as the two arguments have the same type.</div></p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* Adding two integers *)</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> add x y = x + y;;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> add : <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote><p><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> fn x = (<span class="dt">int_of_float</span> x) * <span class="dv">3</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> fn : <span class="dt">float</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* factorial function *)</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> <span class="kw">rec</span> fact n = </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> n = <span class="dv">0</span> <span class="kw">then</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>       <span class="dv">1</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>       n * fact (n<span class="dv">-1</span>);;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> fact : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* Sum of the first n natural numbers *)</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> <span class="kw">rec</span> sum n = </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> n == <span class="dv">0</span> <span class="kw">then</span> <span class="dv">0</span> <span class="kw">else</span> n + sum (n<span class="dv">-1</span>);;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> sum : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><h5 class="heading">1.13.5<tt>&nbsp;</tt><a name="(part._.Mutually_.Recusrive_.Functions)"></a>Mutually Recusrive Functions<span class="button-group"><a href="#(part._.Mutually_.Recusrive_.Functions)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Mutually recursive functions are functions that call each other (directly or indirectly). You define them using the <span style="font-weight: bold">and</span> keyword along with <span style="font-weight: bold">let rec</span>.</p><p><div class="SIntrapara">Suppose we want two functions, <span style="font-weight: bold">even</span> and <span style="font-weight: bold">odd</span>, to determine whether a number is even or odd, with <span style="font-weight: bold">even</span> calling <span style="font-weight: bold">odd</span> and <span style="font-weight: bold">odd</span> calling <span style="font-weight: bold">even</span>. We define them together using <span style="font-weight: bold">let rec ... and</span>
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> odd n = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> n == <span class="dv">0</span> <span class="kw">then</span> <span class="kw">false</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> even(n<span class="dv">-1</span>) </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> <span class="kw">and</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    even n = </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> n == <span class="dv">0</span> <span class="kw">then</span> <span class="kw">true</span> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>      <span class="kw">else</span> odd(n<span class="dv">-1</span>);;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> odd : <span class="dt">int</span> -&gt; <span class="dt">bool</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> even : <span class="dt">int</span> -&gt; <span class="dt">bool</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><h5 class="heading">1.13.6<tt>&nbsp;</tt><a name="(part._.Polymorphic_.Types)"></a>Polymorphic Types<span class="button-group"><a href="#(part._.Polymorphic_.Types)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>This says the function takes a list of any element type &lsquo;&rsquo;a&lsquo;, and returns something of that same type.
These are basically generic types in Java. &lsquo;&rsquo;a list&lsquo; is like &lsquo;List&lt;T&gt;&lsquo;.</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="dt">fst</span> x y = x;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="dt">fst</span> <span class="dv">1</span> <span class="st">&quot;hello&quot;</span>;; </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="dt">fst</span> [<span class="dv">1</span>; <span class="dv">2</span>] <span class="dv">1</span>;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> <span class="dt">fst</span> : &#39;a -&gt; &#39;b -&gt; &#39;a = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a># - : <span class="dt">int</span> = <span class="dv">1</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">1</span>; <span class="dv">2</span>]</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> eq x y = x = y;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> eq <span class="dv">1</span> <span class="dv">2</span>;; </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> eq <span class="st">&quot;hello&quot;</span> <span class="st">&quot;there&quot;</span>;; </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> eq <span class="st">&quot;hello&quot;</span> <span class="dv">1</span>;;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> eq : &#39;a -&gt; &#39;a -&gt; <span class="dt">bool</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a># - : <span class="dt">bool</span> = <span class="kw">false</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a># - : <span class="dt">bool</span> = <span class="kw">false</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>Line <span class="dv">1</span>, characters <span class="dv">12-13</span>:</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> |  eq <span class="st">&quot;hello&quot;</span> <span class="dv">1</span>;;</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>                ^</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>Error: The constant <span class="st">&quot;1&quot;</span> has <span class="kw">type</span> <span class="st">&quot;int&quot;</span> but an expression was expected <span class="kw">of</span> <span class="kw">type</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>         <span class="st">&quot;string&quot;</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote><h5 class="heading">1.13.7<tt>&nbsp;</tt><a name="(part._.Type_annotations)"></a>Type annotations<span class="button-group"><a href="#(part._.Type_annotations)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p><div class="SIntrapara">The OCaml compiler can infer types automatically, but type inference can be tricky and sometimes produces vague error messages. To avoid this, we can provide type annotations manually.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (x : <span class="dt">int</span>) = <span class="dv">3</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> x : <span class="dt">int</span> = <span class="dv">3</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> fn (x:<span class="dt">int</span>):<span class="dt">float</span> = (<span class="dt">float_of_int</span> x) *. <span class="fl">3.14</span>;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> add (x:<span class="dt">int</span>) (y:<span class="dt">int</span>):<span class="dt">int</span> = x + y;;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> fn : <span class="dt">int</span> -&gt; <span class="dt">float</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> add : <span class="dt">int</span> -&gt; <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> id x = x;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> id : &#39;a -&gt; &#39;a = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> id (x:<span class="dt">int</span>) = x;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> id : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><h4 class="heading">1.14<tt>&nbsp;</tt><a name="(part._.Lists)"></a>Lists<span class="button-group"><a href="#(part._.Lists)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p><div class="SIntrapara">The list is a fundamental data structure in OCaml. Lists can have arbitrary length and are implemented as linked structures. All elements in a list must be of the same type (i.e., lists are homogeneous). We will learn how to construct lists and deconstruct them using pattern matching.
In OCaml, <span style="font-weight: bold">[ ]</span> is a value, represents an empty list. Elements are separated by semicolons.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>[];; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">4</span>];; </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> [<span class="st">&quot;apple&quot;</span>; <span class="st">&quot;banana&quot;</span>; <span class="st">&quot;cherry&quot;</span>];;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a># - : &#39;a <span class="dt">list</span> = []</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a># - : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">4</span>]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">string</span> <span class="dt">list</span> = [<span class="st">&quot;apple&quot;</span>; <span class="st">&quot;banana&quot;</span>; <span class="st">&quot;cherry&quot;</span>]</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><p>To evaluate <span style="font-weight: bold">[e1; e1;...;en]</span>, we evaluate <span style="font-weight: bold">e1</span> to a value <span style="font-weight: bold">v1</span>, <span style="font-weight: bold">e2</span> to a value <span style="font-weight: bold">v2</span>, and <span style="font-weight: bold">en</span> to a value <span style="font-weight: bold">vn</span>, and return <span style="font-weight: bold">[v1;&#8230;;vn]</span>.</p><p>In OCaml, the list notation [e1; e2] is syntactic sugar for using the cons operator ::(pronounced &#8220;cons&#8221;). <span style="font-weight: bold">::</span> constructs a list by prepending an element to an existing list. Specifically:
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>[e1; e2];;  <span class="co">(* sugar syntax *)</span></span></code></pre></div>

is equivalent to:
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>e1 :: e2 :: [];;  <span class="co">(* desugared form *)</span></span></code></pre></div>
</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> y = [<span class="dv">1</span>; <span class="dv">1</span>+<span class="dv">1</span>; <span class="dv">1</span>+<span class="dv">1</span>+<span class="dv">1</span>] ;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> x = <span class="dv">4</span>::y ;; </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> z = <span class="dv">5</span>::y ;; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> m = <span class="st">&quot;hello&quot;</span> :: <span class="st">&quot;bob&quot;</span> ::[];;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> y : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> x : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">4</span>; <span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>]</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> z : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">5</span>; <span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>]</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> m : <span class="dt">string</span> <span class="dt">list</span> = [<span class="st">&quot;hello&quot;</span>; <span class="st">&quot;bob&quot;</span>]</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote><h5 class="heading">1.14.1<tt>&nbsp;</tt><a name="(part._.Typing_.Lists)"></a>Typing Lists<span class="button-group"><a href="#(part._.Typing_.Lists)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>The type of an empty list <span class="emph">[ ]</span> is <span style="font-weight: bold">&rsquo;a list</span>. The type of <span style="font-weight: bold">Cons</span> is
<span style="font-weight: bold">if e1 : t and e2 : t list then e1::e2 : t list</span>. If we add parentheses for clarity: <span style="font-weight: bold">if e1 : t</span> and <span style="font-weight: bold">e2 : (t list)</span> then <span style="font-weight: bold">(e1::e2) : (t list)</span>.</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> m = [[<span class="dv">1</span>];[<span class="dv">2</span>;<span class="dv">3</span>]];;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> m : <span class="dt">int</span> <span class="dt">list</span> <span class="dt">list</span> = [[<span class="dv">1</span>]; [<span class="dv">2</span>; <span class="dv">3</span>]]</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote><p><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> y = <span class="dv">0</span>::[<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>] ;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> y : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">0</span>; <span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>]</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = [<span class="dv">1</span>;<span class="st">&quot;world&quot;</span>] ;; <span class="co">(* all elements must have same type *)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>Line <span class="dv">1</span>, characters <span class="dv">11-18</span>:</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> | <span class="kw">let</span> x = [<span class="dv">1</span>;<span class="st">&quot;world&quot;</span>] ;; <span class="co">(* all elements must have same type *)</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>               ^^^^^^^</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>Error: This constant has <span class="kw">type</span> <span class="st">&quot;string&quot;</span> but an expression was expected <span class="kw">of</span> <span class="kw">type</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>         <span class="st">&quot;int&quot;</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><h5 class="heading">1.14.2<tt>&nbsp;</tt><a name="(part.____.Operator)"></a>:: Operator<span class="button-group"><a href="#(part.____.Operator)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p><div class="SIntrapara">&lsquo;::&lsquo; operator appends a single item, not a list, to the front of another list. The left argument of &lsquo;::&lsquo; is an element, the right is a list
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> y = <span class="dv">0</span>::[<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>] ;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> w = [<span class="dv">1</span>;<span class="dv">2</span>]::y ;; <span class="co">(* error *)</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> y : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">0</span>; <span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>]</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>Line <span class="dv">1</span>, characters <span class="dv">16-17</span>:</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> |  <span class="kw">let</span> w = [<span class="dv">1</span>;<span class="dv">2</span>]::y ;; <span class="co">(* error *)</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>                    ^</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>Error: The value <span class="st">&quot;y&quot;</span> has <span class="kw">type</span> <span class="st">&quot;int list&quot;</span> but an expression was expected <span class="kw">of</span> <span class="kw">type</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>         <span class="st">&quot;int list list&quot;</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>       Type <span class="st">&quot;int&quot;</span> is <span class="dt">not</span> compatible <span class="kw">with</span> <span class="kw">type</span> <span class="st">&quot;int list&quot;</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">Quiz: Can you construct a list y such that <span style="font-weight: bold">[1;2]::y</span> makes sense?</div></p><p>Yes. If the type of &lsquo;y&lsquo; is <span style="font-weight: bold">int list list</span>,i.e., <span style="font-weight: bold">[1;2]::[[3;4]]</span>. Each element of this list is an &lsquo;int list&lsquo;.</p><p>Lists in Ocaml are Linked. <span style="font-weight: bold">[1;2;3]</span> is represented as:
<img src="lists.png" alt="" width="536" height="211"/></p><p><div class="SIntrapara">A nonempty list is a <span style="font-weight: bold">pair (element, rest of list)</span>. The <span style="font-weight: bold">element</span> is the head of the list, and <span style="font-weight: bold">rest of the list</span>
 is itself a list. Thus in math (i.e., inductively) a list is either
</div><div class="SIntrapara"><ul><li><p>The empty list [ ]</p></li><li><p>Or a pair consisting of an element and a list</p></li></ul></div></p><p>This recursive structure will come in handy shortly</p><h5 class="heading">1.14.3<tt>&nbsp;</tt><a name="(part._.Lists_of_.Lists)"></a>Lists of Lists<span class="button-group"><a href="#(part._.Lists_of_.Lists)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p><div class="SIntrapara">Lists can be nested arbitrarily. For exmaple:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>[ [<span class="dv">9</span>; <span class="dv">10</span>; <span class="dv">11</span>]; [<span class="dv">5</span>; <span class="dv">4</span>; <span class="dv">3</span>; <span class="dv">2</span>] ];;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> <span class="dt">list</span> = [[<span class="dv">9</span>; <span class="dv">10</span>; <span class="dv">11</span>]; [<span class="dv">5</span>; <span class="dv">4</span>; <span class="dv">3</span>; <span class="dv">2</span>]]</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><p>The ype &lsquo;int list list&lsquo; can also be written as &lsquo;(int list) list&lsquo;.</p><p>Lists are immutable in OCaml; you cannot change an element of a list. Instead, you create new lists from existing ones, for example using the :: operator.</p><h4 class="heading">1.15<tt>&nbsp;</tt><a name="(part._.Pattern_.Matching)"></a>Pattern Matching<span class="button-group"><a href="#(part._.Pattern_.Matching)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>To pull lists apart, we use the &lsquo;match&lsquo; construct. The pattern-matching part of the
&lsquo;match&lsquo; is a sequence of clauses, each one of the form: <span style="font-weight: bold">pattern -&gt; expr</span>, separated by
vertical bars (|). The clauses are processed in order, and only the &lsquo;expr&lsquo; of first matching
 clause is evaluated. The value of the entire match expression is the value of the &lsquo;expr&lsquo;
 of the matching clause; If no &lsquo;pattern&lsquo; matches &lsquo;expr&lsquo;, your match is said to be
 &lsquo;non-exhaustive&lsquo; and when a match fails it raise the exception &lsquo;Match_failure&lsquo;.</p><p><div class="SIntrapara">The syntax of the match expressin is:
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">match</span> e <span class="kw">with</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>| p1 -&gt; e1 </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>| â€¦ </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>| pn -&gt; en</span></code></pre></div>

The type checking rules for the match expression:
Let t be the type of e.
</div><div class="SIntrapara"><ul><li><p>Each pattern pi must be a pattern of type t. (i.e., e and the patterns have same type)</p></li><li><p>Each branch expression ei must have the same type &#963;. So the whole match expression has type &#963;.</p></li></ul></div><div class="SIntrapara">For example: the function neg negates the boolean argument.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> neg x= </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> x <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    | <span class="kw">true</span> -&gt; <span class="kw">false</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    | <span class="kw">false</span> -&gt; <span class="kw">true</span>;; </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> neg <span class="kw">true</span>;; </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a> neg (<span class="dv">10</span> &gt; <span class="dv">20</span>);;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> neg : <span class="dt">bool</span> -&gt; <span class="dt">bool</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a># - : <span class="dt">bool</span> = <span class="kw">false</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">bool</span> = <span class="kw">true</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">The function is_zero checks if the argument is zero.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> is_zero n = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> n <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    | <span class="dv">0</span> -&gt; <span class="kw">true</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    | _ -&gt; <span class="kw">false</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> ;; </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> is_zero <span class="dv">1</span>;;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> is_zero : <span class="dt">int</span> -&gt; <span class="dt">bool</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">bool</span> = <span class="kw">false</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><p><div class="SIntrapara">The function <span style="font-weight: bold">is_odd</span> checks if a value is odd:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> is_odd x = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>          <span class="kw">match</span> x <span class="kw">mod</span> <span class="dv">2</span> <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>          <span class="dv">0</span> -&gt; <span class="kw">false</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>          | <span class="dv">1</span> -&gt; <span class="kw">true</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>          | _ -&gt; <span class="dt">raise</span> (<span class="dt">Invalid_argument</span> <span class="st">&quot;is_odd&quot;</span>);;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> is_odd : <span class="dt">int</span> -&gt; <span class="dt">bool</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">In <span style="font-weight: bold">is_odd</span>, why do we need the thrid match case <span style="font-weight: bold">| _ -&gt;</span>? Try -1 mod 2.</div></p><p><div class="SIntrapara">Logical implication
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> imply v = <span class="kw">match</span> v <span class="kw">with</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>                   (<span class="kw">true</span>,<span class="kw">true</span>)   -&gt; <span class="kw">true</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>             | (<span class="kw">true</span>,<span class="kw">false</span>)  -&gt; <span class="kw">false</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>             | (<span class="kw">false</span>,<span class="kw">true</span>)  -&gt; <span class="kw">true</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>             | (<span class="kw">false</span>,<span class="kw">false</span>) -&gt; <span class="kw">true</span>;;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> imply : <span class="dt">bool</span> * <span class="dt">bool</span> -&gt; <span class="dt">bool</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">Or, we can make it even simpler:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> imply v = <span class="kw">match</span> v <span class="kw">with</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">true</span>,x)  -&gt; x </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    | (<span class="kw">false</span>,x) -&gt; <span class="kw">true</span>;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> imply : <span class="dt">bool</span> * <span class="dt">bool</span> -&gt; <span class="dt">bool</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><p><div class="SIntrapara">For characters, OCaml also recognizes the range patterns in the form of &rsquo;c1&rsquo; .. &rsquo;cn&rsquo; as shorthand for any ASCII character in the range.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> is_vowel c = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>          <span class="kw">match</span> c <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>          (<span class="ch">&#39;a&#39;</span> | <span class="ch">&#39;e&#39;</span> | <span class="ch">&#39;i&#39;</span> | <span class="ch">&#39;o&#39;</span> | <span class="ch">&#39;u&#39;</span>) -&gt; <span class="kw">true</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>          | _ -&gt; <span class="kw">false</span>;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> is_vowel : <span class="dt">char</span> -&gt; <span class="dt">bool</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">Determine whether a character is uppercase:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> is_upper x = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> x <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="ch">&#39;A&#39;</span> .. <span class="ch">&#39;Z&#39;</span> -&gt; <span class="kw">true</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    | _ -&gt; <span class="kw">false</span>;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> is_upper : <span class="dt">char</span> -&gt; <span class="dt">bool</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><p>In OCaml, the underscore <span style="font-weight: bold">_</span> in a match is a wildcard pattern. It is like the default in the switch statement.
It matches anything, but doesn&#8217;t bind a variable to the value.</p><h5 class="heading">1.15.1<tt>&nbsp;</tt><a name="(part._.Pattern_.Matching_.Lists)"></a>Pattern Matching Lists<span class="button-group"><a href="#(part._.Pattern_.Matching_.Lists)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p><div class="SIntrapara">In OCaml, you can destruct lists using pattern matching by matching against the list constructors:
</div><div class="SIntrapara"><ul><li><p>[ ] represents the empty list.</p></li><li><p>h :: t (pronounced "head cons tail") represents a list with head element h and tail list t.</p></li></ul></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> is_empty l = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> l <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    | [] -&gt; <span class="kw">true</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    | h::t -&gt; <span class="kw">false</span>;; </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> is_empty [];; </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a> is_empty [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>];;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> is_empty : &#39;a <span class="dt">list</span> -&gt; <span class="dt">bool</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a># - : <span class="dt">bool</span> = <span class="kw">true</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">bool</span> = <span class="kw">false</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><p><div class="SIntrapara">Here are the primary techniques for destructuring lists with examples. Patterns can also be nested for more precise matches.
</div><div class="SIntrapara"><ul><li><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>a::b</span></code></pre></div>
 matches lists with <span style="font-weight: bold">at least one element</span>. For example:
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">match</span> [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>] <span class="kw">with</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> |a::b</span></code></pre></div>

matches and binds &lsquo;a&lsquo; to &lsquo;1&lsquo; and &lsquo;b&lsquo; to &lsquo;[2;3]&lsquo;</p></li><li><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>a::[]</span></code></pre></div>
 matches lists with <span style="font-weight: bold">exactly one element</span>. For example:
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">match</span> [<span class="dv">1</span>] <span class="kw">with</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>| a::[]</span></code></pre></div>

 binds &lsquo;a&lsquo; to &lsquo;1&lsquo;. we could also write pattern <span style="font-weight: bold">a::[]</span> as <span style="font-weight: bold">[a]</span></p></li><li><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>a::b::[]</span></code></pre></div>
 matches lists with <span style="font-weight: bold">exactly two elements</span>. For example:
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">match</span> [<span class="dv">1</span>;<span class="dv">2</span>] <span class="kw">with</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>|a::b::[]</span></code></pre></div>

 binds &lsquo;a&lsquo; to 1 and &lsquo;b&lsquo; to 2. We could also write pattern <span style="font-weight: bold">a::b::[]</span> as <span style="font-weight: bold">[a;b]</span></p></li><li><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>a::b::c::d</span></code></pre></div>
 matches lists with bold{at least three elements}. For example:
  <div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">match</span> [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>] <span class="kw">with</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>|a::b::c::d</span></code></pre></div>

binds &lsquo;a&lsquo; to &lsquo;1&lsquo;, &lsquo;b&lsquo; to &lsquo;2&lsquo;, &lsquo;c&lsquo; to &lsquo;3&lsquo;, and &lsquo;d&lsquo; to &lsquo;[]&lsquo;.</p></li></ul></div></p><p>OCaml can detect non-exhaustive patterns and warn you about them. For example:
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> hd l = <span class="kw">match</span> l <span class="kw">with</span> (h::_) -&gt; h;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>Warning: this pattern-matching is <span class="dt">not</span> exhaustive.</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>Here is an example <span class="kw">of</span> a value that is <span class="dt">not</span> matched: []</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a># hd [];;</span></code></pre></div>
</p><p>Therefore, You can&#8217;t forget a case because compiler issues inexhaustive
pattern-match warning. You can&#8217;t duplicate a case because compiler issues
unused match case warning. Pattern matching leads to elegant, concise, beautiful code .</p><p>Quiz: Can write pattern as [a;b;c]::d (why?)</p><p>An underscore <span style="font-weight: bold">_</span> is a wildcard pattern. It matches anything, but doesn&#8217;t add any bindings. It is useful to
hold a place but discard the value i.e., when the variable does not appear in the branch expression.</p><p>In the earlier examples, many values of h or t were unused. In such cases, we can replace them with the wildcard _.
 For example, in the <span style="font-weight: bold">is_empty</span>, the h and t bindings are unused. We can replace them with <span style="font-weight: bold">_</span>.</p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* cehck if a list is empty *)</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> is_empty l = </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> l <span class="kw">with</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    | [] -&gt; <span class="kw">true</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    | _::_ -&gt; <span class="kw">false</span>;; </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a> is_empty [];; </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a> is_empty [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>];; </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a> is_empty [<span class="st">&quot;a&quot;</span>; <span class="st">&quot;b&quot;</span>; <span class="st">&quot;c&quot;</span>]</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> is_empty : &#39;a <span class="dt">list</span> -&gt; <span class="dt">bool</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a># - : <span class="dt">bool</span> = <span class="kw">true</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a># - : <span class="dt">bool</span> = <span class="kw">false</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>Line <span class="dv">1</span>, characters <span class="dv">25-25</span>:</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>Error: Syntax error</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote><p><div class="SIntrapara">Let&#8217;s define a function that computes the sum of all elements in an <span style="font-weight: bold">int list</span>.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> sum l = <span class="kw">match</span> l <span class="kw">with</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>      [] -&gt; <span class="dv">0</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    | (h::t) -&gt; h + (sum t);; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    sum [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>;<span class="dv">4</span>];;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> sum : <span class="dt">int</span> <span class="dt">list</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">10</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><p>The <span style="font-weight: bold">sum</span> function works only for int lists, but the <span style="font-weight: bold">is_empty</span> function works for any type of list.
OCaml gives such functions polymorphic types. <pre class="ocml"><code>is_empty : &#39;a list -&gt; bool</code></pre>
</p><h5 class="heading">1.15.2<tt>&nbsp;</tt><a name="(part._.Pattern_.Matching_~e2~80~93_.An_.Abbreviation)"></a>Pattern Matching &#8211; An Abbreviation<span class="button-group"><a href="#(part._.Pattern_.Matching_~e2~80~93_.An_.Abbreviation)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p><div class="SIntrapara">If there&#8217;s only one acceptable input, the pattern matching <div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f x = <span class="kw">match</span> x <span class="kw">with</span> p -&gt; e</span></code></pre></div>

can be abbreviated to <div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f p = e</span></code></pre></div>

</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="dt">fst</span> pair = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> pair <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    | (x, _) -&gt; x;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="dt">fst</span> : &#39;a * &#39;b -&gt; &#39;a = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">You can abbreviate by putting the pattern directly in the function parameter:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="dt">fst</span> (x, _) = x;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> <span class="dt">fst</span> : &#39;a * &#39;b -&gt; &#39;a = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><p><div class="SIntrapara">With the <span style="font-weight: bold">function</span> keyword, you can abbreviate <div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f x = <span class="kw">match</span> x <span class="kw">with</span> ...</span></code></pre></div>
 to
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f = <span class="kw">function</span></span></code></pre></div>
 We can abbreviate
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f x = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> x <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    | <span class="dv">0</span> -&gt; <span class="st">&quot;zero&quot;</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    | <span class="dv">1</span> -&gt; <span class="st">&quot;one&quot;</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    | _ -&gt; <span class="st">&quot;many&quot;</span>;;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> f : <span class="dt">int</span> -&gt; <span class="dt">string</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">to
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f = <span class="kw">function</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    | <span class="dv">0</span> -&gt; <span class="st">&quot;zero&quot;</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    | <span class="dv">1</span> -&gt; <span class="st">&quot;one&quot;</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    | _ -&gt; <span class="st">&quot;many&quot;</span>;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> f : <span class="dt">int</span> -&gt; <span class="dt">string</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><h4 class="heading">1.16<tt>&nbsp;</tt><a name="(part._.Lists_and_.Recursion)"></a>Lists and Recursion<span class="button-group"><a href="#(part._.Lists_and_.Recursion)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p><div class="SIntrapara">Lists have a recursive structure and so most functions over lists will be recursive.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> length l = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> l <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    |[] -&gt; <span class="dv">0</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    | (_::t) -&gt; <span class="dv">1</span> + (length t);; </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    length [<span class="dv">1</span>;<span class="dv">3</span>;<span class="dv">6</span>;<span class="dv">9</span>];;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> length : &#39;a <span class="dt">list</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">4</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">This is just like an inductive definition:
</div><div class="SIntrapara"><ul><li><p>The length of the empty list is zero</p></li><li><p>The length of a nonempty list is 1 plus the length of the tail.</p></li></ul></div></p><p><div class="SIntrapara">Negate elements in list
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> negate l = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>          <span class="kw">match</span> l <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>       [] -&gt; [] </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>       | (h::t) -&gt; (-h) :: (negate t);; </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> negate [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">-10</span>];;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> negate : <span class="dt">int</span> <span class="dt">list</span> -&gt; <span class="dt">int</span> <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">-1</span>; <span class="dv">-2</span>; <span class="dv">10</span>]</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><p><div class="SIntrapara">Get the last element of a list
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> last l = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> l <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    | []-&gt;[] </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    |  [x] -&gt; [x] </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    | (h::t) -&gt; last t;; </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    last [];; </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    last [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>;<span class="dv">4</span>];;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> last : &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a># - : &#39;a <span class="dt">list</span> = []</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">4</span>]</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><p><div class="SIntrapara">Append two lists, that is, produce a list containing all elements of l followed by all elements of m.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> append l m = <span class="kw">match</span> l <span class="kw">with</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>     [] -&gt; m </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>   | (h::t) -&gt; h::(append t m);; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>     append [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>] [<span class="dv">4</span>;<span class="dv">5</span>;<span class="dv">6</span>];; </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a> <span class="co">(* Reversing a list *)</span> </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> <span class="kw">rec</span> rev l = <span class="kw">match</span> l <span class="kw">with</span> </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>      [] -&gt; [] </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    | (h::t) -&gt; append (rev t) [h];; </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    rev [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>;<span class="dv">4</span>];;</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> append : &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a># - : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">4</span>; <span class="dv">5</span>; <span class="dv">6</span>]</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> rev : &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">4</span>; <span class="dv">3</span>; <span class="dv">2</span>; <span class="dv">1</span>]</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">&lsquo;rev&lsquo; takes O(n2) time.  Can you do better? Here is a  clever version of reverse
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> rev_helper l a = <span class="kw">match</span> l <span class="kw">with</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    [] -&gt; a </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    | (x::xs) -&gt; rev_helper xs (x::a);; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> rev l = rev_helper l [];; </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a> rev [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>;<span class="dv">4</span>];;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> rev_helper : &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> rev : &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">4</span>; <span class="dv">3</span>; <span class="dv">2</span>; <span class="dv">1</span>]</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">Let&#8217;s give it a try
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>rev [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>] â†’</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>rev_helper [<span class="dv">1</span>;<span class="dv">2</span>;<span class="dv">3</span>] [] â†’</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>rev_helper [<span class="dv">2</span>;<span class="dv">3</span>] [<span class="dv">1</span>] â†’</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>rev_helper [<span class="dv">3</span>] [<span class="dv">2</span>;<span class="dv">1</span>] â†’</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>rev_helper [] [<span class="dv">3</span>;<span class="dv">2</span>;<span class="dv">1</span>] â†’</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>[<span class="dv">3</span>;<span class="dv">2</span>;<span class="dv">1</span>]</span></code></pre></div>
</div></p><p><div class="SIntrapara">Check if x is member of a list
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> member lst x= </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">match</span> lst <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>                  |[]-&gt;<span class="kw">false</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>                  |h::t-&gt;<span class="kw">if</span> h = x <span class="kw">then</span> <span class="kw">true</span> <span class="kw">else</span> member t x </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>          ;;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> member : &#39;a <span class="dt">list</span> -&gt; &#39;a -&gt; <span class="dt">bool</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><p><div class="SIntrapara">Merge two sorted lists into one sorted list
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> merge l1 l2 = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> l1,l2 <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>     [],l-&gt;l </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>     |l,[]-&gt;l </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>     |(h1::t1, h2::t2)-&gt; </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>          <span class="kw">if</span> h1 &lt; h2 <span class="kw">then</span> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>            h1::merge t1 l2 </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>          <span class="kw">else</span> </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>            h2::merge l1 t2;; </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a> merge [<span class="dv">1</span>;<span class="dv">3</span>;<span class="dv">7</span>;<span class="dv">9</span>] [<span class="dv">2</span>;<span class="dv">3</span>;<span class="dv">4</span>;<span class="dv">5</span>;<span class="dv">6</span>];;</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> merge : &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>; <span class="dv">3</span>; <span class="dv">4</span>; <span class="dv">5</span>; <span class="dv">6</span>; <span class="dv">7</span>; <span class="dv">9</span>]</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><p><div class="SIntrapara">Insert x into a sorted list l in sorted order
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> insert x l= </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>          <span class="kw">match</span> l <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>          |[]-&gt;[x] </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>          |h::t-&gt;<span class="kw">if</span> x &lt; h <span class="kw">then</span> x::h::t </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>                          <span class="kw">else</span> h::insert x t;; </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    insert <span class="dv">10</span> [<span class="dv">5</span>;<span class="dv">9</span>;<span class="dv">20</span>;<span class="dv">30</span>];;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> insert : &#39;a -&gt; &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">5</span>; <span class="dv">9</span>; <span class="dv">10</span>; <span class="dv">20</span>; <span class="dv">30</span>]</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><p><div class="SIntrapara">Insertion sort
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> insert x l= </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>          <span class="kw">match</span> l <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>          |[]-&gt;[x] </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>          |h::t-&gt;<span class="kw">if</span> x &lt; h <span class="kw">then</span> x::h::t </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>                          <span class="kw">else</span> h::insert x t;; </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> <span class="kw">rec</span> sort l = </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">match</span> l <span class="kw">with</span> </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>                  []-&gt;[] </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>                  |[x]-&gt;[x] </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>                  |h::t-&gt;insert h (sort t);; </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a> sort [<span class="dv">1</span>;<span class="dv">6</span>;<span class="dv">2</span>;<span class="dv">10</span>;<span class="dv">-5</span>];;</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> insert : &#39;a -&gt; &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> sort : &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">-5</span>; <span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">6</span>; <span class="dv">10</span>]</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><p><div class="SIntrapara">QuickSort
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> qsort = <span class="kw">function</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>        | [] -&gt; []</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        | pivot :: rest -&gt;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> left, right = <span class="dt">List</span>.partition (<span class="kw">fun</span> x-&gt; x &lt; pivot) rest <span class="kw">in</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    qsort left @ [pivot] @ qsort right;;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> </span></code></pre></div>

MergeSort
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(** split list a into two even parts *)</span> </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> split a = </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">rec</span> aux lst b c = </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">match</span> lst <span class="kw">with</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>                    [] -&gt; (b, c) </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>                  | hd :: tail -&gt; aux tail c (hd :: b) </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>          <span class="kw">in</span> aux a [] [];; </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a> <span class="co">(* merge lists xs and ys *)</span> </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> <span class="kw">rec</span> merge cmp xs ys = </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">match</span> (xs, ys) <span class="kw">with</span> </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>                    ([], []) -&gt; [] </span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>                  | (_, []) -&gt; xs </span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>                  | ([], _) -&gt; ys </span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>                  | (xhd :: xtail, yhd :: ytail) -&gt; </span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">if</span> (cmp xhd yhd) <span class="kw">then</span> </span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>                          xhd :: (merge cmp xtail ys) </span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>            <span class="kw">else</span> </span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>                          yhd :: (merge cmp xs ytail);; </span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> <span class="kw">rec</span> mergesort cmp os  = </span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">match</span> os <span class="kw">with</span> </span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>                  [] -&gt; [] </span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>                  | [x] -&gt; [x] </span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>                  | _ -&gt; </span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">let</span> (ls, rs) = split os <span class="kw">in</span> </span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>          merge cmp (mergesort cmp ls) (mergesort cmp rs);; </span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> lt a b = a &lt; b;; </span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>    mergesort lt [<span class="dv">1</span>;<span class="dv">6</span>;<span class="dv">2</span>;<span class="dv">10</span>;<span class="dv">-5</span>];;</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> split : &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> * &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> merge : (&#39;a -&gt; &#39;a -&gt; <span class="dt">bool</span>) -&gt; &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> mergesort : (&#39;a -&gt; &#39;a -&gt; <span class="dt">bool</span>) -&gt; &#39;a <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> lt : &#39;a -&gt; &#39;a -&gt; <span class="dt">bool</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> <span class="dt">list</span> = [<span class="dv">-5</span>; <span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">6</span>; <span class="dv">10</span>]</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><h4 class="heading">1.17<tt>&nbsp;</tt><a name="(part.__.Let_.Expressions)"></a> Let Expressions<span class="button-group"><a href="#(part.__.Let_.Expressions)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>In OCaml, a let expression binds a name to a value.
Its general form is:</p><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = e1 <span class="kw">in</span> e2</span></code></pre></div>
</p><p><div class="SIntrapara">In this construct:
</div><div class="SIntrapara"><ul><li><p>x is the bound variable</p></li><li><p>e1 is the binding expression</p></li><li><p>e2 is the body expression in which the binding is visible.</p></li></ul></div></p><p><div class="SIntrapara">To evaluate a let expression:
</div><div class="SIntrapara"><ul><li><p>Evaluate e1 to v1</p></li><li><p>Substitute <span style="font-weight: bold">v1</span> for <span style="font-weight: bold">x</span> in <span style="font-weight: bold">e2</span>, yielding new expression <span style="font-weight: bold">e2&rsquo;</span></p></li><li><p>Evaluate <span style="font-weight: bold">e2&#8217;</span> to <span style="font-weight: bold">v2</span>, the final result</p></li></ul></div><div class="SIntrapara">. For exmple:
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = <span class="dv">20</span> + <span class="dv">1</span> <span class="kw">in</span> x + x </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = <span class="dv">21</span> <span class="kw">in</span> x + x <span class="co">(* evaluate e1, 20+1 ==&gt; 21)</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co">21 + 21 (* Substitute 21 for x in e2 *) </span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co">42</span></span></code></pre></div>

Here is the type checking rules for the let expression:</div></p><p>If <span style="font-weight: bold">e1 : t1</span> and if assuming <span style="font-weight: bold">x : t1</span> implies <span style="font-weight: bold">e2 : t</span> then <span style="font-weight: bold">(let x = e1 in e2) : t</span></p><h5 class="heading">1.17.1<tt>&nbsp;</tt><a name="(part._.Let_.Definitions_vs__.Let_.Expressions_)"></a>Let Definitions vs. Let Expressions <span class="button-group"><a href="#(part._.Let_.Definitions_vs__.Let_.Expressions_)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p><div class="SIntrapara">At the top level (in utop), we write <span style="font-weight: bold">let x = e;;</span>. Notice that there
is no in e2 part, unlike with a <span style="font-weight: bold">let expression</span>.
This is called a <span style="font-weight: bold">let definition</span>. The difference is that a
let definition does not itself produce a value when evaluated;
instead, it installs a new name into the top-level environment.
In other words, by omitting <span style="font-weight: bold">in</span>, we are saying &#8220;<span style="font-weight: bold">from now on</span>,
 the name x refers to the result of evaluating e.&#8221;
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> pi = <span class="fl">3.14</span>;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="co">(* pi is now bound in the rest of the top-level scope *)</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> pi : <span class="dt">float</span> = <span class="fl">3.14</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">We can write any expression at top-level, too
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>e;;</span></code></pre></div>

This says to evaluate <span style="font-weight: bold">e</span> and then ignore the result. It is equivalent to
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> _ = e;;</span></code></pre></div>

Useful when &lsquo;e&lsquo; has a side effect, such as reading/writing a file, printing to the screen, etc.</div></p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = <span class="dv">37</span>;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> y = x + <span class="dv">5</span>;; </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="dt">print_int</span> y;; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> <span class="dt">print_string</span> <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> x : <span class="dt">int</span> = <span class="dv">37</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> y : <span class="dt">int</span> = <span class="dv">42</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a># <span class="dv">42</span>- : <span class="dt">unit</span> = ()</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">unit</span> = ()</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote><h5 class="heading">1.17.2<tt>&nbsp;</tt><a name="(part._.Let_.Expressions__.Scope)"></a>Let Expressions: Scope<span class="button-group"><a href="#(part._.Let_.Expressions__.Scope)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p><div class="SIntrapara">In <span style="font-weight: bold">let x = e1 in e2</span>, variable <span style="font-weight: bold">x</span> is not visible outside of <span style="font-weight: bold">e2</span>. For example:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> pi = <span class="fl">3.14</span> <span class="kw">in</span> pi *. <span class="fl">3.0</span> *. <span class="fl">3.0</span>;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="dt">print_float</span> pi;;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a># - : <span class="dt">float</span> = <span class="fl">28.259999999999998</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>Line <span class="dv">1</span>, characters <span class="dv">13-15</span>:</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> |  <span class="dt">print_float</span> pi;;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>                 ^^</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>Error: Unbound value <span class="st">&quot;pi&quot;</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">Here, it binds <span style="font-weight: bold">pi</span> (only) in body of let (which is <span style="font-weight: bold">pi *. 3.0 *. 3.0</span>). Outside <span style="font-weight: bold">e2</span>,
the var <span style="font-weight: bold">x</span> is not visible. After <span style="font-weight: bold">e2</span> <span style="font-weight: bold">(pi *. 3.0 *. 3.0)</span> is evalued, <span style="font-weight: bold">pi</span>
 is out of scope. Therefore, <span style="font-weight: bold">print_float pi;;</span> shows <span style="font-weight: bold">pi not bound error</span>.
 This is similar to the scoping in C/JAVA.
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">float</span> pi <span class="op">=</span> <span class="fl">3.14</span><span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  pi <span class="op">*</span> <span class="fl">3.0</span> <span class="op">*</span> <span class="fl">3.0</span><span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>pi<span class="op">;</span> <span class="co">/* pi unbound! */</span></span></code></pre></div>

After the curly bracket, <span style="font-weight: bold">pi</span> is not visible.</div></p><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>x;; <span class="co">(* Unbound value x *)</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = <span class="dv">1</span> <span class="kw">in</span> x + <span class="dv">1</span>;;  <span class="co">(* 2 *)</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = x <span class="kw">in</span> x + <span class="dv">1</span>;; <span class="co">(* Unbound value x *)</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = <span class="dv">1</span> <span class="kw">in</span>  x + <span class="dv">1</span> + x   ;;    <span class="co">(* 3 *)</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>(<span class="kw">let</span> x = <span class="dv">1</span> <span class="kw">in</span> x + <span class="dv">1</span>) ;;  x;;   <span class="co">(* Unbound value x *)</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = <span class="dv">4</span> <span class="kw">in</span> (<span class="kw">let</span> x = x + <span class="dv">1</span> <span class="kw">in</span> x) </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>             <span class="kw">let</span> x = <span class="dv">4</span> + <span class="dv">1</span> <span class="kw">in</span> x</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>             <span class="kw">let</span> x = <span class="dv">5</span> <span class="kw">in</span> x</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>             <span class="dv">5</span></span></code></pre></div>
</p><h5 class="heading">1.17.3<tt>&nbsp;</tt><a name="(part._.Nested_.Let_.Expressions)"></a>Nested Let Expressions<span class="button-group"><a href="#(part._.Nested_.Let_.Expressions)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p><div class="SIntrapara">Uses of let can be nested
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> res = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">let</span> area = </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">let</span> pi = <span class="fl">3.14</span> <span class="kw">in</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> r = <span class="fl">3.0</span> <span class="kw">in</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>      pi *. r *. r) <span class="kw">in</span> </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>      <span class="co">(* pi and r are not visble here *)</span> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    area /. <span class="fl">2.0</span>);; </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">(* area is not visible here *)</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> res : <span class="dt">float</span> = <span class="fl">14.129999999999999</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">Similar scoping possibilities C and Java
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> res<span class="op">;</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span> <span class="dt">float</span> area<span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span> <span class="dt">float</span> pi <span class="op">=</span> <span class="fl">3.14</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> r <span class="op">=</span> <span class="fl">3.0</span><span class="op">;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    area <span class="op">=</span> pi <span class="op">*</span> r <span class="op">*</span> r<span class="op">;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span>  <span class="co">// p and r are not visible here.</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  res <span class="op">=</span> area <span class="op">/</span> <span class="fl">2.0</span><span class="op">;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="co">// area is not visible here</span></span></code></pre></div>

You should generally avoid nested let Style. Sometimes a nested binding
can be rewritten in a more linear style to make the code easier to understand. For example:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> res = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">let</span> area = </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>      (<span class="kw">let</span> pi = <span class="fl">3.14</span> <span class="kw">in</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> r = <span class="fl">3.0</span> <span class="kw">in</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>      pi *. r *. r) <span class="kw">in</span> </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    area /. <span class="fl">2.0</span>);;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> res : <span class="dt">float</span> = <span class="fl">14.129999999999999</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">can be written as
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> res = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> pi = <span class="fl">3.14</span> <span class="kw">in</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> r = <span class="fl">3.0</span> <span class="kw">in</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> area = pi *. r *. r <span class="kw">in</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    area /. <span class="fl">2.0</span>;;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> res : <span class="dt">float</span> = <span class="fl">14.129999999999999</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><h5 class="heading">1.17.4<tt>&nbsp;</tt><a name="(part._.Let_.Expressions_in_.Functions)"></a>Let Expressions in Functions<span class="button-group"><a href="#(part._.Let_.Expressions_in_.Functions)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p><div class="SIntrapara">You can use let inside of functions for local variables:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> area d = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> pi = <span class="fl">3.14</span> <span class="kw">in</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> r = d /. <span class="fl">2.0</span> <span class="kw">in</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> square x = x *. x <span class="kw">in</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    pi *. (square r);; </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> area <span class="fl">10.0</span>;;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> area : <span class="dt">float</span> -&gt; <span class="dt">float</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">float</span> = <span class="fl">78.5</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><h5 class="heading">1.17.5<tt>&nbsp;</tt><a name="(part._.Shadowing_.Names)"></a>Shadowing Names<span class="button-group"><a href="#(part._.Shadowing_.Names)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p><div class="SIntrapara">Shadowing is rebinding a name in an inner scope to have a different meaning.
Some lagnauges such as java does not allow it. For example:
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f<span class="op">(</span><span class="dt">float</span> i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="op">*</span>i <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span> <span class="co">// Here i refer to the inner character variable.</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span> <span class="co">// Here, i refers to the global integer variable</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>

Similarly, OCaml allows shadowing variables:
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = <span class="dv">3</span>+<span class="dv">4</span> <span class="kw">in</span> <span class="kw">let</span> x = <span class="dv">3</span>*x <span class="kw">in</span> x+<span class="dv">1</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = <span class="dv">7</span> <span class="kw">in</span> <span class="kw">let</span> x = <span class="dv">3</span>*x <span class="kw">in</span> x+<span class="dv">1</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = <span class="dv">3</span>*<span class="dv">7</span> <span class="kw">in</span> x+<span class="dv">1</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = <span class="dv">21</span> <span class="kw">in</span> x+<span class="dv">1</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="dv">21</span>+<span class="dv">1</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="dv">22</span></span></code></pre></div>

In this example, the <span style="font-weight: bold">x</span> in the inner <span style="font-weight: bold">let</span> expression <span style="font-weight: bold">let x = 3*x in x+1</span>
 shadows the <span style="font-weight: bold">x</span> in outer <span style="font-weight: bold">let</span> expression  <span style="font-weight: bold">let x = 3+4 in ...</span>
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x = <span class="dv">10</span> <span class="kw">in</span> (<span class="kw">let</span> x = x*<span class="dv">2</span> <span class="kw">in</span> x * x);; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="co">(* inner x shadows the outer x. It is same as *)</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> x = <span class="dv">10</span> <span class="kw">in</span> (<span class="kw">let</span> y = x*<span class="dv">2</span> <span class="kw">in</span> y * y);;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a># - : <span class="dt">int</span> = <span class="dv">400</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">400</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><h4 class="heading">1.18<tt>&nbsp;</tt><a name="(part._.Tuples)"></a>Tuples<span class="button-group"><a href="#(part._.Tuples)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>A tuple is an ordered sequence of n values written in parenthesis and separated by
commas as <span style="font-weight: bold">(e1, e2, ..., en)</span>. For instance, <span style="font-weight: bold">(330, "hello", true)</span> is a 3-tuple that
contains the integer &lsquo;42&lsquo; as its first component, the string &lsquo;"hello"&lsquo; as its second
component, and the boolean value &lsquo;true&lsquo; as its third component. <span style="font-weight: bold">()</span> denotes the empty
tuple with &lsquo;0&lsquo; element. It is called <span style="font-weight: bold">unit</span> in OCaml.</p><p><div class="SIntrapara">Tuple types use <span style="font-weight: bold">*</span> to separate the type of its components. For example:
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>(<span class="dv">1</span>, <span class="dv">2</span>) : (<span class="dt">int</span> * <span class="dt">int</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>(<span class="dv">1</span>, <span class="st">&quot;string&quot;</span>, <span class="fl">3.5</span>) : <span class="dt">int</span> * <span class="dt">string</span> * <span class="dt">float</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>(<span class="dv">1</span>, [<span class="st">&quot;a&quot;</span>; <span class="st">&quot;b&quot;</span>], <span class="ch">&#39;c&#39;</span>) :<span class="dt">int</span> * <span class="dt">string</span> <span class="dt">list</span> * <span class="dt">char</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>[(<span class="dv">1</span>,<span class="dv">2</span>)] : (<span class="dt">int</span> * <span class="dt">int</span>) <span class="dt">list</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>[(<span class="dv">1</span>, <span class="dv">2</span>); (<span class="dv">3</span>, <span class="dv">4</span>)] :(<span class="dt">int</span> * <span class="dt">int</span>) <span class="dt">list</span></span></code></pre></div>

Tuples are fixed size. The following code does not type check
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> foo x = </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">match</span> x <span class="kw">with</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    (a, b) -&gt; a + b </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    |(a, b, c) -&gt; a + b + c;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>Line <span class="dv">4</span>, characters <span class="dv">5-14</span>:</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="dv">4</span> |     |(a, b, c) -&gt; a + b + c;;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>         ^^^^^^^^^</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>Error: This pattern matches values <span class="kw">of</span> <span class="kw">type</span> <span class="st">&quot;&#39;a * &#39;b * &#39;c&quot;</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>       but a pattern was expected which matches values <span class="kw">of</span> <span class="kw">type</span> <span class="st">&quot;&#39;d * &#39;e&quot;</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">because the pattern <span style="font-weight: bold">(a,b)</span> has the type <span style="font-weight: bold">int * int</span>, and the second
pattern has the type <span style="font-weight: bold">int * int * int</span>, but all the pattern expressions in
a <span style="font-weight: bold">match</span> must have a same type.</div></p><h5 class="heading">1.18.1<tt>&nbsp;</tt><a name="(part._.Pattern_.Matching_.Tuples)"></a>Pattern Matching Tuples<span class="button-group"><a href="#(part._.Pattern_.Matching_.Tuples)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p><div class="SIntrapara">In OCaml, you can use pattern matching on tuples to directly unpack their components.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> plus3 t = <span class="kw">match</span> t <span class="kw">with</span> (x, y, z) -&gt; x + y + z;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> plus3(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>);;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> plus3 : <span class="dt">int</span> * <span class="dt">int</span> * <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">6</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> plus3&#39; (x, y, z) = x + y + z;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> plus3&#39;(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>);;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> plus3&#39; : <span class="dt">int</span> * <span class="dt">int</span> * <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">6</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> addOne (x, y, z) = (x+<span class="dv">1</span>, y+<span class="dv">1</span>, z+<span class="dv">1</span>);; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> addOne(<span class="dv">10</span>,<span class="dv">20</span>,<span class="dv">30</span>);;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> addOne : <span class="dt">int</span> * <span class="dt">int</span> * <span class="dt">int</span> -&gt; <span class="dt">int</span> * <span class="dt">int</span> * <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> * <span class="dt">int</span> * <span class="dt">int</span> = (<span class="dv">11</span>, <span class="dv">21</span>, <span class="dv">31</span>)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote><p><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> sum ((a, b), c) = (a+c, b+c);; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> sum ((<span class="dv">1</span>, <span class="dv">2</span>), <span class="dv">3</span>) = (<span class="dv">4</span>, <span class="dv">5</span>);;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> sum : (<span class="dt">int</span> * <span class="dt">int</span>) * <span class="dt">int</span> -&gt; <span class="dt">int</span> * <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">bool</span> = <span class="kw">true</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> plusFirstTwo (x::y::_, a) = (x + a, y + a);; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> plusFirstTwo ([<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>], <span class="dv">4</span>) = (<span class="dv">5</span>, <span class="dv">6</span>);;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a># Line <span class="dv">1</span>, characters <span class="dv">17-29</span>:</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> | <span class="kw">let</span> plusFirstTwo (x::y::_, a) = (x + a, y + a);; </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>                     ^^^^^^^^^^^^</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>Warning <span class="dv">8</span> [partial-<span class="kw">match</span>]: this pattern-matching is <span class="dt">not</span> exhaustive.</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>Here is an example <span class="kw">of</span> a case that is <span class="dt">not</span> matched:</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>(x::[], _)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> plusFirstTwo : <span class="dt">int</span> <span class="dt">list</span> * <span class="dt">int</span> -&gt; <span class="dt">int</span> * <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">bool</span> = <span class="kw">true</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> tls (_::xs, _::ys) = (xs, ys);; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> tls ([<span class="dv">1</span>; <span class="dv">2</span>; <span class="dv">3</span>], [<span class="dv">4</span>; <span class="dv">5</span>; <span class="dv">6</span>; <span class="dv">7</span>]) = ([<span class="dv">2</span>; <span class="dv">3</span>], [<span class="dv">5</span>; <span class="dv">6</span>; <span class="dv">7</span>]);;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a># Line <span class="dv">1</span>, characters <span class="dv">8-22</span>:</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> | <span class="kw">let</span> tls (_::xs, _::ys) = (xs, ys);; </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>            ^^^^^^^^^^^^^^</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>Warning <span class="dv">8</span> [partial-<span class="kw">match</span>]: this pattern-matching is <span class="dt">not</span> exhaustive.</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>Here is an example <span class="kw">of</span> a case that is <span class="dt">not</span> matched:</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>(_::xs, [])</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> tls : &#39;a <span class="dt">list</span> * &#39;b <span class="dt">list</span> -&gt; &#39;a <span class="dt">list</span> * &#39;b <span class="dt">list</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">bool</span> = <span class="kw">true</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><h4 class="heading">1.19<tt>&nbsp;</tt><a name="(part._.Records)"></a>Records<span class="button-group"><a href="#(part._.Records)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p><div class="SIntrapara">A record represents a collection of values stored together as one, where each
component is identified by a different field name. The syntax for a record type declaration is as follows:
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> &lt;record-name&gt; =</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    { &lt;field&gt; : &lt;<span class="kw">type</span>&gt;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>      &lt;field&gt; : &lt;<span class="kw">type</span>&gt;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>      ...</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div>

For example, we can define a record type &lsquo;date&lsquo; as:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> date = { month: <span class="dt">string</span>; day: <span class="dt">int</span>; year: <span class="dt">int</span> } </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="co">(* Now, we can define a record: *)</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> today = { day = <span class="dv">16</span>; year = <span class="dv">2017</span>; month = <span class="st">&quot;f&quot;</span> ^ <span class="st">&quot;eb&quot;</span> };;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> date = { month : <span class="dt">string</span>; day : <span class="dt">int</span>; year : <span class="dt">int</span>; }</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> today : date = {month = <span class="st">&quot;feb&quot;</span>; day = <span class="dv">16</span>; year = <span class="dv">2017</span>}</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">We can access the components of a record by field name or pattern matching:
field name:
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">print_string</span> today.month;; <span class="co">(* prints feb *)</span></span></code></pre></div>
</div></p><p><div class="SIntrapara">pattern matching
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> date = { month: <span class="dt">string</span>; day: <span class="dt">int</span>; year: <span class="dt">int</span> } </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> f x = </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> x <span class="kw">with</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    {year; day; month}-&gt; <span class="dt">Printf</span>.printf <span class="st">&quot;%d</span><span class="ch">\t</span><span class="st">%s</span><span class="ch">\t</span><span class="st">%d</span><span class="ch">\n</span><span class="st">&quot;</span> year month day;; </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> f {year=<span class="dv">2024</span>;day=<span class="dv">6</span>;month=<span class="st">&quot;Feb&quot;</span>};;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a># <span class="kw">type</span> date = { month : <span class="dt">string</span>; day : <span class="dt">int</span>; year : <span class="dt">int</span>; }</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> f : date -&gt; <span class="dt">unit</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="dv">2024</span>    Feb <span class="dv">6</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">unit</span> = ()</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><p><div class="SIntrapara">We can also bind records fields to pattern variables:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> date = { month: <span class="dt">string</span>; day: <span class="dt">int</span>; year: <span class="dt">int</span> } </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> f x = </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">match</span> x <span class="kw">with</span> </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    {year=y; day=d; month=m} -&gt; <span class="dt">Printf</span>.printf <span class="st">&quot;%d</span><span class="ch">\t</span><span class="st">%s</span><span class="ch">\t</span><span class="st">%d</span><span class="ch">\n</span><span class="st">&quot;</span> y m d;; </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> f {year=<span class="dv">2024</span>;day=<span class="dv">6</span>;month=<span class="st">&quot;Feb&quot;</span>};;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a># <span class="kw">type</span> date = { month : <span class="dt">string</span>; day : <span class="dt">int</span>; year : <span class="dt">int</span>; }</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> f : date -&gt; <span class="dt">unit</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="dv">2024</span>    Feb <span class="dv">6</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">unit</span> = ()</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">There is a syntactic sugar for the match
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f3 {year; day; month} = <span class="dt">Printf</span>.printf <span class="st">&quot;%d   %s  %d</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;</span> year month day</span></code></pre></div>

or
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f {year =y; day=d; month=m} = <span class="dt">Printf</span>.printf <span class="st">&quot;%d %s  %d</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;</span> y m d</span></code></pre></div>
</div></p><p><div class="SIntrapara">You can also destruct a record using let expressions.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> date = { month: <span class="dt">string</span>; day: <span class="dt">int</span>; year: <span class="dt">int</span> } </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> today = {year=<span class="dv">2023</span>;day=<span class="dv">6</span>;month=<span class="st">&quot;Feb&quot;</span>};; </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> {year; day; month} = today <span class="kw">in</span> <span class="dt">Printf</span>.printf <span class="st">&quot;%d</span><span class="ch">\t</span><span class="st">%s</span><span class="ch">\t</span><span class="st">%d</span><span class="ch">\n</span><span class="st">&quot;</span> year month day;; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> {year =y; day=d; month=m} = today <span class="kw">in</span> <span class="dt">Printf</span>.printf <span class="st">&quot;%d</span><span class="ch">\t</span><span class="st">%s</span><span class="ch">\t</span><span class="st">%d</span><span class="ch">\n</span><span class="st">&quot;</span> y m d;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a># <span class="kw">type</span> date = { month : <span class="dt">string</span>; day : <span class="dt">int</span>; year : <span class="dt">int</span>; }</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> today : date = {month = <span class="st">&quot;Feb&quot;</span>; day = <span class="dv">6</span>; year = <span class="dv">2023</span>}</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a># <span class="dv">2023</span>  Feb <span class="dv">6</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">unit</span> = ()</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="dv">2023</span>    Feb <span class="dv">6</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">unit</span> = ()</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">Or access any number of fields of the record:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> date = { month: <span class="dt">string</span>; day: <span class="dt">int</span>; year: <span class="dt">int</span> } </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> today = {year=<span class="dv">2023</span>;day=<span class="dv">6</span>;month=<span class="st">&quot;Feb&quot;</span>};; </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> {year} = today <span class="kw">in</span> <span class="dt">Printf</span>.printf <span class="st">&quot;%d</span><span class="ch">\n</span><span class="st">&quot;</span> year;; </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> {year =y; day=d} = today <span class="kw">in</span> <span class="dt">Printf</span>.printf <span class="st">&quot;%d</span><span class="ch">\t</span><span class="st">%d</span><span class="ch">\n</span><span class="st">&quot;</span> y d;;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a># <span class="kw">type</span> date = { month : <span class="dt">string</span>; day : <span class="dt">int</span>; year : <span class="dt">int</span>; }</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> today : date = {month = <span class="st">&quot;Feb&quot;</span>; day = <span class="dv">6</span>; year = <span class="dv">2023</span>}</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a># <span class="dv">2023</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">unit</span> = ()</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="dv">2023</span>    <span class="dv">6</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">unit</span> = ()</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><p>Quiz: What is the type of shift?
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> point = {x:<span class="dt">int</span>; y:<span class="dt">int</span>}</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> shift { x=px } = [px]::[]</span></code></pre></div>

Answer: The type of &lsquo;shift&lsquo; is <span style="font-weight: bold">point -&gt; int list list</span>.
Argument &lsquo;{ x=px }&lsquo; is a record with a field &lsquo;x&lsquo;.
We know it is the &lsquo;pont&lsquo;.  &lsquo;{ x=px }&lsquo;also binds the field &lsquo;x&lsquo; of &lsquo;point&lsquo; to &lsquo;px&lsquo;.
Because &lsquo;x&lsquo; is &lsquo;int&lsquo;, &lsquo;px&lsquo; is also &lsquo;int&lsquo;. If &lsquo;px&lsquo; is &lsquo;int&lsquo;, then &lsquo;[px]&lsquo; is &lsquo;int list&lsquo;
and &lsquo;[px]::[]&lsquo; is an &lsquo;int list list&lsquo;.</p><h4 class="heading">1.20<tt>&nbsp;</tt><a name="(part._.Anonymous_.Functions)"></a>Anonymous Functions<span class="button-group"><a href="#(part._.Anonymous_.Functions)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p><div class="SIntrapara">In OCaml, we use &lsquo;fun&lsquo; to make a function with no name. For example:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> x -&gt; x + <span class="dv">3</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">Here, &lsquo;x&lsquo; is the parameter and &lsquo;x+3&lsquo; is the body. We can apply this anonymous function as:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">fun</span> x -&gt; x + <span class="dv">3</span>) <span class="dv">5</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">8</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">The evaluation and typechecking rules are same as functions.</div></p><p><div class="SIntrapara">Quiz: What is this expression&#8217;s type?
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>(<span class="kw">fun</span> x y -&gt; x) <span class="dv">2</span> <span class="dv">3</span></span></code></pre></div>

Type of <span style="font-weight: bold">(fun x y&#8594; x)</span> is <span style="font-weight: bold">&rsquo;a&#8594;&rsquo;b&#8594;&rsquo;a</span>. Because we apply this anonymous
function to arguments &lsquo;2 3&lsquo;, &lsquo;&rsquo;a&lsquo; and &lsquo;&rsquo;b&lsquo; will be restricted to &lsquo;int&lsquo;s. Therefore,
 the return type will be an &lsquo;int&lsquo;.
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">fun</span> x y -&gt; x) <span class="dv">2</span> <span class="dv">3</span>;;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">2</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div></p><h5 class="heading">1.20.1<tt>&nbsp;</tt><a name="(part._.Functions_and_.Binding)"></a>Functions and Binding<span class="button-group"><a href="#(part._.Functions_and_.Binding)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p><div class="SIntrapara">In OCaml, functions are first-class, so you can bind them to other names as you like
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="emph">OCaml REPL</span></span></p><blockquote class="Rfilecontent"><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f x = x + <span class="dv">3</span>;; </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">let</span> g = f;; </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> g <span class="dv">5</span>;;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> f : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a># <span class="kw">val</span> g : <span class="dt">int</span> -&gt; <span class="dt">int</span> = &lt;<span class="kw">fun</span>&gt;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a># </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>- : <span class="dt">int</span> = <span class="dv">8</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p></blockquote></blockquote></div><div class="SIntrapara">In fact, let for functions is a syntactic shorthand
<span style="font-weight: bold">let f x = body</span> is semantically equivalent to
<span style="font-weight: bold">let f = fun x -&gt;  body</span>. For example:</div></p><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> next x = x + <span class="dv">1</span></span></code></pre></div>
 is the short for
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> next = <span class="kw">fun</span> x -&gt; x + <span class="dv">1</span></span></code></pre></div>
</p><p>and,
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> plus x y = x + y</span></code></pre></div>

is the short for
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> plus = <span class="kw">fun</span> x y -&gt; x + y</span></code></pre></div>
</p><p>Quiz: What does this evaluate to?
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f = <span class="kw">fun</span> x -&gt; <span class="dv">0</span> <span class="kw">in</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> g = f <span class="kw">in</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> h = <span class="kw">fun</span> y -&gt; g (y+<span class="dv">1</span>) <span class="kw">in</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>h <span class="dv">1</span>;;</span></code></pre></div>

Answer:
<div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>h <span class="dv">1</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>(<span class="kw">fun</span> y -&gt; g (y+<span class="dv">1</span>)) <span class="dv">1</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>g (<span class="dv">1</span>+<span class="dv">1</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>g <span class="dv">2</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>f <span class="dv">2</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>(<span class="kw">fun</span> x -&gt; <span class="dv">0</span>) <span class="dv">2</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="dv">0</span></span></code></pre></div>
</p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="index.html" title="backward to &quot;CMSC 330 Lecture Notes&quot;" data-pltdoc="x" rel="prev">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;CMSC 330 Lecture Notes&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<span class="nonavigation">next &rarr;</span></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>