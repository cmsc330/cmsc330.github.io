<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>5&nbsp;Finite Automata</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><link rel="stylesheet" type="text/css" href="extra.css" title="default"/><link rel="stylesheet" type="text/css" href="fancyverb.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">CMSC 330 Lecture Notes</a></td></tr></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="ocaml.html" class="tocviewlink" data-pltdoc="x">Functional Programming with OCaml</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="Imperative_OCaml.html" class="tocviewlink" data-pltdoc="x">Imperative Programming with OCaml</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="pbt.html" class="tocviewlink" data-pltdoc="x">Property-<wbr></wbr>Based Randomized Testing</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="regexp.html" class="tocviewlink" data-pltdoc="x">OCaml Regular Expressions</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Finite Automata</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td>5&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Finite Automata</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">5.1&nbsp;</td><td><a href="#%28part._.Regular_.Expressions%29" class="tocviewlink" data-pltdoc="x">Regular Expressions</a></td></tr><tr><td align="right">5.2&nbsp;</td><td><a href="#%28part._.Alphabet__.String__and_.Language%29" class="tocviewlink" data-pltdoc="x">Alphabet, String, and Language</a></td></tr><tr><td align="right">5.3&nbsp;</td><td><a href="#%28part._.Operations_on_.Languages%29" class="tocviewlink" data-pltdoc="x">Operations on Languages</a></td></tr><tr><td align="right">5.4&nbsp;</td><td><a href="#%28part._.Regular_.Languages%29" class="tocviewlink" data-pltdoc="x">Regular Languages</a></td></tr><tr><td align="right">5.5&nbsp;</td><td><a href="#%28part._.Semantics_of_.Regular_.Expressions%29" class="tocviewlink" data-pltdoc="x">Semantics of Regular Expressions</a></td></tr><tr><td align="right">5.6&nbsp;</td><td><a href="#%28part._.Implementing_.Regular_.Expressions%29" class="tocviewlink" data-pltdoc="x">Implementing Regular Expressions</a></td></tr><tr><td align="right">5.7&nbsp;</td><td><a href="#%28part._.F.S.M_.Exercises%29" class="tocviewlink" data-pltdoc="x">FSM Exercises</a></td></tr><tr><td align="right">5.8&nbsp;</td><td><a href="#%28part._.D.F.A_and_.N.F.A%29" class="tocviewlink" data-pltdoc="x">DFA and NFA</a></td></tr><tr><td align="right">5.9&nbsp;</td><td><a href="#%28part._.Reducing_.Regular_.Expressions_to_.N.F.As%29" class="tocviewlink" data-pltdoc="x">Reducing Regular Expressions to NFAs</a></td></tr><tr><td align="right">5.10&nbsp;</td><td><a href="#%28part._.Subset_.Construction__.N.F.A_to_.D.F.A_.Conversion_%29" class="tocviewlink" data-pltdoc="x">Subset Construction (NFA to DFA Conversion)</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">5.1<tt>&nbsp;</tt></span><a href="#%28part._.Regular_.Expressions%29" class="tocsubseclink" data-pltdoc="x">Regular Expressions</a></td></tr><tr><td><span class="tocsublinknumber">5.2<tt>&nbsp;</tt></span><a href="#%28part._.Alphabet__.String__and_.Language%29" class="tocsubseclink" data-pltdoc="x">Alphabet, String, and Language</a></td></tr><tr><td><span class="tocsublinknumber">5.2.1<tt>&nbsp;</tt></span><a href="#%28part._.The_.Set_of_.All_.Valid__.Runnable__.O.Caml_.Programs%29" class="tocsubseclink" data-pltdoc="x">The Set of All Valid (Runnable) OCaml Programs</a></td></tr><tr><td><span class="tocsublinknumber">5.3<tt>&nbsp;</tt></span><a href="#%28part._.Operations_on_.Languages%29" class="tocsubseclink" data-pltdoc="x">Operations on Languages</a></td></tr><tr><td><span class="tocsublinknumber">5.4<tt>&nbsp;</tt></span><a href="#%28part._.Regular_.Languages%29" class="tocsubseclink" data-pltdoc="x">Regular Languages</a></td></tr><tr><td><span class="tocsublinknumber">5.5<tt>&nbsp;</tt></span><a href="#%28part._.Semantics_of_.Regular_.Expressions%29" class="tocsubseclink" data-pltdoc="x">Semantics of Regular Expressions</a></td></tr><tr><td><span class="tocsublinknumber">5.6<tt>&nbsp;</tt></span><a href="#%28part._.Implementing_.Regular_.Expressions%29" class="tocsubseclink" data-pltdoc="x">Implementing Regular Expressions</a></td></tr><tr><td><span class="tocsublinknumber">5.6.1<tt>&nbsp;</tt></span><a href="#%28part._.Finite_.State_.Machine%29" class="tocsubseclink" data-pltdoc="x">Finite State Machine</a></td></tr><tr><td><span class="tocsublinknumber">5.7<tt>&nbsp;</tt></span><a href="#%28part._.F.S.M_.Exercises%29" class="tocsubseclink" data-pltdoc="x">FSM Exercises</a></td></tr><tr><td><span class="tocsublinknumber">5.8<tt>&nbsp;</tt></span><a href="#%28part._.D.F.A_and_.N.F.A%29" class="tocsubseclink" data-pltdoc="x">DFA and NFA</a></td></tr><tr><td><span class="tocsublinknumber">5.9<tt>&nbsp;</tt></span><a href="#%28part._.Reducing_.Regular_.Expressions_to_.N.F.As%29" class="tocsubseclink" data-pltdoc="x">Reducing Regular Expressions to NFAs</a></td></tr><tr><td><span class="tocsublinknumber">5.10<tt>&nbsp;</tt></span><a href="#%28part._.Subset_.Construction__.N.F.A_to_.D.F.A_.Conversion_%29" class="tocsubseclink" data-pltdoc="x">Subset Construction (NFA to DFA Conversion)</a></td></tr><tr><td><span class="tocsublinknumber">5.10.1<tt>&nbsp;</tt></span><a href="#%28part._.Subset_.Construction_.Algorithm%29" class="tocsubseclink" data-pltdoc="x">Subset Construction Algorithm</a></td></tr><tr><td><span class="tocsublinknumber">5.10.2<tt>&nbsp;</tt></span><a href="#%28part._.Example_1%29" class="tocsubseclink" data-pltdoc="x">Example 1</a></td></tr><tr><td><span class="tocsublinknumber">5.10.3<tt>&nbsp;</tt></span><a href="#%28part._.Example_2%29" class="tocsubseclink" data-pltdoc="x">Example 2</a></td></tr><tr><td><span class="tocsublinknumber">5.10.4<tt>&nbsp;</tt></span><a href="#%28part._.Example_3%29" class="tocsubseclink" data-pltdoc="x">Example 3</a></td></tr><tr><td><span class="tocsublinknumber">5.10.5<tt>&nbsp;</tt></span><a href="#%28part._.Example_4%29" class="tocsubseclink" data-pltdoc="x">Example 4</a></td></tr><tr><td><span class="tocsublinknumber">5.10.6<tt>&nbsp;</tt></span><a href="#%28part._.Example_5%29" class="tocsubseclink" data-pltdoc="x">Example 5</a></td></tr><tr><td><span class="tocsublinknumber">5.10.7<tt>&nbsp;</tt></span><a href="#%28part._.Example_6%29" class="tocsubseclink" data-pltdoc="x">Example 6</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">8.17</span></div><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="regexp.html" title="backward to &quot;4 OCaml Regular Expressions&quot;" data-pltdoc="x" rel="prev">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;CMSC 330 Lecture Notes&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<span class="nonavigation">next &rarr;</span></span>&nbsp;</div><h3 class="heading">5<tt>&nbsp;</tt><a name="(part._.Finite_.Automata)"></a>Finite Automata<span class="button-group"><a href="#(part._.Finite_.Automata)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h3><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Regular_.Expressions%29" class="toclink" data-pltdoc="x">5.1<span class="hspace">&nbsp;</span>Regular Expressions</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Alphabet__.String__and_.Language%29" class="toclink" data-pltdoc="x">5.2<span class="hspace">&nbsp;</span>Alphabet, String, and Language</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Operations_on_.Languages%29" class="toclink" data-pltdoc="x">5.3<span class="hspace">&nbsp;</span>Operations on Languages</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Regular_.Languages%29" class="toclink" data-pltdoc="x">5.4<span class="hspace">&nbsp;</span>Regular Languages</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Semantics_of_.Regular_.Expressions%29" class="toclink" data-pltdoc="x">5.5<span class="hspace">&nbsp;</span>Semantics of Regular Expressions</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Implementing_.Regular_.Expressions%29" class="toclink" data-pltdoc="x">5.6<span class="hspace">&nbsp;</span>Implementing Regular Expressions</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.F.S.M_.Exercises%29" class="toclink" data-pltdoc="x">5.7<span class="hspace">&nbsp;</span>FSM Exercises</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.D.F.A_and_.N.F.A%29" class="toclink" data-pltdoc="x">5.8<span class="hspace">&nbsp;</span>DFA and NFA</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Reducing_.Regular_.Expressions_to_.N.F.As%29" class="toclink" data-pltdoc="x">5.9<span class="hspace">&nbsp;</span>Reducing Regular Expressions to NFAs</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Subset_.Construction__.N.F.A_to_.D.F.A_.Conversion_%29" class="toclink" data-pltdoc="x">5.10<span class="hspace">&nbsp;</span>Subset Construction (NFA to DFA Conversion)</a></p></td></tr></table><h4 class="heading">5.1<tt>&nbsp;</tt><a name="(part._.Regular_.Expressions)"></a>Regular Expressions<span class="button-group"><a href="#(part._.Regular_.Expressions)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p><div class="SIntrapara">In the previous lecture, we introduced regular expressions (regex).
We discussed:
</div><div class="SIntrapara"><ul><li><p>What regular expressions are</p></li><li><p>What kinds of patterns they can express &#8212; and what they cannot</p></li><li><p>How to use them in programming to match and manipulate strings</p></li></ul></div></p><p><div class="SIntrapara">In this lecture, we will explore how regular expressions (REs) work and
examine the internal mechanisms that enable pattern matching &#8212; specifically,
how regex engines process input strings and identify matches. Regular
expressions are a foundational concept in computer science, offering a
simple yet powerful way to describe patterns within strings. To understand
them deeply, we need to address several key questions:
</div><div class="SIntrapara"><ul><li><p>How are regular
expressions implemented?</p></li><li><p>Given an arbitrary RE and a string, how can we
determine whether the RE matches the string?</p></li><li><p>What are the basic components
of regular expressions, and how do they relate to one another? For instance, some
operators can be expressed in terms of others, such as <span style="font-weight: bold">e+</span> being equivalent
to <span style="font-weight: bold">ee*</span>.</p></li></ul></div></p><p>At a fundamental level, a regular expression represents a set of strings
that match the pattern, and viewing them this way provides a crucial perspective.
This viewpoint will guide our approach to designing and implementing effective
regular expression matching.</p><h4 class="heading">5.2<tt>&nbsp;</tt><a name="(part._.Alphabet__.String__and_.Language)"></a>Alphabet, String, and Language<span class="button-group"><a href="#(part._.Alphabet__.String__and_.Language)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>First, let&#8217;s review some basic concepts.</p><p><span style="font-weight: bold">Alphabet</span>: An alphabet is a finite set of symbols, typically denoted by &#931; (the Greek
letter sigma). It defines the basic building blocks used to form strings in formal languages.</p><p><div class="SIntrapara">Examples of alphabets:
</div><div class="SIntrapara"><ul><li><p>Binary: &#931; = {0, 1}</p></li><li><p>Decimal: &#931; = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}</p></li><li><p>Alphanumeric: &#931; = {0&#8211;9, a&#8211;z, A&#8211;Z}</p></li></ul></div></p><p><div class="SIntrapara"><span style="font-weight: bold">String:</span> A string is a finite sequence of symbols taken from the alphabet &#931;.
</div><div class="SIntrapara"><ul><li><p>&#949; denotes the empty string (written as "" in OCaml).</p></li><li><p>|s| represents the length of string s.</p></li><li><ul><li><p>Example: |Hello| = 5,&#8195;|&#949;| = 0</p></li></ul></li></ul></div></p><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>&#216; is the empty set (it has no elements).
&#216; &#8800; {&#949;}&#8195;and&#8195;&#216; &#8800; &#949; &#8212; these are distinct concepts.</p></blockquote></blockquote></blockquote><p><div class="SIntrapara">Example strings over the binary alphabet &#931; = {0,1}:
</div><div class="SIntrapara"><ul><li><p>0101</p></li><li><p>0101110</p></li><li><p>&#949;</p></li></ul></div></p><p><span style="font-weight: bold">Language:</span> A language <span style="font-weight: bold">L</span> is a set of strings formed from symbols of a given alphabet <span style="font-weight: bold">&#931;</span>.
In other words, once we define an alphabet, we can describe a language as any
collection of finite strings built using those symbols.</p><p>Formally:
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>L âŠ† Î£<span class="op">*</span></span></code></pre></div>
</p><p>Here, &#931;* (read &#8220;Sigma star&#8221;) represents the set of all possible strings, including
the empty string &#949;, that can be constructed using symbols from &#931;.</p><p><div class="SIntrapara">Here are some examples of a language.
</div><div class="SIntrapara"><ul><li><p>Example 1:</p><p>All strings of length 1 or 2 over the alphabet &#931; = {a, b, c} that begin with a:</p><p>L1 = { a, aa, ab, ac }</p></li><li><p>Example 2:</p><p>All strings over &#931; = {a, b}:</p><p>L2 = { &#949;, a, b, aa, bb, ab, ba, aaa, bba, aba, baa, &#8230; }</p><p>This is the language &#931;* itself &#8212; that is, all possible strings (of any length) over the alphabet {a, b}.</p></li><li><p>Example 3:</p><p>A language can also represent a real-world set of strings.
For instance, the set of valid phone numbers over the alphabet
&#931; = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, (, ), -}:</p><p>L3 = { "(301)405-1000", "(202)555-0182", "410-555-7890", &#8230; }</p></li></ul></div></p><p><div class="SIntrapara">From the example 3, we can ask the folloing questions:
</div><div class="SIntrapara"><ul><li><p>Are all strings over the alphabet &#931; = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, (, ), -} included in the language L3?
No. Not every string over this alphabet forms a valid phone number.
For example, the string "(((((((&#8212;<wbr></wbr>&#8212;<wbr></wbr>" uses only symbols from &#931; but does not represent a valid phone number, so it is not in L&#8323;.</p></li><li><p>Is there a regular expression that describes L3?
Yes. The language L3, representing valid phone numbers, can be expressed using the regular
expression: <span style="font-weight: bold">\(\d{3}\)\d{3}-\d{4}</span>. This pattern matches strings in the form (XXX)XXX-XXXX, where each X is a digit.</p></li></ul></div></p><h5 class="heading">5.2.1<tt>&nbsp;</tt><a name="(part._.The_.Set_of_.All_.Valid__.Runnable__.O.Caml_.Programs)"></a>The Set of All Valid (Runnable) OCaml Programs<span class="button-group"><a href="#(part._.The_.Set_of_.All_.Valid__.Runnable__.O.Caml_.Programs)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Consider the language of all valid OCaml programs &#8212; that is, every possible
sequence of characters that forms a syntactically correct and executable OCaml program.
Each valid program (for example, print_endline "Hello";;) can be viewed as a string over
a suitable alphabet that includes letters, digits, punctuation, and symbols
used in the OCaml language.</p><p>This collection of all syntactically correct programs forms a language in the formal
sense &#8212; a set of strings over an alphabet that satisfy certain grammatical
rules (in this case, the OCaml grammar).</p><p>Later in the course, we will learn how such programming language grammars
can be formally specified using tools more expressive than regular expressions.
While regular expressions are powerful for describing many kinds
of string patterns (like tokens, identifiers, or numbers), they are
not sufficient to describe the full syntax of programming languages such as OCaml.
To handle nested structures (like parentheses, let-bindings, or function
definitions), we need more powerful formalisms such as context-free grammars (CFGs).</p><h4 class="heading">5.3<tt>&nbsp;</tt><a name="(part._.Operations_on_.Languages)"></a>Operations on Languages<span class="button-group"><a href="#(part._.Operations_on_.Languages)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p><div class="SIntrapara">Just like numbers and sets, languages can be combined and manipulated using well-defined operations.
Some common operations include:
</div><div class="SIntrapara"><ul><li><p>Union (L&#8321; &#8746; L&#8322;): Strings that belong to either L&#8321; or L&#8322;.</p></li><li><p>Concatenation (L&#8321; &#183; L&#8322;): All strings formed by taking a string from L&#8321; followed by a string from L&#8322;.</p></li><li><p>Kleene Star (L*): All strings formed by concatenating zero or more strings from L.</p></li></ul></div><div class="SIntrapara">These operations let us build more complex languages from simpler ones &#8212; a key idea behind constructing regular expressions, automata, and programming language grammars.
Let &#931; be an alphabet and let L, L1, L2 be languages over &#931;
</div><div class="SIntrapara"><ul><li><p>Concatenation L<span style="vertical-align: sub; font-size: 80%">1</span>L<span style="vertical-align: sub; font-size: 80%">2</span> creates a language defined as:</p><p>L<span style="vertical-align: sub; font-size: 80%">1</span>L<span style="vertical-align: sub; font-size: 80%">2</span> = { xy | x &#8714; L1 and y &#8714; L2}</p></li><li><p>Union creates a language defined as</p><p>L<span style="vertical-align: sub; font-size: 80%">1</span> &#8746; L<span style="vertical-align: sub; font-size: 80%">2</span> = { x | x &#8714; L<span style="vertical-align: sub; font-size: 80%">1</span> or x &#8714; L<span style="vertical-align: sub; font-size: 80%">2</span>}</p></li><li><p>Kleene closure creates a language is defined as
L* = { x | x = &#949; or x &#8714; L or x &#8714; LL or x &#8714; LLL or &#8230;}</p></li></ul></div></p><p>Here is an Example:</p><p>Let L<span style="vertical-align: sub; font-size: 80%">1</span> = { a, b },   L2 = { 1, 2, 3 } (and &#931; =  {a,b,1,2,3})</p><p>L<span style="vertical-align: sub; font-size: 80%">1</span>L<span style="vertical-align: sub; font-size: 80%">2</span>: { a1, a2, a3, b1, b2, b3 }</p><p>L<span style="vertical-align: sub; font-size: 80%">1</span> &#8746; L<span style="vertical-align: sub; font-size: 80%">2</span>: { a, b, 1, 2, 3 }</p><p>L<span style="vertical-align: sub; font-size: 80%">1</span>* : { &#949;, a, b, aa, bb, ab, ba, aaa, aab, bba, bbb, aba, abb, baa, bab, &#8230; }</p><h4 class="heading">5.4<tt>&nbsp;</tt><a name="(part._.Regular_.Languages)"></a>Regular Languages<span class="button-group"><a href="#(part._.Regular_.Languages)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>In theoretical computer science and formal language theory, a regular language is a formal language that can be described using a regular expression (RE).</p><p>Regular expressions represent regular languages. They are not merely a convenient tool for describing string patterns &#8212; they have a precise mathematical meaning. Each regular expression corresponds to a specific regular language, which is the set of all strings that match the expression.</p><p>In short, regular expressions provide a formal notation for defining regular languages.</p><p>When we write a regular expression such as:</p><p>(a&#8739;b)*ab</p><p>it denotes the language consisting of all strings over the &#931; ={a,b} that end with &#8220;ab&#8221;.</p><p>While regular expressions and finite automata are powerful, not every language can be described by a regular expression.
Some languages are simply too complex to be captured by the limited memory of a finite automaton.</p><p><div class="SIntrapara">Here are some examples of Non-Regular Languages:
</div><div class="SIntrapara"><ul><li><p>Palindromes over &#931;:
The set of all strings that read the same forwards and backwards (e.g., abba, 0110).
Recognizing palindromes requires remembering the first half of the string to compare with the second &#8212; something a finite automaton cannot do.</p></li><li><p>L = { a&#8319;b&#8319; | n &gt; 0 }:
The set of strings with an equal number of a&#8217;s followed by b&#8217;s, such as ab, aabb, aaabbb, etc.
This language is not regular because it requires counting &#8212; another task beyond the capability of finite automata.</p></li><li><p>Programming Languages:
Most programming languages (like OCaml, Python, or C) are not regular, since their syntax involves nested structures and dependencies (e.g., matching parentheses, block scopes).
However, some components of these languages are regular, such as identifiers, numbers, or simple tokens.</p></li></ul></div></p><p>Despite these limits, regular expressions remain extremely useful, especially in lexical analysis &#8212; the first stage of program compilation where the source code is broken into tokens.
Tools like lex, flex, and many modern regex libraries use regular expressions to describe and recognize these patterns.</p><h4 class="heading">5.5<tt>&nbsp;</tt><a name="(part._.Semantics_of_.Regular_.Expressions)"></a>Semantics of Regular Expressions<span class="button-group"><a href="#(part._.Semantics_of_.Regular_.Expressions)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p><div class="SIntrapara">Given an alphabet &#931;, the set of regular expressions over &#931; is defined inductively (step by step) as follows:
</div><div class="SIntrapara"><ul><li><p><div class="SIntrapara">Base cases:
</div><div class="SIntrapara"><ul><li><p>&#949; &#8212; represents the language {&#949;}, which contains only the empty string.</p></li><li><p>&#8709; &#8212; represents the empty language, containing no strings.</p></li><li><p>For each symbol a &#8712; &#931;, a is a regular expression denoting the language {a}.</p></li></ul></div></p></li><li><p><div class="SIntrapara">Inductive (recursive) cases:
If A and B are regular expressions representing the languages L(A) and L(B),
then the following are also regular expressions:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="boxed" style="border-collapse: collapse;"><tr><td align="center" style="border: 1px solid black;"><p><span style="font-weight: bold">Regular Expression</span></p></td><td align="center" style="border: 1px solid black;"><p><span style="font-weight: bold">Denoted Language</span></p></td></tr><tr><td align="center" style="border: 1px solid black;"><p>A | B</p></td><td align="center" style="border: 1px solid black;"><p>Union: L(A) &#8746; L(B)</p></td></tr><tr><td align="center" style="border: 1px solid black;"><p>A &#183; B</p></td><td align="center" style="border: 1px solid black;"><p>Concatenation: L(A)L(B)</p></td></tr><tr><td align="center" style="border: 1px solid black;"><p>A*</p></td><td align="center" style="border: 1px solid black;"><p>Kleene star: L(A)*</p></td></tr></table></div></p></li></ul></div><div class="SIntrapara">These rules precisely define how each regular expression corresponds to a language,
providing the formal semantics of regular expressions.</div></p><p>Regular expressions apply operations to symbols to generate a set of strings, also known as a language.
(A formal definition will follow.)</p><p><div class="SIntrapara">Examples:
</div><div class="SIntrapara"><ul><li><p>a generates the language {a}</p></li><li><p>a | b generates the language {a} &#8746; {b} = {a, b}</p></li><li><p>a* generates the language {&#949;} &#8746; {a} &#8746; {aa} &#8746; &#8230; = {&#949;, a, aa, &#8230;}</p></li></ul></div></p><p>If a string s &#8712; L, where L is the language generated by a regular expression r, we say that r accepts, describes, or recognizes the string s.</p><p><div class="SIntrapara">In essence, nearly all features of regular expressions can be reduced to this formal definition. For example:
</div><div class="SIntrapara"><ul><li><p>OCaml &#8211; concatenation of single-symbol REs</p></li><li><p>(OCaml|Rust) &#8211;&#160;union</p></li><li><p>(OCaml)* &#8211;&#160;Kleene closure</p></li><li><p>(OCaml)+ &#8211;&#160;same as (OCaml)(OCaml)*</p></li><li><p>(Ocaml)? &#8211; same as (&#949;|(OCaml))</p></li><li><p>[a-z] &#8211; same as (a|b|c|...|z)</p></li><li><p>[^0-9] &#8211;&#160;same as (a|b|c|...) for a,b,c,... &#8712; &#931; - {0..9}</p></li><li><p>^, $ &#8211;&#160;correspond to extra symbols in alphabet</p></li></ul></div></p><p>Think of every string containing a distinct, hidden symbol at its start and at its end &#8211; these are written ^ and $</p><h4 class="heading">5.6<tt>&nbsp;</tt><a name="(part._.Implementing_.Regular_.Expressions)"></a>Implementing Regular Expressions<span class="button-group"><a href="#(part._.Implementing_.Regular_.Expressions)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Regular expressions can be implemented by converting them into an equivalent finite automaton &#8212; a computational model that recognizes exactly the same set of strings described by the expression.</p><p>In essence, a finite automaton serves as a machine that reads an input string symbol by symbol and determines whether it belongs to the regular language defined by the regular expression.</p><p><img src="machine.png" alt="" width="495" height="175"/></p><p>Simply put, to determine whether an input string matches a pattern, we first build a small machine based on the pattern. Then, we feed the string into the machine &#8212; if the machine accepts it, the string matches; if it rejects it, the string does not match.</p><p>Thus, every regular expression corresponds to a finite automaton, and every finite automaton defines a regular language.</p><h5 class="heading">5.6.1<tt>&nbsp;</tt><a name="(part._.Finite_.State_.Machine)"></a>Finite State Machine<span class="button-group"><a href="#(part._.Finite_.State_.Machine)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>A Finite-State Machine (FSM) &#8212; also known as Finite-State Automaton
(FSA), Finite Automata, or simply a State Machine &#8212; is a
mathematical model of computation. It represents an abstract machine that
can be in one and only one state at any given time.</p><p>In class, the terms FSM, FSA, and FA are all used to refer to a finite-state machine.</p><p>The machine can change from one state to another in response to certain inputs. Such a change is called a transition.</p><p><div class="SIntrapara">An FSM is formally defined by:
</div><div class="SIntrapara"><ul><li><p>A finite set of states</p></li><li><p>A start (initial) state</p></li><li><p>A set of input symbols (alphabet)</p></li><li><p>A transition function that describes how states change in response to inputs</p></li></ul></div></p><p>In summary, the FSM processes inputs one at a time, moving through states according to its transition rules. For example,
consider the finite-state machine shown below:</p><p><img src="fsm1.png" alt="" width="305" height="202"/></p><ul><li><p>States are represented by circles, and transitions are represented by arrows.</p></li><li><p>Set of states: {S0, S1}</p></li><li><p>Start state: S0. &#8212; The state where the automaton begins computation. It is indicated by an incoming arrow with no origin. There is only one start state. </p></li><li><p>Final (accepting) state: S1 &#8212; denoted by the double circles. There may be zero or multiple final states in general. Any state, including the start state, can be final</p></li><li><p>Input symbols: {0,1}</p></li><li><p>Transitions:  {(S0, 0, S0), (S0, 1, S1), (S1, 1, S1), (S1, 0, S0)} - Each transition specifies how the automaton moves from one state to another when reading a particular input symbol.</p></li></ul><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>The FSM&#8217;s next state depends only on its current state and the current input symbol, not on the sequence of inputs that led to the current state.
In other words, the machine has no memory of past inputs beyond the current state it is in.</p></blockquote></blockquote></blockquote><p>Now, let&#8217;s explain how a Finite Automaton processes an input string.</p><ul><li><p>The machine begins in the start (initial) state.</p></li><li><p><div class="SIntrapara">It processes the input string symbol by symbol until the end of the string is reached:
</div><div class="SIntrapara"><ul><li><p>Read the next symbol &#963; &#8712; &#931; from the string.</p></li><li><p>Follow the transition edge labeled with &#963; to the next state.</p></li></ul></div></p></li><li><p>After the entire string has been read, the string is accepted if the
automaton is in a final (accepting) state; otherwise, it is rejected.</p></li></ul><p><div class="SIntrapara"><span style="font-weight: bold">Example:</span> Let&#8217;s trace how the FSM processes the input string &#8220;0 0 1 0 1 1&#8221;.
</div><div class="SIntrapara"><ul><li><p>Starting at S0, the first input 0 keeps the machine in S0.</p></li><li><p>The next input 0 also keeps it in S0.</p></li><li><p>The next symbol 1 causes a transition from S0 to S1.</p></li><li><p>The following 0 moves the machine from S1 back to S0.</p></li><li><p>The next 1 transitions it to S1, and the final 1 keeps it in S1.</p></li></ul></div></p><p>After processing all input symbols, the machine ends in S1, which is a final (accepting) state.
Therefore, the input string &#8220;0 0 1 0 1 1&#8221; is accepted by the FSM.</p><p><div class="SIntrapara"><span style="font-weight: bold">Example 2:</span> Using the same process, consider the input &#8220;0 0 1 0 1 0.&#8221;
</div><div class="SIntrapara"><ul><li><p>After processing all the input symbols, the FSM ends in S0, which is a rejecting state.</p></li></ul></div></p><p>Thus, the input string &#8220;0 0 1 0 1 0&#8221; is rejected by the FSM.</p><p><div class="SIntrapara">For each input string in the table below, determine:
</div><div class="SIntrapara"><ul><li><p>The state in which the machine ends after processing the input.</p></li><li><p>Whether the input is accepted or rejected by the FSM.</p></li></ul></div></p><p><div class="SIntrapara"><img src="fsm2.png" alt="" width="353" height="375"/>
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="boxed" style="border-collapse: collapse;"><tr><td align="center" style="border: 1px solid black;"><p><span style="font-weight: bold">Input String</span></p></td><td align="center" style="border: 1px solid black;"><p><span style="font-weight: bold">State at end</span></p></td><td align="center" style="border: 1px solid black;"><p><span style="font-weight: bold">Accepts?</span></p></td></tr><tr><td align="center" style="border: 1px solid black;"><p>aabcc</p></td><td align="center" style="border: 1px solid black;"><p>S2</p></td><td align="center" style="border: 1px solid black;"><p>Yes</p></td></tr><tr><td align="center" style="border: 1px solid black;"><p>acca</p></td><td align="center" style="border: 1px solid black;"><p>S3</p></td><td align="center" style="border: 1px solid black;"><p>No</p></td></tr><tr><td align="center" style="border: 1px solid black;"><p>aacbbb</p></td><td align="center" style="border: 1px solid black;"><p>S3</p></td><td align="center" style="border: 1px solid black;"><p>No</p></td></tr><tr><td align="center" style="border: 1px solid black;"><p>&#949;</p></td><td align="center" style="border: 1px solid black;"><p>S0</p></td><td align="center" style="border: 1px solid black;"><p>Yes</p></td></tr></table></div></p><p>From the FSM above, notice that state S3 has no outgoing transitions. This
means that once the machine enters S3, it cannot leave. Such a state is
called a dead state.</p><p>In some cases, we simplify an FSM by omitting dead states. If a transition is not
explicitly defined, it is assumed to lead to a dead state.</p><p>Based on the examples, what do you think is the language recognized by the FSM above?</p><p>The FSM accepts all strings that can be generated by the regular expression a*b*c*.</p><h4 class="heading">5.7<tt>&nbsp;</tt><a name="(part._.F.S.M_.Exercises)"></a>FSM Exercises<span class="button-group"><a href="#(part._.F.S.M_.Exercises)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Define an FSM over &#931; = {0,1} that accepts strings with an odd number of 1s.</p><p><img src="fsm3.png" alt="" width="407" height="150"/></p><p>Define an FSM over &#931; = {a,b} that accepts strings containing an even number of a&#8217;s and any number of b&#8217;s</p><p><img src="fsm4.png" alt="" width="419" height="133"/></p><p>Define an FSM over &#931; = {0,1} that accepts strings containing two consecutive 0s followed by two consecutive 1s.
<img src="fsm5.png" alt="" width="578" height="142"/></p><p>Define an FSM over &#931; = {0,1} that accepts strings END with two consecutive 0s followed by two consecutive 1s.
<img src="fsm6.png" alt="" width="586" height="216"/></p><p>Define an FSM over &#931; = {0,1} that accepts strings containing an odd number of 0s and odd number of 1s.</p><p><img src="fsm7.png" alt="" width="493" height="258"/></p><h4 class="heading">5.8<tt>&nbsp;</tt><a name="(part._.D.F.A_and_.N.F.A)"></a>DFA and NFA<span class="button-group"><a href="#(part._.D.F.A_and_.N.F.A)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p><div class="SIntrapara">Finite-State Machines (FSMs) can be classified into two types:
</div><div class="SIntrapara"><ul><li><p><div class="SIntrapara">Deterministic Finite Automaton (DFA)
</div><div class="SIntrapara"><ul><li><p>A DFA is a finite-state machine in which each state and input symbol pair has exactly one next state.</p></li><li><p>It reads input symbols one at a time and moves deterministically from one state to the next.</p></li><li><p>An input string is accepted if the machine ends in a final state after processing all input symbols.</p></li><li><p>Example:</p><p><img src="DFA-Example-0.png" alt="" width="440" height="117"/></p></li><li><p><div class="SIntrapara">Formally, A deterministic finite automaton (DFA) is a
        5-tuple (&#931;, Q, q0, F, &#948;) where
</div><div class="SIntrapara"><ul><li><p>&#931; is an alphabet</p></li><li><p>Q is a nonempty set of states</p></li><li><p>q0 &#8714; Q is the start state</p></li><li><p>F &#8838; Q is the set of final states</p></li><li><p>&#948; : Q x &#931; &#8594; Q specifies the DFA&rsquo;s transitions</p></li></ul></div><div class="SIntrapara">A DFA accepts s if it stops at a final state on s.</div></p><p>For</p><p><img src="fsm1.png" alt="" width="305" height="202"/></p><p>We have
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>Î£ <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">}</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>Q <span class="op">=</span> <span class="op">{</span>S0<span class="op">,</span> S1<span class="op">}</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>q0 <span class="op">=</span> S0</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>F <span class="op">=</span> <span class="op">{</span>S1<span class="op">}</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>Î´ <span class="op">=</span>  <span class="op">{(</span>S0<span class="op">,</span><span class="dv">0</span><span class="op">,</span>S0<span class="op">),</span> <span class="op">(</span>S0<span class="op">,</span><span class="dv">1</span><span class="op">,</span>S1<span class="op">),(</span>S1<span class="op">,</span><span class="dv">0</span><span class="op">,</span>S0<span class="op">),</span> <span class="op">(</span>S1<span class="op">,</span><span class="dv">1</span><span class="op">,</span>S1<span class="op">)</span> <span class="op">}</span></span></code></pre></div>
</p><p>We can also represent the transitions as a table, called transition table:</p><table cellspacing="0" cellpadding="0" class="boxed" style="border-collapse: collapse;"><tr><td align="center" style="border: 1px solid black;"><p><span style="font-weight: bold">States</span></p></td><td align="center" style="border: 1px solid black;"><p><span style="font-weight: bold">0</span></p></td><td align="center" style="border: 1px solid black;"><p><span style="font-weight: bold">1</span></p></td></tr><tr><td align="center" style="border: 1px solid black;"><p>S0</p></td><td align="center" style="border: 1px solid black;"><p>S0</p></td><td align="center" style="border: 1px solid black;"><p>S1</p></td></tr><tr><td align="center" style="border: 1px solid black;"><p>S1</p></td><td align="center" style="border: 1px solid black;"><p>S0</p></td><td align="center" style="border: 1px solid black;"><p>S1</p></td></tr></table></li></ul></div></p></li><li><p><div class="SIntrapara">Nondeterministic Finite Automaton (NFA)
</div><div class="SIntrapara"><ul><li><p>An NFA is a finite-state machine in which a state and input symbol pair can lead to zero, one,
or multiple next states.</p></li><li><p>NFAs may include epsilon (&#949;) transitions, allowing the machine to move
to another state without consuming any input.</p></li><li><p>It reads input symbols one at a time and can branch into multiple possible paths simultaneously.</p></li><li><p>An input string is accepted if any path leads to a final state.</p></li><li><p>Example:</p><p><img src="nfa2.svg" alt="" width="501pt" height="165pt"/></p></li></ul></div></p></li></ul></div></p><p><div class="SIntrapara">Formally, an NFA is a 5-tuple (&#931;, Q, q0, F, &#948;) where
&#931;, Q, q0, F same as with DFAs. Only difference is that,
NFA&rsquo;s transitions are specified as &#948; &#8838; Q x (&#931; &#8746; {&#949;}) x Q. A transition &#948; is a subset of Q &#215; (&#931; &#8746; {&#949;}) &#215; Q, which means:
</div><div class="SIntrapara"><ul><li><p>Each transition is a triple (current state, input symbol or &#949;, next state)</p></li><li><p>For a given state and input (or &#949;), the NFA may move to one or more possible next states.</p></li><li><p>Since &#948; is a subset, it allows multiple transitions for the same (state, input) pair, or even no transitions at all.</p></li></ul></div></p><h4 class="heading">5.9<tt>&nbsp;</tt><a name="(part._.Reducing_.Regular_.Expressions_to_.N.F.As)"></a>Reducing Regular Expressions to NFAs<span class="button-group"><a href="#(part._.Reducing_.Regular_.Expressions_to_.N.F.As)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Given a regular expression A, our goal is to construct an equivalent NFA, denoted as
&#10216;A&#10217; = (&#931;, Q, q&#8320;, F, &#948;).</p><p>Regular expressions are defined recursively from primitive RE languages.
Each component of a regular expression corresponds to a small NFA fragment, and these fragments are combined according to the operators used in the expression.</p><p>Throughout the construction, we maintain the invariant |F| = 1, meaning that each NFA we build will have exactly one final state.</p><p>We will define &lt;A&gt; for base cases: &#963; , &#949; , &#8709;  where &#963; is a symbol in &#931; and and for inductive cases: AB, A|B, A*
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>Recall<span class="op">:</span> NFA is <span class="op">(</span>Î£<span class="op">,</span> Q<span class="op">,</span> q0<span class="op">,</span> F<span class="op">,</span> Î´<span class="op">)</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  where </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    Î£ is the alphabet</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    Q is set of states</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    q0 is starting state</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    F is set of final states</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    Î´ is transition relation</span></code></pre></div>

<span style="font-weight: bold">Base case: &#963;</span></p><p>For a single symbol &#963;, we construct an NFA with two states: the start state and the final state.
The start state transitions to the final state on input &#963;.</p><p><img src="one-symbol.png" alt="" width="319" height="152"/></p><p><div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>Ïƒ<span class="op">&gt;</span> <span class="op">=</span> <span class="op">({</span>Ïƒ<span class="op">},</span> <span class="op">{</span>S0<span class="op">,</span> S1<span class="op">},</span> S0<span class="op">,</span> <span class="op">{</span>S1<span class="op">},</span> <span class="op">{(</span>S0<span class="op">,</span> Ïƒ<span class="op">,</span> S1<span class="op">)}</span> <span class="op">)</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>      <span class="op">(</span> Î£<span class="op">,</span>      Q<span class="op">,</span>    q0<span class="op">,</span>  F<span class="op">,</span>        Î´        <span class="op">)</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
</p><p><span style="font-weight: bold">Base case: &#949;</span></p><p>To recognize &#949;, the empty string, we create an NFA with a single state that serves as both the start and the final state.</p><p><img src="empty-string.png" alt="" width="135" height="115"/>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>Îµ<span class="op">&gt;</span> <span class="op">=</span> <span class="op">(</span>âˆ…<span class="op">,</span> <span class="op">{</span>S0<span class="op">},</span> S0<span class="op">,</span> <span class="op">{</span>S0<span class="op">},</span> âˆ…<span class="op">)</span></span></code></pre></div>
</p><p><span style="font-weight: bold">Base case:  &#8709;</span>
To represent the empty set (&#8709;), we construct an NFA with two states: a start state and a final state.
There are no transitions between them, so the final state is unreachable from the start state.
This automaton accepts no strings.</p><p><img src="empty-set.png" alt="" width="309" height="127"/></p><p><div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>âˆ…<span class="op">&gt;</span> <span class="op">=</span> <span class="op">(</span>âˆ…<span class="op">,</span> <span class="op">{</span>S0<span class="op">,</span> S1<span class="op">},</span> S0<span class="op">,</span> <span class="op">{</span>S1<span class="op">},</span> âˆ…<span class="op">)</span></span></code></pre></div>
</p><p>Now, let us look at the inductive cases.</p><p><span style="font-weight: bold">Concatenation</span></p><p>Given a machine A and B, we want to build a concatenation AB.</p><p><img src="concat1.png" alt="" width="563" height="188"/>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>A<span class="op">&gt;</span> <span class="op">=</span>  <span class="op">(</span>Î£A<span class="op">,</span> QA<span class="op">,</span> qA<span class="op">,</span> <span class="op">{</span>fA<span class="op">},</span> Î´A<span class="op">)</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>B<span class="op">&gt;</span> <span class="op">=</span>  <span class="op">(</span>Î£B<span class="op">,</span> QB<span class="op">,</span> qB<span class="op">,</span> <span class="op">{</span>fB<span class="op">},</span> Î´B<span class="op">)</span></span></code></pre></div>
</p><p>We construct the new NFA by adding an &#949;-transition from the final state of A to the start state of B.
The start state of the combined NFA is the start state of A, and the final state is the final state of B.</p><p><img src="concat2.png" alt="" width="538" height="174"/>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>A<span class="op">&gt;</span> <span class="op">=</span>  <span class="op">(</span>Î£A<span class="op">,</span> QA<span class="op">,</span> qA<span class="op">,</span> <span class="op">{</span>fA<span class="op">},</span> Î´A<span class="op">)</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>B<span class="op">&gt;</span> <span class="op">=</span>  <span class="op">(</span>Î£B<span class="op">,</span> QB<span class="op">,</span> qB<span class="op">,</span> <span class="op">{</span>fB<span class="op">},</span> Î´B<span class="op">)</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>AB<span class="op">&gt;</span> <span class="op">=</span>  <span class="op">(</span>Î£A âˆª Î£B<span class="op">,</span> QA âˆª QB<span class="op">,</span> qA<span class="op">,</span> <span class="op">{</span>fB<span class="op">},</span> Î´A âˆª Î´B âˆª <span class="op">{(</span>fA<span class="op">,</span>Îµ<span class="op">,</span>qB<span class="op">)}</span> <span class="op">)</span></span></code></pre></div>
</p><p><span style="font-weight: bold">Union</span></p><p>Given a machine A and B, we want to build a union A|B.</p><p><img src="union1.png" alt="" width="293" height="211"/>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>A<span class="op">&gt;</span> <span class="op">=</span>  <span class="op">(</span>Î£A<span class="op">,</span> QA<span class="op">,</span> qA<span class="op">,</span> <span class="op">{</span>fA<span class="op">},</span> Î´A<span class="op">)</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>B<span class="op">&gt;</span> <span class="op">=</span>  <span class="op">(</span>Î£B<span class="op">,</span> QB<span class="op">,</span> qB<span class="op">,</span> <span class="op">{</span>fB<span class="op">},</span> Î´B<span class="op">)</span></span></code></pre></div>

We construct the new NFA by adding a new start state S0, a new final state S1,
and adding &#949;-transitions from S0 to the starts states of A and B, adding  &#949;-transitions from
the final states of A and B to the new final state S1.</p><p><img src="union2.png" alt="" width="414" height="208"/></p><p><div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>A<span class="op">|</span>B<span class="op">&gt;</span> <span class="op">=</span>  <span class="op">(</span>Î£A âˆª Î£B<span class="op">,</span> QA âˆª QB âˆª <span class="op">{</span>S0<span class="op">,</span>S1<span class="op">},</span> S0<span class="op">,</span> <span class="op">{</span>S1<span class="op">},</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>         Î´A âˆª Î´B âˆª <span class="op">{(</span>S0<span class="op">,</span>Îµ<span class="op">,</span>qA<span class="op">),</span> <span class="op">(</span>S0<span class="op">,</span>Îµ<span class="op">,</span>qB<span class="op">),</span> <span class="op">(</span>fA<span class="op">,</span>Îµ<span class="op">,</span>S1<span class="op">),</span> <span class="op">(</span>fB<span class="op">,</span>Îµ<span class="op">,</span>S1<span class="op">)})</span></span></code></pre></div>
</p><p><span style="font-weight: bold">Closure (Kleene Star)</span></p><p>Given a machine A and B, we want to build A*.</p><p><img src="star1.png" alt="" width="263" height="108"/>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>A<span class="op">&gt;</span> <span class="op">=</span>  <span class="op">(</span>Î£A<span class="op">,</span> QA<span class="op">,</span> qA<span class="op">,</span> <span class="op">{</span>fA<span class="op">},</span> Î´A<span class="op">)</span></span></code></pre></div>
</p><p><div class="SIntrapara">We construct the new NFA by adding
</div><div class="SIntrapara"><ul><li><p>a new start state S0</p></li><li><p>a new final state S1</p></li><li><p>&#949;-transitions from S0 to the starts state of A</p></li><li><p>&#949;-transition from the final state of A the new final state S1</p></li><li><p>&#949;-transition from S0 to S1</p></li><li><p>&#949;-transition from S1 to S0</p></li></ul></div></p><p><img src="star2.png" alt="" width="494" height="173"/>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>A<span class="op">*&gt;</span> <span class="op">=</span>  <span class="op">(</span>Î£A<span class="op">,</span> QA âˆª <span class="op">{</span>S0<span class="op">,</span>S1<span class="op">},</span> S0<span class="op">,</span> <span class="op">{</span>S1<span class="op">},</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>         Î´A âˆª <span class="op">{(</span>fA<span class="op">,</span>Îµ<span class="op">,</span>S1<span class="op">),</span> <span class="op">(</span>S0<span class="op">,</span>Îµ<span class="op">,</span>qA<span class="op">),</span> <span class="op">(</span>S0<span class="op">,</span>Îµ<span class="op">,</span>S1<span class="op">),</span> <span class="op">(</span>S1<span class="op">,</span>Îµ<span class="op">,</span>S0<span class="op">)})</span></span></code></pre></div>
</p><p><span style="font-weight: bold">RE to NFA Example</span></p><p>RE: ab*|cd</p><p><img src="nfa7.svg" alt="" width="782pt" height="172pt"/></p><h4 class="heading">5.10<tt>&nbsp;</tt><a name="(part._.Subset_.Construction__.N.F.A_to_.D.F.A_.Conversion_)"></a>Subset Construction (NFA to DFA Conversion)<span class="button-group"><a href="#(part._.Subset_.Construction__.N.F.A_to_.D.F.A_.Conversion_)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p><div class="SIntrapara">In this section, we will introduce the algorithm to reduce an NFA to a DFA. The algorithm is called
subset construction algorithm.
It takes NFA (&#931;, Q, q0, Fn, &#948;) as an input, and returns DFA (&#931;, R, r0, Fd, &#948;). It uses
 two subroutines
 </div><div class="SIntrapara"><ul><li><p>&#949;-closure(&#948;, p) (and &#949;-closure(&#948;, Q)) </p></li><li><p>move(&#948;, p, &#963;) (and move(&#948;, Q, &#963;))</p></li></ul></div></p><p>where p is an NFA state.</p><h5 class="heading">5.10.1<tt>&nbsp;</tt><a name="(part._.Subset_.Construction_.Algorithm)"></a>Subset Construction Algorithm<span class="button-group"><a href="#(part._.Subset_.Construction_.Algorithm)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p><div class="sourceCode" id="cb1"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>Let r0 = e-closure(Î´, q0)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>add r0 <span class="kw">to</span> R</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>While âˆƒ an unmarked state r âˆˆ R:</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  Mark r</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  For each Ïƒ âˆˆ Î£</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>     Let m = move(delta, r, Ïƒ)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>     Let e = e-closure(Î´, m)</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>     If e âˆ‰ R</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>        Let R = R âˆª {e}</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>     Let Î´&#39; = Î´&#39;âˆª { r, Ïƒ, e }</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a> Let F = { r âˆ£ âˆƒ s âˆˆ r  <span class="kw">with</span>  s âˆˆ F n }</span></code></pre></div>
</p><h5 class="heading">5.10.2<tt>&nbsp;</tt><a name="(part._.Example_1)"></a>Example 1<span class="button-group"><a href="#(part._.Example_1)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>NFA:</p><p><img src="nfa1.svg" alt="" width="381pt" height="339/2pt"/></p><p><table cellspacing="0" cellpadding="0" class="boxed" style="border-collapse: collapse;"><tr><td align="center" style="border: 1px solid black;"><p><span style="font-weight: bold">States</span></p></td><td align="center" style="border: 1px solid black;"><p><span style="font-weight: bold">a</span></p></td><td align="center" style="border: 1px solid black;"><p><span style="font-weight: bold">b</span></p></td><td align="center" style="border: 1px solid black;"><p><span style="font-weight: bold">c</span></p></td></tr><tr><td align="center" style="border: 1px solid black;"><p>{0,2}</p></td><td align="center" style="border: 1px solid black;"><p>1</p></td><td align="center" style="border: 1px solid black;"><p>&#216;</p></td><td align="center" style="border: 1px solid black;"><p>2</p></td></tr><tr><td align="center" style="border: 1px solid black;"><p>1</p></td><td align="center" style="border: 1px solid black;"><p>&#216;</p></td><td align="center" style="border: 1px solid black;"><p>{0,2}</p></td><td align="center" style="border: 1px solid black;"><p>&#216;</p></td></tr><tr><td align="center" style="border: 1px solid black;"><p>2</p></td><td align="center" style="border: 1px solid black;"><p>&#216;</p></td><td align="center" style="border: 1px solid black;"><p>&#216;</p></td><td align="center" style="border: 1px solid black;"><p>2</p></td></tr></table></p><p>DFA:</p><p><img src="dfa1.svg" alt="" width="306pt" height="219pt"/></p><h5 class="heading">5.10.3<tt>&nbsp;</tt><a name="(part._.Example_2)"></a>Example 2<span class="button-group"><a href="#(part._.Example_2)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>NFA:</p><p><img src="nfa2.svg" alt="" width="501pt" height="165pt"/></p><p><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="boxed" style="border-collapse: collapse;"><tr><td align="center" style="border: 1px solid black;"><p><span style="font-weight: bold">States</span></p></td><td align="center" style="border: 1px solid black;"><p><span style="font-weight: bold">a</span></p></td><td align="center" style="border: 1px solid black;"><p><span style="font-weight: bold">b</span></p></td></tr><tr><td align="center" style="border: 1px solid black;"><p>{1,3}</p></td><td align="center" style="border: 1px solid black;"><p>&#216;</p></td><td align="center" style="border: 1px solid black;"><p>{2,4}</p></td></tr><tr><td align="center" style="border: 1px solid black;"><p>{2,4}</p></td><td align="center" style="border: 1px solid black;"><p>{2,3}</p></td><td align="center" style="border: 1px solid black;"><p>&#216;</p></td></tr><tr><td align="center" style="border: 1px solid black;"><p>{2,3}</p></td><td align="center" style="border: 1px solid black;"><p>{2,3}</p></td><td align="center" style="border: 1px solid black;"><p>4</p></td></tr><tr><td align="center" style="border: 1px solid black;"><p>4</p></td><td align="center" style="border: 1px solid black;"><p>&#216;</p></td><td align="center" style="border: 1px solid black;"><p>&#216;</p></td></tr></table></div><div class="SIntrapara">DFA:</div></p><p><img src="dfa2.svg" alt="" width="366pt" height="100pt"/></p><h5 class="heading">5.10.4<tt>&nbsp;</tt><a name="(part._.Example_3)"></a>Example 3<span class="button-group"><a href="#(part._.Example_3)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p><img src="nfa3.svg" alt="" width="438pt" height="159pt"/></p><p><table cellspacing="0" cellpadding="0" class="boxed" style="border-collapse: collapse;"><tr><td align="center" style="border: 1px solid black;"><p>States</p></td><td align="center" style="border: 1px solid black;"><p>a</p></td></tr><tr><td align="center" style="border: 1px solid black;"><p>{1,2,4}</p></td><td align="center" style="border: 1px solid black;"><p>{1,2,3,4}</p></td></tr><tr><td align="center" style="border: 1px solid black;"><p>{1,2,3,4}</p></td><td align="center" style="border: 1px solid black;"><p>{1,2,3,4}</p></td></tr></table></p><p>DFA:</p><p><img src="dfa3.svg" alt="" width="268pt" height="134pt"/></p><h5 class="heading">5.10.5<tt>&nbsp;</tt><a name="(part._.Example_4)"></a>Example 4<span class="button-group"><a href="#(part._.Example_4)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p><img src="nfa4.svg" alt="" width="381pt" height="195pt"/></p><p><table cellspacing="0" cellpadding="0" class="boxed" style="border-collapse: collapse;"><tr><td align="center" style="border: 1px solid black;"><p>States</p></td><td align="center" style="border: 1px solid black;"><p>0</p></td><td align="center" style="border: 1px solid black;"><p>1</p></td></tr><tr><td align="center" style="border: 1px solid black;"><p>{A,C}</p></td><td align="center" style="border: 1px solid black;"><p>{B,C}</p></td><td align="center" style="border: 1px solid black;"><p>{C,D}</p></td></tr><tr><td align="center" style="border: 1px solid black;"><p>{B,C}</p></td><td align="center" style="border: 1px solid black;"><p>C </p></td><td align="center" style="border: 1px solid black;"><p>{C,D}</p></td></tr><tr><td align="center" style="border: 1px solid black;"><p>C </p></td><td align="center" style="border: 1px solid black;"><p>C</p></td><td align="center" style="border: 1px solid black;"><p>{C,D}</p></td></tr><tr><td align="center" style="border: 1px solid black;"><p>{C,D}</p></td><td align="center" style="border: 1px solid black;"><p>C </p></td><td align="center" style="border: 1px solid black;"><p>{C,D}</p></td></tr></table></p><p><img src="dfa4.svg" alt="" width="618pt" height="207pt"/></p><h5 class="heading">5.10.6<tt>&nbsp;</tt><a name="(part._.Example_5)"></a>Example 5<span class="button-group"><a href="#(part._.Example_5)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>NFA:
<img src="nfa5.svg" alt="" width="600pt" height="320pt"/></p><p><table cellspacing="0" cellpadding="0" class="boxed" style="border-collapse: collapse;"><tr><td align="center" style="border: 1px solid black;"><p>States</p></td><td align="center" style="border: 1px solid black;"><p>a</p></td><td align="center" style="border: 1px solid black;"><p>b</p></td></tr><tr><td align="center" style="border: 1px solid black;"><p>0</p></td><td align="center" style="border: 1px solid black;"><p>{0,1}</p></td><td align="center" style="border: 1px solid black;"><p>&#216;</p></td></tr><tr><td align="center" style="border: 1px solid black;"><p>{0,1}</p></td><td align="center" style="border: 1px solid black;"><p>{0,1}</p></td><td align="center" style="border: 1px solid black;"><p>{2,3}</p></td></tr><tr><td align="center" style="border: 1px solid black;"><p>{2,3}</p></td><td align="center" style="border: 1px solid black;"><p>{0,1}</p></td><td align="center" style="border: 1px solid black;"><p>{2,3,4}</p></td></tr><tr><td align="center" style="border: 1px solid black;"><p>{2,3,4}</p></td><td align="center" style="border: 1px solid black;"><p>{0,1}</p></td><td align="center" style="border: 1px solid black;"><p>{2,3,4}</p></td></tr></table></p><p>DFA:</p><p><img src="dfa5.svg" alt="" width="513pt" height="519/2pt"/></p><h5 class="heading">5.10.7<tt>&nbsp;</tt><a name="(part._.Example_6)"></a>Example 6<span class="button-group"><a href="#(part._.Example_6)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h5><p>Language: (a|b)*bb</p><p>NFA:</p><p><img src="nfa6.svg" alt="" width="508pt" height="160pt"/></p><p><table cellspacing="0" cellpadding="0" class="boxed" style="border-collapse: collapse;"><tr><td align="center" style="border: 1px solid black;"><p>States</p></td><td align="center" style="border: 1px solid black;"><p>a</p></td><td align="center" style="border: 1px solid black;"><p>b</p></td></tr><tr><td align="center" style="border: 1px solid black;"><p>1</p></td><td align="center" style="border: 1px solid black;"><p>1</p></td><td align="center" style="border: 1px solid black;"><p>{1,2}</p></td></tr><tr><td align="center" style="border: 1px solid black;"><p>{1,2}</p></td><td align="center" style="border: 1px solid black;"><p>1</p></td><td align="center" style="border: 1px solid black;"><p>{1,2,3}</p></td></tr><tr><td align="center" style="border: 1px solid black;"><p>{1,2,3}</p></td><td align="center" style="border: 1px solid black;"><p>1</p></td><td align="center" style="border: 1px solid black;"><p>{1,2,3}</p></td></tr></table></p><p>DFA:</p><p><img src="dfa6.svg" alt="" width="405pt" height="471/2pt"/></p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="regexp.html" title="backward to &quot;4 OCaml Regular Expressions&quot;" data-pltdoc="x" rel="prev">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;CMSC 330 Lecture Notes&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<span class="nonavigation">next &rarr;</span></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>