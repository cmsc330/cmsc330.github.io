<!DOCTYPE html>
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>5&nbsp;OCaml Regular Expressions</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><link rel="stylesheet" type="text/css" href="extra.css" title="default"/><link rel="stylesheet" type="text/css" href="faq.css" title="default"/><link rel="stylesheet" type="text/css" href="fancyverb.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="accordion.js"></script><script type="text/javascript" src="manual-racket.js"></script></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">CMSC 330 Lecture Notes</a></td></tr></table></div><div class="tocviewsublistonly" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="intro.html" class="tocviewlink" data-pltdoc="x">Introduction</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="ocaml.html" class="tocviewlink" data-pltdoc="x">Functional Programming with OCaml</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="imperative-ocaml.html" class="tocviewlink" data-pltdoc="x">Imperative Programming with OCaml</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="pbt.html" class="tocviewlink" data-pltdoc="x">Property-<wbr></wbr>Based Randomized Testing (PBT)</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">OCaml Regular Expressions</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="Finite_Automata.html" class="tocviewlink" data-pltdoc="x">Finite Automata</a></td></tr><tr><td align="right">7&nbsp;</td><td><a href="Context_Free_Grammars.html" class="tocviewlink" data-pltdoc="x">Context Free Grammars</a></td></tr><tr><td align="right">8&nbsp;</td><td><a href="Parsing.html" class="tocviewlink" data-pltdoc="x">Parsing</a></td></tr><tr><td align="right">9&nbsp;</td><td><a href="Operational_Semantics.html" class="tocviewlink" data-pltdoc="x">Operational Semantics</a></td></tr><tr><td align="right">10&nbsp;</td><td><a href="Type_Checking.html" class="tocviewlink" data-pltdoc="x">Type Checking</a></td></tr><tr><td align="right">11&nbsp;</td><td><a href="Lambda_Calculus.html" class="tocviewlink" data-pltdoc="x">Lambda Calculus</a></td></tr><tr><td align="right">12&nbsp;</td><td><a href="Rust.html" class="tocviewlink" data-pltdoc="x">Rust</a></td></tr><tr><td align="right">13&nbsp;</td><td><a href="Software_Security.html" class="tocviewlink" data-pltdoc="x">Software Security</a></td></tr><tr><td align="right">14&nbsp;</td><td><a href="exercises.html" class="tocviewlink" data-pltdoc="x">Exercises</a></td></tr></table></div></div></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">9.0</span></div><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="pbt.html" title="backward to &quot;4 Property-Based Randomized Testing (PBT)&quot;" data-pltdoc="x" rel="prev">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;CMSC 330 Lecture Notes&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="Finite_Automata.html" title="forward to &quot;6 Finite Automata&quot;" data-pltdoc="x" rel="next">next &rarr;</a></span>&nbsp;</div><section class="SsectionLevel2" id="section 5"><h2 class="heading">5<span class="stt">&nbsp;</span><a name="(part._regexp)"></a>OCaml Regular Expressions<span class="button-group"><a href="#(part._regexp)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h2><details class="SubFlow accordion-section"><summary><span style="font-weight: bold">What Are Regular Expressions?</span></summary><details class="SubFlow"><summary>The String module in OCaml provides many useful functions for manipulating strings, including:</summary><ul><li><p>Concatenating two strings</p></li><li><p>Extracting substrings</p></li><li><p>Searching for substrings and replacing them with something else</p></li></ul><p>A regular expression is a pattern that describes a set of strings. Regular expressions are useful for:</p><ul><li><p>Searching and matching text</p></li><li><p>Formally describing strings</p></li><li><p>Defining the symbols (lexemes or tokens) that make up a language</p></li></ul><p>Regular expressions are common across many languages and tools, including sed, grep, awk, Perl, Python, and Ruby. They were popularized (and made fast) as a language feature in Perl and are based on elegant theoretical foundations.</p><p>There exist multiple Regexp libraries. Most common ones are RE and Str:</p><ul><li><p><span style="font-weight: bold">RE</span>: a pure OCaml regular expressions library that supports several formats (glob, posix, str&#8230;). In this lecture, we will use the posix format of the RE library.</p></li><li><p><span style="font-weight: bold">Str</span>: OCaml comes with the Str module. This module is not recommended because it is not particularly fast and does not support Unicode.</p></li></ul></details><details class="SubFlow"><summary>Here is a basic example that uses the RE library:</summary></details></details><details class="SubFlow accordion-section"><summary><span style="font-weight: bold">Basic Concepts</span></summary><details class="SubFlow"><summary>Regular expressions (regex) provide a formal way of describing patterns in strings. They form the foundation for pattern matching.</summary><p>A regular expression is constructed from two types of components:</p><ul><li><p><div class="SIntrapara"><span style="font-weight: bold">Basic Building Blocks</span>
</div><div class="SIntrapara"><ul><li><p>Empty set (&#8709;): Matches nothing</p></li><li><p>Empty string (&#949;): Matches an empty string</p></li><li><p>Symbols (character literals) from the alphabet: Any character from &#931; (the alphabet)</p></li></ul></div></p></li><li><p><div class="SIntrapara"><span style="font-weight: bold">Operations on Building Blocks</span>
</div><div class="SIntrapara"><ul><li><p>Union (|): Provides a choice between patterns</p></li><li><p>Concatenation (. or implicit): Joins patterns together</p></li><li><p>Kleene Star (*): Repeats a pattern zero or more times</p></li></ul></div></p></li><li><p><span style="font-weight: bold">Building Complex Patterns</span>: By applying these operations recursively, we can construct arbitrarily complex patterns from the basic building blocks. This compositional structure makes regular expressions both powerful and mathematically elegant.</p></li></ul><ul><li><p><span class="stt">"OCaml"</span>: Strings are matched exactly</p></li><li><p><span class="stt">"a|b"</span>: A vertical bar separates alternatives (Boolean OR)</p></li><li><p><span class="stt">"ab*"</span>: A quantifier (<span class="stt">?</span>, <span class="stt">*</span>, <span class="stt">+</span>, <span class="stt">{n}</span>) after an element specifies how many times the element is allowed to repeat</p></li></ul></details><details class="SubFlow"><summary><span style="font-weight: bold">Repetition in Regular Expressions</span></summary><p>The following are suffixes on a regular expression <span class="stt">e</span>:</p><table cellspacing="0" cellpadding="0"><tr><td><p><span style="font-weight: bold">Pattern</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span style="font-weight: bold">Meaning</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span style="font-weight: bold">Example</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span style="font-weight: bold">Matches</span></p></td></tr><tr><td><p>e*</p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p>Zero or more occurrences of e</p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p>a*</p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p>"",a,aa,aaa, ...</p></td></tr><tr><td><p>e+</p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p>One or more occurrences of e (same as ee*)</p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p>a+</p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p>a,aa,aaa, ...</p></td></tr><tr><td><p>e?</p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p>Exactly zero or one e</p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p>a?</p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p>"",a</p></td></tr><tr><td><p>e{x}</p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p>Exactly x occurrences of e</p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p>a{3}</p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p>aaa</p></td></tr><tr><td><p>e{x,}</p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p>At least x occurrences of e</p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p>a{2,}</p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p>aa,aaa, ...</p></td></tr><tr><td><p>e{x,y}</p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p>At least x and at most y occurrences of e</p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p>a{2,4}</p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p>aa, aaa, aaaa</p></td></tr></table><p>For example:</p><ul><li><p><span class="stt">bc*</span> matches <span class="stt">"b"</span>, <span class="stt">"bc"</span>, <span class="stt">"bcc"</span>, ...</p></li><li><p><span class="stt">a+b*</span> matches <span class="stt">"a"</span>, <span class="stt">"ab"</span>, <span class="stt">"aa"</span>, <span class="stt">"aab"</span>, <span class="stt">"aabb"</span>, <span class="stt">"aabbb"</span>, <span class="stt">"aaa"</span>, ...</p></li></ul><p><span style="font-weight: bold">Precedence</span>: Use parentheses to disambiguate. Note that parentheses also have another use: to extract matches (capturing groups).</p><ul><li><p><span class="stt">(OCaml)*</span> means "", "OCaml", "OCamlOCaml", ...</p></li><li><p><span class="stt">OCaml*</span> means "OCam", "OCaml", "OCamlllll", ...</p></li></ul></details><details class="SubFlow"><summary><span style="font-weight: bold">Character Classes</span></summary><p>Character classes allow you to match one character from a set:</p><ul><li><p><span class="stt">[abcd]</span>: Matches any of <span class="stt">{"a", "b", "c", "d"}</span> (can also be written as <span class="stt">(a|b|c|d)</span>)</p></li><li><p><span class="stt">[a-zA-Z0-9]</span>: Matches any upper- or lower-case letter or digit</p></li><li><p><span class="stt">[^0-9]</span>: Matches any character except 0&#8211;9 (the <span class="stt">^</span> means "not" and must come first)</p></li><li><p><span class="stt">[\t\n ]</span>: Matches tab, newline, or space</p></li><li><p><span class="stt">[a-zA-Z_\$][a-zA-Z_\$0-9]*</span>: Matches Java identifiers ($ escaped)</p></li></ul><p><span style="font-weight: bold">Special Characters</span>:</p><ul><li><p><span class="stt">^</span>: Beginning of line</p></li><li><p><span class="stt">$</span>: End of line</p></li><li><p><span class="stt">\$</span>: Literal dollar sign</p></li></ul><p>Note: Languages like Ruby and Python provide additional special characters. Be careful with characters that have different meanings in different contexts:</p><ul><li><p><div class="SIntrapara"><span class="stt">^</span>
</div><div class="SIntrapara"><ul><li><p>Inside a character class: means "not" (e.g., <span class="stt">[^0-9]</span>)</p></li><li><p>Outside a character class: means beginning of line</p></li></ul></div></p></li><li><p><div class="SIntrapara"><span class="stt">( )</span>
</div><div class="SIntrapara"><ul><li><p>Inside character classes: literal characters</p></li><li><p>Outside character classes: used for grouping</p></li></ul></div></p></li><li><p><div class="SIntrapara"><span class="stt">-</span>
</div><div class="SIntrapara"><ul><li><p>Inside character classes: range (e.g., <span class="stt">[a-z]</span> means a to z)</p></li><li><p>Outside regular expressions: subtraction</p></li></ul></div></p></li></ul></details><details class="SubFlow"><summary><span style="font-weight: bold">Summary of Regular Expression Syntax</span></summary><p>Let <span class="stt">re</span> represent an arbitrary pattern:</p><ul><li><p><span class="stt">re</span> &#8211; matches regexp <span class="stt">re</span></p></li><li><p><span class="stt">(re1|re2)</span> &#8211; match either <span class="stt">re1</span> or <span class="stt">re2</span></p></li><li><p><span class="stt">(re)*</span> &#8211; match 0 or more occurrences of <span class="stt">re</span></p></li><li><p><span class="stt">(re)+</span> &#8211; match 1 or more occurrences of <span class="stt">re</span></p></li><li><p><span class="stt">(re)?</span> &#8211; match 0 or 1 occurrences of <span class="stt">re</span></p></li><li><p><span class="stt">(re){2}</span> &#8211; match exactly two occurrences of <span class="stt">re</span></p></li><li><p><span class="stt">[a-z]</span> &#8211; same as <span class="stt">(a|b|c|...|z)</span></p></li><li><p><span class="stt">[^0-9]</span> &#8211; match any character that is not 0, 1, etc.</p></li><li><p><span class="stt">^</span>, <span class="stt">$</span> &#8211; match start or end of string</p></li></ul><p>Try out regular expressions at <a href="rubular.com">rubular.com</a></p></details><details class="SubFlow"><summary><span style="font-weight: bold">Regular Expression Examples</span></summary><ul><li><p>Any string containing two consecutive <span style="font-weight: bold">ab</span>: <span class="stt">(ab){2}</span></p></li><li><p>Any string containing <span style="font-weight: bold">a</span> or two consecutive <span style="font-weight: bold">b</span>: <span class="stt">a|bb</span></p></li><li><p>Contains <span style="font-weight: bold">sss</span> or <span style="font-weight: bold">ccc</span>: <span class="stt">s{3}|c{3}</span></p></li><li><p>Contains exactly 2 <span class="stt">b</span>&rsquo;s, not necessarily consecutive: <span class="stt">^[^b]*b[^b]*b[^b]*$</span></p></li><li><p>Starts with <span style="font-weight: bold">c</span>, followed by <span style="font-weight: bold">one lowercase vowel</span>, and ends with <span style="font-weight: bold">any number of lowercase letters</span>: <span class="stt">^c[aeiou][a-z]*$</span></p></li><li><p>Starts with <span style="font-weight: bold">a</span> and has exactly 0 or 1 letter after that: <span class="stt">^a[A-Za-z]?$</span></p></li><li><p>Only lowercase letters, in any amount, in alphabetic order: <span class="stt">^a*b*c*d*e*f*g*h*i*j*k*l*m*n*o*p*q*r*s*t*u*v*w*x*y*z*$</span></p></li><li><p>Contains one or more <span style="font-weight: bold">ab</span> or <span style="font-weight: bold">ba</span>: <span class="stt">(ab|ba)+</span></p></li><li><p>Precisely <span style="font-weight: bold">steve</span>, <span style="font-weight: bold">steven</span>, or <span style="font-weight: bold">stephen</span>: <span class="stt">^ste(ve|ven|phen)$</span></p></li><li><p>Even length string: <span class="stt">^(..)*$</span></p></li><li><p>Even number of lowercase vowels: <span class="stt">^([^aeiou]*[aeiou][^aeiou]*[aeiou][^aeiou]*)*$</span></p></li><li><p>Starts with anything but <span class="stt">b</span>, followed by one or more <span class="stt">a</span>&rsquo;s and then no other characters: <span class="stt">^[^b]a+$</span></p></li></ul></details><details class="SubFlow"><summary><span style="font-weight: bold">Basic Functions</span></summary><ul><li><p><span class="stt">matches</span>: Extracts all matched substrings as a list</p></li><li><p><span class="stt">compile</span>: Compiles a regular expression into an executable version that can be used to match strings</p></li><li><p><span class="stt">exec</span>: Matches a string against the compiled expression and returns the matched groups if any</p></li><li><p><span class="stt">split</span>: Splits a string into chunks separated by the regular expression</p></li></ul></details></details><details class="SubFlow accordion-section"><summary><span style="font-weight: bold">Extracting Substrings with Capturing Groups</span></summary><details class="SubFlow"><summary>Capturing groups allow you to extract specific parts of a matched string. The Re library remembers which strings matched the parenthesized parts of a regular expression. These parts can be referred to as groups.</summary><p>Example:</p><p>By using capturing groups with parentheses, you can extract the numeric values and reformat the output accordingly.</p></details></details></section><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="pbt.html" title="backward to &quot;4 Property-Based Randomized Testing (PBT)&quot;" data-pltdoc="x" rel="prev">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;CMSC 330 Lecture Notes&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="Finite_Automata.html" title="forward to &quot;6 Finite Automata&quot;" data-pltdoc="x" rel="next">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>